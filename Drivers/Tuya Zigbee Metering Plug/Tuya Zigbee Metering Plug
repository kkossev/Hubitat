/**
 *  Tuya Zigbee Metering Plug driver for Hubitat Elevation - Power, Energy, Voltage, Amperage
 *
 *  https://community.hubitat.com/t/release-tuya-zigbee-metering-plug/86465
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License. You may obtain a copy of the License at:
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *  for the specific language governing permissions and limitations under the License.
 *
 *  The initial version was based on "SmartThings/iquix" DHT
 *
 *  ver. 1.0.0 2021-11-09 kkossev - first version: - reads Power, Energy, Voltage, Amperage once every 60 seconds
 *  ver. 1.0.1 2021-11-10 kkossev - added 'pollingInterval' preference; 'amperage' attribute name bug fix; 
 *  ver. 1.1.0 2021-11-12 kkossev - added 'PresenceSensor' capability; the automatic polling can be switched off.
 *  ver. 1.1.1 2021-11-25 kkossev - added Tuya Outlet TS011F fingerprint
 *  ver. 1.1.2 2021-12-24 kkossev - added Tuya / Neo NAS-WR01 fingerprint; fingerprint inClusters correction
 *  ver. 1.2.0 2021-12-29 kkossev - major refactoring and optimizations
 *  ver. 1.2.1 2021-12-29 kkossev - added AlwaysOn option
 *  ver. 1.3.0 2022-01-01 kkossev - added 'HIKING TOMZN DDS238-2 TS0601'
 *  ver. 1.3.1 2022-01-02 kkossev - minor bug fixes
 *  ver. 1.3.2 2022-01-12 kkossev - Tuya cluster command bug fix (HIKING TOMZN TS0601)
 *  ver. 1.4.0 2022-01-23 kkossev - debug / trace logging cleanup; initialize switch and energy automatic reporting mode; energy and switch are excluded from polling; 
 *                                  default debug logging is false, optimizations are true; switch digital/physical bug fixed; added driver version check
 *  ver. 1.4.1 2022-01-27 kkossev - added XH-002P Outlet TS011F fingerprint (no power monitoring!)
 *  ver. 1.4.2 2022-02-20 kkossev - missing Switch capability bug fix
 *  ver. 1.4.3 2022-02-15 kkossev - added 'Tuya RC-RCBO Circuit Breaker' 
 *  ver. 1.4.4 2022-05-08 kkossev - added new fingerprints; [overwrite: true] explicit option for runIn timers; settings reset bug fix; 
 *  ver. 1.4.5 2022-05-24 kkossev - added _TZ3000_5f43h46b XUELILI 16A UK; _TZ3000_r6buo8ba; _TZ3000_ksw8qtmt NOUS A1Z; _TZ3000_1h2x4akh Ajax/Zignito; _TZ3000_ky0fq4ho DIN Relay; GreenPower cluster 0xF2 fix?
 *                                  added childLock, ledMode, powerOnState configuration commands; importURL is the development branch
 *  ver. 1.4.6 2022-06-04 kkossev - added _TZ3000_gjnozsaz;  added on/off switches for power, amperage, voltage and energy reporting (logs+Events); added device display name in all logs
 *  ver. 1.5.0 2022-06-05 kkossev - Bug fix - all settings were reset back in to the defaults on hub reboot; parsing 'other Tuya oddities..'; over current alarm 0x8003; 'Freeze' LED mode (sets the backlight to the current state); 
 *  ver. 1.5.1 2022-06-12 kkossev - ChildLock bug fix
 *  ver. 1.5.2 2022-09-09 kkossev - added _TZ3000_cehuw1lw _TZ3000_typdpbpg; 
 *  ver. 1.6.0 2022-09-12 kkossev - removed 'Health Check' and 'Polling' capabilities (ping and poll buttons); automatic reporting configuration bug fixes; added individual thresholds for W,A,V;
 *                                  added autoReportingEnabled switch(default:false); added resetEnergy command; disabled attributes states are now deleted; added energyPrice (decimal) preference; added setEnergyPrice command; added energyCost calculation and event;
 *  ver. 1.6.1 2022-09-19 kkossev - added html attribute; added energyDuration; added hourlyEnergy; energy and energyCosts are reset on Initialize button; energyCost and hourlyEnergy types changed to NUMBER; fixed autoPoll bug;
 *  ver. 1.6.2 2022-09-28 kkossev - added NON-Tuya plugs fingerprints; removed hardcoded EPVA dividers; SmartThings outlet power and voltage correction; added warning for '_TZ3000_okaz9tjs'; 
 *                                  removed lastAmperage, lastVoltage; negative energy automatic correction; ignoring false zero automatic reports for W,A,V !;  frient A/S SPLZB-131 voltage correction; added processing for power Instantaneous Demand
 *  ver. 1.6.3 2022-11-08 kkossev - added OSRAM 'Plug 01'; maximum power cap set to 13KW; added 'Develco Products A/S' as Frient manufacturer; fixed power events when on/off; added lastHour energy in HTML; added _TZ3000_zloso4jk
 *                                  'not present' bug fix when polling is disabled; removed lastPresenceState; added SiHAS products; added frequency; added powerFactor; fixOtherTuyaOddities() for _TZ3000_okaz9tjs; extendedTuyaMagic
 *  ver. 1.6.4 2022-11-26 kkossev - added Frient Energy Monitor (ZHEMI101); pulseConfiguration; energyMeterMode; removed fixed destEndpoint; isRefreshRequest fix; _TZ3000_okaz9tjs tests; added rejoinCounter; fixed null Zigbee commands bug;
 *  ver. 1.6.5 2022-12-19 kkossev - _TZE204_cjbofhxw Smart Meter w/ Current Transformer ; fixed bug in html for Power attribute; added new models HIKING TOMZN DDS238-2 _TZE200_bkkmqmyo; added MatSee _TZE200_eaac7dkw
 *  ver. 1.6.6 2023-01-20 kkossev - Zigbee 3.0 incompatible with HE _TZ3000_r6buo8ba and _TZ3000_okaz9tjs fingerprints commented out; added SONOFF Z111PL0H-1JX to the isHEProblematic() list; added _TZ3000_7dndcnnb
 *  ver. 1.7.0 2023-01-29 kkossev - added healthStatus;
 *  ver. 1.7.1 2023-02-02 kkossev - added capability 'Health Check'
 *  ver. 1.7.2 2023-02-16 kkossev - InteliJ lint +bug fixes; added ThirdReality 3RSP02028BZ metering plug; powerOnState for non-Tuya plugs
 *  ver. 1.7.3 2023-03-28 kkossev - Third Reality amperage divisor fix; added frequency polling; completely removed presence capability; improvede logging for disabled attributes; hourlyEnergy is not sent of disabled or the deviceHealth is ofline; dummy ping
 *  ver. 1.7.4 2023-04-22 kkossev - (dev.branch) added TS011F _TZ3000_1hwjutgo _TZ3000_lnggrqqi Tuya Circuit Breaker 2P; TS0601 _TZE200_hkdl5fmv circuit breaker w/ energy: power, energy, voltage, amperage; polling and energyMode are set automatically depending on the device type.
 *
 *                                 TODO: RCBO: send temperature event only when changed; raname Hoch to RCBO; revise configure/initialize sequence; 
 *                                 TODO: energyDuration events have 'Days' in the value field!event type should be digital!
 *                                 TODO: Frient plug initialization doesn't work? replace Initialize() w/ Configure() command; implement ping();
 *                                 TODO: 
 *
 */
import groovy.json.*
import groovy.transform.Field
import hubitat.zigbee.zcl.DataType

def version() { "1.7.4" }
def timeStamp() {"2023/04/22 10:30 AM"}

@Field static final Boolean debug = false

metadata {
    definition (name: "Tuya Zigbee Metering Plug", namespace: "kkossev", author: "Krassimir Kossev", importUrl: "https://raw.githubusercontent.com/kkossev/Hubitat/development/Drivers/Tuya%20Zigbee%20Metering%20Plug/Tuya%20Zigbee%20Metering%20Plug", singleThreaded: true ) {
        capability "EnergyMeter"
        capability "PowerMeter"
        capability "CurrentMeter"
        capability "VoltageMeasurement"
        capability "Actuator"    
        capability "Switch"
        capability "Outlet"
        capability "Refresh"
        //capability "Configuration"
        capability "Sensor"
        capability "Health Check"
        
        
        attribute "powerFactor", "NUMBER"
        attribute "energyCost", "NUMBER"
		attribute "energyDuration", "string"
        attribute "html", "string"
        attribute "hourlyEnergy", "NUMBER"
        //attribute "dailyEnergy", "string"
        attribute "healthStatus", "enum", ["unknown", "offline", "online"]
        
        
        command "initialize", [[name: "Manually initialize the plug after switching drivers.\n\r ***** Will load device default values! *****" ]]
        command "childLock", [[name:"Child Lock", type: "ENUM", description: "Select Child Lock mode", constraints: ["--- Select ---", "off", "on"]]]
        command "ledMode", [[name:"LED mode", type: "ENUM", description: "Select LED mode", constraints: ["--- Select ---", "Disabled", "Lit when On", "Lit when Off", "Freeze", "Always Green", "Red when On; Green when Off", "Green when On; Red when Off", "Always Red" ]]]
        command "powerOnState", [[name:"Power On State", type: "ENUM", description: "Select Power On State", constraints: ["--- Select ---", "off", "on", "Last state"]]]
        command "setEnergyPrice", [[name:"setEnergyPrice", type: "STRING", description: "Set the energy cost (rate) for 1 KWh. The value is shown in the Preferences section", constraints: ["STRING"], defaultValue : "0.12"]]
        command "resetEnergy", [[name: "Reset the accumulated Energy value" ]]
        
        if (_DEBUG == true) {
            command "activeEndpoints"
            command "identify", [[name: "Identify the plug for 30 seconds"]]    // works for my OSRAM plug only? :( 
            command "configureReporting", [ 
                [name: "operation*",   type: "ENUM", constraints: ["--- Select ---", "Read", "Write"]],
                [name: "measurement*", type: "ENUM", constraints: ["--- Select ---", ONOFF, ENERGY, POWER, INST_POWER, VOLTAGE, AMPERAGE, FREQUENCY, POWER_FACTOR], description: "Select measurement to configure"],
                [name: "Minimum Reporting Interval (seconds)", type: "STRING", defaultValue : "30", description: "Select Minimum reporting time (in seconds)"],
                [name: "Maximum Reporting Interval (seconds)", type: "STRING", defaultValue : "900", description: "Select Maximum reporting time (in seconds)"],
                [name: "Minimum measurement change",           type: "STRING", defaultValue : "1", description: "Select Minimum measurement change to be reported"]
            ]
            command "test", [[name: "test", type: "STRING", description: "test", defaultValue : ""]]
        }

        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0004,0005,0006,0702,0B04", outClusters:"0019,000A", manufacturer:"_TZ3000_vtscrpmw", model:"TS0121",  deviceJoinName: "Tuya Outlet" //Tuya Smart Plug
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0004,0005,0006,0702,0B04", outClusters:"0019,000A", manufacturer:"_TZ3000_3ooaz3ng", model:"TS0121",  deviceJoinName: "Tuya Outlet" //Tuya Smart Plug        
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0004,0005,0006,0702 0B04", outClusters:"0019,000A", manufacturer:"_TZ3000_rdtixbnu", model:"TS0121",  deviceJoinName: "Tuya Outlet" //Tuya Smart Plug    
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0004,0005,0006,0702,0B04", outClusters:"0019,000A", model:"TS0121", manufacturer:"_TZ3000_g5xawfcq",  deviceJoinName: "Blitzwolf BW-SHP13" //Blitzwolf BW-SHP13  
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0702,0B04,E000,E001", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_cphmq0q7", deviceJoinName: "Tuya Outlet TS011F" //TS011F   
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0702,0B04,E000,E001", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_ps3dmato",  deviceJoinName: "Lellki WK35 Plug Wall Socket"   
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0702,0B04,E000,E001", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_1h2x4akh",  deviceJoinName: "Ajax/Zignito Plug Wall Socket"   
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,0702,0B04,E000,E001,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_w0qqde0g", deviceJoinName: "Neo NAS-WR01 Outlet TS011F"  
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,E000,E001,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_v1pdxuqq", deviceJoinName: "XH-002P Outlet TS011F No Power Monitoring"  // - no power monitoring !
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,E000,E001,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_hyfvrar3", deviceJoinName: "TS011F No Power Monitoring"  // - no power monitoring !
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,E000,E001,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_cymsnfvf", deviceJoinName: "TS011F No Power Monitoring"  // - no power monitoring !
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,E000,E001,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_bfn1w0mm", deviceJoinName: "TS011F No Power Monitoring"  // - no power monitoring !
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,E000,E001,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_gjnozsaz", deviceJoinName: "NEO ZigBee On Off Power Metering Plug"  // https://ultrasmart.pl/en_GB/p/NEO-ZigBee-On-Off-Power-Metering-Plug/81
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0004,0005,EF00", outClusters:"0019,000A", model:"TS0601", manufacturer:"_TZE200_byzdayie", deviceJoinName: "HIKING TOMZN DDS238-2 TS0601_din"
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0004,0005,EF00", outClusters:"0019,000A", model:"TS0601", manufacturer:"_TZE200_bkkmqmyo", deviceJoinName: "HIKING TOMZN DDS238-2 TS0601_din"
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0004,0005,EF00", outClusters:"0019,000A", model:"TS0601", manufacturer:"_TZE200_eaac7dkw", deviceJoinName: "MatSee Plus Energy Meter 80A Din Rail"    // https://www.youtube.com/watch?v=KwTz35OWmP4
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0004,0005,EF00", outClusters:"0019,000A", model:"TS0601", manufacturer:"_TZE200_lsanae15", deviceJoinName: "MatSee Plus Energy Meter 80A Din Rail"    // https://www.aliexpress.com/item/1005004399475951.html
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0004,0005,EF00", outClusters:"0019,000A", model:"TS0601", manufacturer:"_TZE200_fsb6zw01", deviceJoinName: "Tuya Energy Device"  
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0004,0005,EF00", outClusters:"0019,000A", model:"TS0601", manufacturer:"_TZE200_hkdl5fmv", deviceJoinName: "Tuya RC-RCBO Circuit Breaker"
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0004,0005,0006", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_1hwjutgo", deviceJoinName: "Tuya RC-MCB Circuit Breaker 2P"            // https://www.aliexpress.com/item/1005003725997370.html
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0004,0005,0006", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_lnggrqqi", deviceJoinName: "Tuya RC-MCB Circuit Breaker 2P"            // vendor: 'Mumubiz', model: 'ZJSB9-80Z' https://www.aliexpress.com/item/1005002605097816.html not tested  (no power monitoring)
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0004,0005,EF00", outClusters:"0019,000A", model:"TS0601", manufacturer:"_TZE204_cjbofhxw", deviceJoinName: "MatSee Smart Meter with CT"
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,0702,0B04,E001,E000,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_ky0fq4ho", deviceJoinName: "ATMS1602Z DIN Relay"
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,0702,0B04,E001,E000,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_ksw8qtmt", deviceJoinName: "Smart ZigBee Socket NOUS A1Z" //https://nous.technology/product/a1z-1.html
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,0702,0B04,E001,E000,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_5f43h46b", deviceJoinName: " XUELILI 16A UK Standards Smart Outlet"
        // temporary removed for tests //       fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,0702,0B04,E001,E000,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_cehuw1lw", deviceJoinName: "Haozee Smart Zigbee Plug 16A/20A EU Outlet" // https://www.aliexpress.com/item/1005002344798281.html  //
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,0702,0B04,E001,E000,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_typdpbpg", deviceJoinName: "Tuya Smart Zigbee Plug AU 16A" // https://www.aliexpress.com/item/1005004505868292.html
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,0702,0B04,E001,E000,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_zloso4jk", deviceJoinName: "Tuya Smart Zigbee Plug AU 16A" // https://www.aliexpress.com/item/1005004505868292.html
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,0702,0B04,E000,E001,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_7dndcnnb", deviceJoinName: "LELLKI Smart Switch 25A Energy Monitor" // https://www.aliexpress.com/item/1005004564755069.html
        // NOT WORKING WITH HE !
        /*
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0006,0003,0004,0005,E001,0B04,0702", outClusters:"", model:"TS011F", manufacturer:"_TZ3000_okaz9tjs", deviceJoinName: "Lonsonho US Plug 20A Power Monitor"   // NOT WORKING WITH HE!
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0006,0003,0004,0005,E001,0B04,0702",                 model:"TS011F", manufacturer:"_TZ3000_okaz9tjs", deviceJoinName: "UK Plug 20A"
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0006,0003,0004,0005,E001,0B04,0702", outClusters:"", model:"TS011F", manufacturer:"_TZ3000_r6buo8ba", deviceJoinName: "EU Power Outlet"  // @user3186 Application version A0
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0B04,0702", outClusters:"0003,0019,0006,E001", model:"TS011F", manufacturer:"_TZ3000_r6buo8ba", deviceJoinName: "US Power Outlet"  // https://www.aliexpress.com/item/1005004128965720.htm
        */
        // NON-Tuya plugs
        fingerprint profileId:"C05E", endpointId:"03", inClusters:"1000,0000,0003,0004,0005,0006,0B04,FC0F", outClusters:"0019", model:"Plug 01", manufacturer:"OSRAM", deviceJoinName: "OSRAM Plug 01"
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0B05,FC01,FC08", outClusters:"0003,0019", model:"PLUG", manufacturer:"LEDVANCE", deviceJoinName: "Sylvania Outlet"
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0008,1000,FC7C", outClusters:"0005,0019,0020,1000", model:"TRADFRI control outlet", manufacturer:"IKEA of Sweden", deviceJoinName: "IKEA Tradfri Power Outlet"
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0008,FC7C", outClusters:"0005,0019,0020", model:"TRADFRI control outlet", manufacturer:"IKEA of Sweden", deviceJoinName: "IKEA Tradfri Power Outlet"
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006", outClusters:"0000", model:"BASICZBR3", manufacturer:"SONOFF", deviceJoinName: "SONOFF BASICZBR3"
        fingerprint profileId:"0104", endpointId:"02", inClusters:"0000,0003,0702", outClusters:"000A", model:"ZHEMI101", manufacturer:"Develco", deviceJoinName: "Frient Energy Monitor"                    // https://community.hubitat.com/t/frient-energy-monitor-driver/89327/28?u=kkossev
        fingerprint profileId:"0104", endpointId:"02", inClusters:"0000,0702,0003,0009,0B04,0006,0004,0005,0002", outClusters:"0000,0019,000A,0003,0406", model:"SMRZB-143", manufacturer:"Develco Products A/S", deviceJoinName: "Frient/Develco Smart Cable"
        fingerprint profileId:"0104", endpointId:"02", inClusters:"0000,0702,0003,0009,0B04,0006,0004,0005,0002", outClusters:"000A,0019,0003,0406", model:"SPLZB-131", manufacturer:"frient A/S", deviceJoinName: "frient Outlet SPLZB-131"   // frient smart plug mini
        fingerprint profileId:"0104", endpointId:"02", inClusters:"0000,0702,0003,0009,0B04,0006,0004,0005,0002", outClusters:"000A,0019,0003,0406", model:"SPLZB-132", manufacturer:"frient A/S", deviceJoinName: "frient Outlet SPLZB-132"   // frient smart plug mini
        fingerprint profileId:"0104", endpointId:"02", inClusters:"0000,0702,0003,0009,0B04,0006,0004,0005,0002", outClusters:"000A,0019,0003,0406", model:"SPLZB-134", manufacturer:"frient A/S", deviceJoinName: "frient Outlet SPLZB-134"   // frient smart plug mini
        fingerprint profileId:"0104", endpointId:"02", inClusters:"0000,0702,0003,0009,0B04,0006,0004,0005,0002", outClusters:"000A,0019,0003,0406", model:"SPLZB-137", manufacturer:"frient A/S", deviceJoinName: "frient Outlet SPLZB-137"   // frient smart plug mini
        fingerprint profileId:"0104", endpointId:"02", inClusters:"0000,0702,0003,0009,0B04,0006,0004,0005,0002", outClusters:"000A,0019,0003,0406", model:"SMRZB-143", manufacturer:"frient A/S", deviceJoinName: "frient smart cable"        // frient smart cable
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0001,0003,0006,0020,0B04,0702", outClusters:"0003,0004,0019", model:"CCM-300Z", manufacturer:"ShinaSystem", deviceJoinName: "SiHAS Outlet CCM-300Z"                    // SIHAS Smart Plug with on/off button
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,1000,0B04", outClusters:"0019", model:"3RSP02028BZ", manufacturer:"Third Reality, Inc", deviceJoinName: "Third Reality smart plug"                 // https://community.hubitat.com/t/request-to-add-support-for-new-device/110003/3?u=kkossev
        
        // As these metering plugs are (most probably) already supported in the stock HE drivers or other community drivers, the fingerprints are commented out to prevent this driver being automatically selected when paired to HE.
        // Manually switching to this driver for the plugs below will still work.
        /*
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0004,0003,0B04,0702,0402", outClusters:"0004,0019", model:"PMM-300Z1", manufacturer:"ShinaSystem", deviceJoinName: "SiHAS Power Meter PMM-300Z1"        // SIHAS Power Meter 01 0104 0000 01 05 0000 0004 0003 0B04 0702 02 0004 0019
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0004,0003,0B04,0702,0402", outClusters:"0004,0019", model:"PMM-300Z2", manufacturer:"ShinaSystem", deviceJoinName: "SiHAS Energy Monitor PMM-300Z2"     // Single Phase, SIHAS Power Meter 01 0104 0000 01 06 0000 0004 0003 0B04 0702 0402 02 0004 0019
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0004,0003,0B04,0702,0402", outClusters:"0004,0019", model:"PMM-300Z3", manufacturer:"ShinaSystem", deviceJoinName: "SiHAS Energy Monitor PMM-300Z3"     // Three Phase,  SIHAS Power Meter 01 0104 0000 01 06 0000 0004 0003 0B04 0702 0402 02 0004 0019
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0009,000F,0B04", outClusters:"0019", model:"outletv4", manufacturer:"SmartThings", deviceJoinName: "SmartThings outletv4 STS-OUT-US-2"      // 
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,000F,0B04", outClusters:"0019", model:"outletv4", manufacturer:"SmartThings", deviceJoinName: "SmartThings outlet"
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0009,000F,0B04", outClusters:"0019", model:"outlet", manufacturer:"SmartThings", deviceJoinName: "SmartThings outlet IM6001-OTP05"
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0006,0009,0B04", outClusters:"0019", model:"outlet", manufacturer:"Samjin", deviceJoinName: "Samjin outlet"
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0009,0B04,0B05", outClusters:"0003,0019", model:"outlet", manufacturer:"Samjin", deviceJoinName: "Samjin outlet"
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0009,000F,0B04", outClusters:"0019", model:"3200-Sgb", manufacturer:"SmartThings", deviceJoinName: "SmartThings 3200-Sgb F-APP-UK-V2"      //  Check !!! // 'Zigbee Outlet UK with power meter'
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0B04,0702,FC82", outClusters:"0003,000A,0019", model:"ZB-ONOFFPlug-D0005", manufacturer:"LDS", deviceJoinName: "SmartThings ZB-ONOFFPlug-D0005 GP-WOU019BBDWG"   // 'Outlet with power meter'  // This plug only actively reports power. The voltage and current values are always 0
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0B04,0702,FC82", outClusters:"0003,000A,0019", model:"ZB-ONOFFPlug-D0000", manufacturer:"LDS", deviceJoinName: "SmartThings ZB-ONOFFPlug-D0005 GP-WOU019BBDWG"
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0702,0B04", outClusters:"0003", model:"HY0105", manufacturer:"REXENSE", deviceJoinName: "HONYAR Smart Outlet (USB)"
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0702,0B04", outClusters:"0003", model:"HY0104", manufacturer:"REXENSE", deviceJoinName: "HONYAR Smart Outlet"
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0009,0702,0B04", outClusters:"0003,0019", model:"E_Socket", manufacturer:"HEIMAN", deviceJoinName: "HEIMAN Outlet"
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0B04,0702,FC82", outClusters:"0003,000A,0019", model:"E1C-NB7", manufacturer:"sengled", deviceJoinName: "Sengled Outlet"    //Sengled Smart Plug with Energy Tracker
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0702,0B05", outClusters:"000A,0019", model:"E1C-NB7", manufacturer:"Jasco Products", deviceJoinName: "Jasco Outlet"       // Check - cluster 0x0B05 ???
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0702,0B05", outClusters:"000A,0019", model:"43132", manufacturer:"Jasco Products", deviceJoinName: "Enbrighten Outlet"    //Enbrighten In-Wall Smart Outlet With Energy Monitoring 43132
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0702,0B05", outClusters:"000A,0019", model:"43078", manufacturer:"Jasco Products", deviceJoinName: "Enbrighten Outlet"    //Enbrighten In-Wall Smart Outlet With Energy Monitoring 43078
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0B05,0702", outClusters:"0003,000A,0019", manufacturer:"Jasco", model: "45853", deviceJoinName: "GE ZigBee Plug-In Switch"
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0B05,0702", outClusters:"000A,0019", manufacturer:"Jasco", model: "45856", deviceJoinName: "GE ZigBee In-Wall Switch"
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0001,0003,0004,0005,0006,0B04,0B05,0702", outClusters:"0003,000A,0B05,0019", model:"SZ-ESW01-AU", manufacturer:"Sercomm Corp.", deviceJoinName: "Telstra Outlet"      // 
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0001,0003,0004,0005,0006,0B04,0B05,0702", outClusters:"0003,000A,0B05,0019", model:"SZ-ESW01", manufacturer:"Sercomm Corp.", deviceJoinName: "Sercomm SZ-ESW01"      // 
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0002,0003,0004,0005,0006,0009,0B04,0702", outClusters:"0019,000A,0003,0406", model:"SmartPlug51AU", manufacturer:"Aurora", deviceJoinName: "Aurora SmartPlug"
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0008,0702,0B05", outClusters:"0019", model:"SP 120", manufacturer:"innr", deviceJoinName: "Innr Smart Plug"
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0008,0B05,1000,FC82", outClusters:"000A,0019", model:"SP 222", manufacturer:"innr", deviceJoinName: "Innr SP 222"        
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0702,0B04,0B05,FC03", outClusters:"0019", model:"3210-L", manufacturer:"CentraLite", deviceJoinName: "Iris Smart Plug"
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0B04,0B05,FC03", outClusters:"0019", model:"3210-L", manufacturer:"CentraLite", deviceJoinName: "Iris Smart Plug"
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0B04,0B05", outClusters:"0019", model:"4257050-RZHAC", manufacturer:"CentraLite", deviceJoinName: "CentraLite Smart Plug"
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0B04,0B05", outClusters:"0019", model:"3200-Sgb", manufacturer:"CentraLite", deviceJoinName: "CentraLite Smart Plug"
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0B04,0B05", outClusters:"0019", model:"3200", manufacturer:"CentraLite", deviceJoinName: "CentraLite Smart Plug"
        */
        // experimental
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,FC57,FCA0", outClusters:"0019", model:"Z111PL0H-1JX", manufacturer:"SONOFF", deviceJoinName: "SONOFF smart plug" // https://community.hubitat.com/t/help-getting-started-with-a-smart-plug-driver/109480/5?u=kkossev           // https://community.hubitat.com/t/frient-energy-monitor-driver/89327/28?u=kkossev
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,FC57,FCA0", outClusters:"0019", model:"Z111PL0H-1JX", manufacturer:"Woolley", deviceJoinName: "Woolley smart plug" // not tested
        fingerprint profileId:"C05E", endpointId:"0D", inClusters:"1000", outClusters:"1000", model:"unknown", manufacturer:"unknown", deviceJoinName: "SONOFF smart plug"                                   // SONOFF Z111PL0H-1JX
    }
    
    
    preferences {
        input (name: "logEnable", type: "bool", title: "<b>Debug logging</b>", description: "<i>Debug information, useful for troubleshooting. Recommended setting is <b>off</b></i>", defaultValue: false)
        input (name: "txtEnable", type: "bool", title: "<b>Description text logging</b>", description: "<i>Display measured values in HE log page. Recommended setting is <b>on</b></i>", defaultValue: true)
        input (name: "autoReportingEnabled", type: "bool", title: "<b>Automatic reporting configuration</b>", description: "<i>Enable the configuration of outlet automatic reporting, if supported by the device. Default setting is <b>off</b></i>", defaultValue: false)
        input (name: "autoPollingEnabled", type: "bool", title: "<b>Automatic polling</b>", description: "<i>Enable outlet automatic polling for power, voltage, amperage, energy and switch state. Recommended setting is <b>on</b></i>", defaultValue: true)
        if (autoPollingEnabled?.value == true) {
            input (name: "pollingInterval", type: "number", title: "<b>Polling interval</b>, seconds", description: "<i>The time period when the smart plug will be polled for power, voltage and amperage readings. Recommended setting is <b>60 seconds</b></i>", 
                   range: "10..3600", defaultValue: defaultPollingInterval)
        }
        input (name: "alwaysOn", type: "bool", title: "<b>Always On</b>", description: "<i>Disable switching OFF for plugs that must be always On</i>", defaultValue: false)
        input (name: "optimizations", type: "bool", title: "<b>Optimize polling and logging</b>", description: "<i>Additional optimizations to reduce the hub load</i>. Recommended value is <b>on</b>", defaultValue: true)
        if (optimizations?.value == true || autoReportingEnabled?.value == true) {
            input (name: "energyMinReportingTime", type: "number", title: "<b>Shortest reporting interval</b>, seconds", description: "<i>The minimum allowed time between two automatic reports. Recommended setting is <b>30 seconds</b></i>", 
                range: "1..86399", defaultValue: 30)
            input (name: "energyMaxReportingTime", type: "number", title: "<b>Longest reporting interval</b>, seconds", description: "<i>The maximum time without automatic reports. Recommended setting is <b>900 seconds</b></i>", 
                range: "10..86400", defaultValue: 900)
            // 09/23/2022
            input (name: "energyMode", type: "enum", title: "<b>Energy Reporting</b>", description:"<i>Select Energy Reporting Mode</i>", defaultValue: "POLLED", options: energyModeOptions)
            if (isEnergyEnabled()) {    // if (energyMode?.value == true)
                if (energyMode == "FIXED") {     // "4":"Fixed Power Load"
                    input (name: "fixedPower", type: "number", title: "<b>Fixed Power</b>, W", description: "<i>The fixed power consumption when the plug is switched on</i>", range: "1..9000", defaultValue: 100)
                }
                input (name: "energyPrice", type: "text", title: "<b>Energy price for 1 KWh</b>, \$", description: "<i>Energy price for KWh used in the Energy Cost calculations.</i>", defaultValue: "0.21326")
                input (name: "energyThreshold", type: "number", title: "<b>Energy minimum change to be reported</b>, Wh", description: "<i>The minimum Energy change that will trigger reporting.</i>", range: "1..10000", defaultValue: 1)
            }
           
            input (name: "reportPower", type:    "bool", title: "<b>Power Reporting Off or On</b>",  description:   "<i>(Disable reporting (Off) when not desired)</i>", defaultValue: true)
            if (reportPower?.value == true) {
                input (name: "powerThreshold", type: "number", title: "<b>Power minimum change to be reported</b>, W", description: "<i>The minimum Power change that will trigger reporting.</i>", range: "1..10000", defaultValue: 1)
            }
            if (!isFrientEnergyMonitor()) {
                input (name: "reportAmperage", type: "bool", title: "<b>Amperage Reporting Off or On</b>", description: "<i>(Disable reporting (Off) when not desired)</i>", defaultValue: true)
                if (reportAmperage?.value == true) {
                    input (name: "amperageThreshold", type: "number", title: "<b>Amperage minimum change to be reported</b>, mA", description: "<i>The minimum Amperage change that will trigger reporting.</i>", range: "1..10000", defaultValue: 25)
                }
                input (name: "reportVoltage", type:  "bool", title: "<b>Voltage Reporting Off or On</b>",  description: "<i>(Disable reporting (Off) when not desired)</i>", defaultValue: true)
                if (reportVoltage?.value == true) {
                    input (name: "voltageThreshold", type: "number", title: "<b>Voltage minimum change to be reported</b>, V", description: "<i>The minimum Voltage change that will trigger reporting.</i>", range: "1..10000", defaultValue: 1)
                }
            }
        } 
        if (isFrientEnergyMonitor() == true) {
            command "pulseConfiguration", [[name: "PulseConfiguration", type: "NUMBER", description: "test", defaultValue : 1000]]
            input (name: "pulseConfiguration", type: "number", title: "<b>Frient Energy Monitor Pulse Configuration</b>", description: "<i>Frient Energy Monitor Pulse Configuration</i>", range: "10..100000", defaultValue: 1000)
            input (name: "frientEnergyMeterMode", type: "enum", title: "<b>Energy Reporting Mode</b>", description:"<i>Select Frient Energy Reporting Mode</i>", defaultValue: "0", options: develcoInterfaceMode)
            //command "setEnergyMeterMode", [[name: "SetEnergyMeterMode*",   type: "ENUM", constraints: develcoInterfaceMode]]
       }        
        input (name: "attribEnable", type:  "bool", title: "<b>Enable HTML Attribute Creation?</b>",  description: "<i>html attribute for use in HE dashboards</i>", defaultValue: false)
    }
}

// Constants
@Field static final Integer presenceCountThreshold = 3
@Field static final Integer defaultPollingInterval = 60
@Field static final Integer debouncingTimer = 300
@Field static final Integer digitalTimer = 1000
@Field static final Integer refreshTimer = 3000
@Field static final Integer MAX_POWER = 15000    // power cap 15 kW
@Field static final String UNKNOWN = "UNKNOWN"
@Field static final String ONOFF = "Switch"
@Field static final String POWER = "Power"
@Field static final String INST_POWER = "InstPower"
@Field static final String ENERGY = "Energy"
@Field static final String VOLTAGE = "Voltage"
@Field static final String AMPERAGE = "Amperage"
@Field static final String FREQUENCY = "Frequency"
@Field static final String POWER_FACTOR = "PowerFactor"

// "energyMode"
@Field static final Map energyModeOptions = [     
    "DISABLED":    "Disabled (Energy and costs will not be reported)", 
    "POLLED":      "Enabled  (Energy is reported by polling the plug [most of Tuya's models])",
    "REPORTED":    "Enabled  (Energy is reported automatically by smart plugs  that do not require polling)"//',
//  "3":           "Enabled  (Energy is calculated from the Power reading multiplied by the time)", 
//  "FIXED":       "Enabled  (Energy is calculated from the fixed Power consumption multiplied by the time)"
]

@Field static final Map develcoInterfaceMode = [   
    '0': 'electricity',
    '1': 'gas',
    '2': 'water',
    '256': 'kamstrup-kmp',
    '257': 'linky',
    '258': 'IEC62056-21',
    '259': 'DSMR-2.3',
    '260': 'DSMR-4.0'
]


private boolean isEnergyEnabled() {energyMode != "DISABLED"}

def getATTRIBUTE_READING_INFO_SET() { 0x0000 }
def getATTRIBUTE_HISTORICAL_CONSUMPTION() { 0x0400 }

private boolean isTuyaSpecificCluster() {device.getDataValue("model") in ["TS0601"] }
private boolean isCircuitBreaker() {device.getDataValue("manufacturer") in ["_TZ3000_ky0fq4ho"] }
private boolean isDinRail()       {device.getDataValue("manufacturer") in ["_TZE200_eaac7dkw", "_TZE200_bkkmqmyo", "_TZE200_lsanae15"] }
private boolean isHEProblematic() {device.getDataValue("manufacturer") in ["_TZ3000_okaz9tjs", "_TZ3000_r6buo8ba", "_TZ3000_cfnprab5", "SONOFF", "Woolley", "unknown"] }
private boolean isHoch()          {device.getDataValue("manufacturer") in ["_TZE200_hkdl5fmv"] }

private boolean isSmartThingsOutlet() { (device.getDataValue("manufacturer") in ["SmartThings"]) || (device.getDataValue("model") in ["outletv4"])}
private boolean isSengledOutlet() { device.getDataValue("model") == "E1C-NB7" }
private boolean isJascoProductsOutlet() { device.getDataValue("manufacturer") == "Jasco Products" }
private boolean isFrientOutlet() { device.getDataValue("manufacturer") in ["frient A/S","Develco Products A/S"]}
private boolean isFrientEnergyMonitor() { state.model in ["ZHEMI101"/* , "SPLZB-131"*/] }
private boolean isCCM300() { device.getDataValue("model") == "CCM-300Z" }
private boolean isSercomm() { device.getDataValue("manufacturer") in ["Sercomm Corp.", " Sercomm Corp."] || device.getDataValue("model") == "SZ-ESW01-AU" }
private boolean isHeiman() { device.getDataValue("manufacturer") == "HEIMAN" }
private boolean isDevelco() { device.getDataValue("model") == "EMIZB-132" }
private boolean isOsramPlug01() {(device.getDataValue('model') == 'Plug 01' && device.getDataValue('manufacturer') == 'OSRAM')}
private boolean isSiHAS() { device.getDataValue("manufacturer") == "ShinaSystem" }
private boolean isThirdReality() { device.getDataValue("manufacturer") == "Third Reality, Inc" }
private boolean isReportingConfigurable() { isSmartThingsOutlet() || isSengledOutlet() || isJascoProductsOutlet() || isFrientEnergyMonitor() || isFrientOutlet() || isCCM300() || isSercomm() || isDevelco() || isSiHAS() || isThirdReality() }

private int getPowerDiv() { ( isThirdReality() || isSengledOutlet() || isJascoProductsOutlet() || isSmartThingsOutlet() || (isTuyaSpecificCluster() && !isDinRail())) ? 10 : 1 }    // Tuya : default powerDiv = 1
private int getEnergyDiv() { ( isSengledOutlet() || isJascoProductsOutlet() ) ? 10000 : (isFrientEnergyMonitor() || isFrientOutlet() || isCCM300() || isSiHAS()) || isThirdReality() ? 1000 : 100 }    // Tuya :  energyDiv = 100
private int getCurrentDiv() { (isHeiman() || isDevelco() || isSiHAS() || device.getDataValue("model") in ["3200-Sgb"]) ? 100 : 1000 }  // Tuya :  currentDiv = 1000
private int getVoltageDiv() { isFrientOutlet()? 100 : isSercomm() ? 125 : ( isTuyaSpecificCluster() || isSmartThingsOutlet() || isSiHAS()) || isThirdReality() ? 10 : 1 }  // Tuya EF00 cluster voltage divider is 10 !
private int getFrequencyDiv() { isFrientOutlet() ? 1000F : isTuyaSpecificCluster() ? 100F : isThirdReality() ? 1F : 10F }
private int getPowerFactorDiv() { isDinRail() ? 1000 : 100 }

private getCLUSTER_TUYA()       { 0xEF00 }
private getSETDATA()            { 0x00 }
private getSETTIME()            { 0x24 }

// Tuya Commands
private getTUYA_REQUEST()       { 0x00 }
private getTUYA_REPORTING()     { 0x01 }
private getTUYA_QUERY()         { 0x02 }
private getTUYA_STATUS_SEARCH() { 0x06 }
private getTUYA_TIME_SYNCHRONISATION() { 0x24 }

// tuya DP type
private getDP_TYPE_RAW()        { "01" }    // [ bytes ]
private getDP_TYPE_BOOL()       { "01" }    // [ 0/1 ]
private getDP_TYPE_VALUE()      { "02" }    // [ 4 byte value ]
private getDP_TYPE_STRING()     { "03" }    // [ N byte string ]
private getDP_TYPE_ENUM()       { "04" }    // [ 0-255 ]
private getDP_TYPE_BITMAP()     { "05" }    // [ 1,2,4 bytes ] as bits

def parse(String description) {
    logDebug "parse: description is $description"
    checkDriverVersion()
    if (state.rxCounter != null) state.rxCounter = state.rxCounter + 1
    setPresent()
    if (isTuyaE00xCluster(description) == true || otherTuyaOddities(description) == true) {
        return null
    }
    def event = [:]
    try {
        event = zigbee.getEvent(description)
    }
    catch ( e ) {
        logWarn "parse: exception caught while parsing description:  ${description}"
        //return null
    }
    if (event) {
        logDebug "Event enter: $event"
        event.type = "physical"
        switch (event.name) {
            case "switch" :
                switchEvent( event.value )
                break
            // for smart plugs that can be configured to fire automatically power and energy events ..
            case "power" :    
                if (!isOsramPlug01()) {
                    powerEvent(event.value/getPowerDiv())
                }
                break
            case "energy" :
                energyEvent(event.value/getEnergyDiv())
                break
            case "temperature" : // SiHAS
                sendEvent(event)
                logInfo "${event.descriptionText}"
                break
            default :
                logDebug "received <b>unhandled event</b> ${event.name} = $event.value"
                break
        }
        return null //event
    }
    else {
        def descMap = [:]
        try {
            descMap = zigbee.parseDescriptionAsMap(description)
        }
        catch ( e ) {
            logWarn "parse: exception caught while parsing descMap:  ${descMap}"
            return null
        }
        logDebug "parse: Desc Map: $descMap"
        if (descMap.attrId != null ) {
            // attribute report received
            List attrData = [[cluster: descMap.cluster ,attrId: descMap.attrId, value: descMap.value, status: descMap.status]]
            descMap.additionalAttrs.each {
                attrData << [cluster: descMap.cluster, attrId: it.attrId, value: it.value, status: it.status]
            }
            attrData.each {
                def map = [:]
                if (it.status == "86") {
                    disableUnsupportedAttribute(descMap.cluster, it.attrId)
                }
                if (it.value == null ) {
                    logWarn "null value attribute report: cluster=${it.cluster} attrId=${it.attrId} status=${it.status} data=${descMap.data}"
                    return null
                }
                else if (it.cluster == "0B04" && it.attrId == "050B") {
                    if (descMap.command == "0A" && safeToInt(zigbee.convertHexToInt(it.value)) == 0 && safeToInt(device.currentValue("power", true)) != 0  && device.currentValue("switch", true)=="on") {
                        logWarn "${device.displayName} ignoring potentially false zero power automatic report!"
                        runInMillis( 3500, pollOnce, [overwrite: true])
                    }
                    else {
                        if (!isOsramPlug01()) {
                            powerEvent(zigbee.convertHexToInt(it.value)/getPowerDiv())
                        }
                    }
                }
                else if (it.cluster == "0B04" && it.attrId == "0505") {
                    if (descMap.command == "0A" && safeToInt(zigbee.convertHexToInt(it.value)) == 0 && safeToInt(device.currentValue("voltage", true)) != 0 && device.currentValue("switch", true)=="on") {
                        logWarn "ignoring potentially false zero voltage automatic report!"
                        runInMillis( 3500, pollOnce, [overwrite: true])
                    }
                    else {
                        voltageEvent(zigbee.convertHexToInt(it.value)/getVoltageDiv())
                    }
                }
                else if (it.cluster == "0B04" && it.attrId == "0508") {
                    if (descMap.command == "0A" && safeToInt(zigbee.convertHexToInt(it.value)) == 0 && (safeToDouble(device.currentValue("amperage", true))*getCurrentDiv() as int) != 0  && device.currentValue("switch", true)=="on") {
                        logWarn "ignoring potentially false zero current automatic report!"
                        runInMillis( 3500, pollOnce, [overwrite: true])
                    }
                    else {
                        amperageEvent(zigbee.convertHexToInt(it.value)/getCurrentDiv())
                    }
                }
                else if (it.cluster == "0B04" && it.attrId == "0510") {
                    powerFactorEvent(zigbee.convertHexToInt(it.value)/getPowerFactorDiv())
                }
                else if (it.cluster == "0B04" && it.attrId == "0300") {
                    frequencyEvent(zigbee.convertHexToInt(it.value)/getFrequencyDiv())
                }
                else if (it.cluster == "0702" && it.attrId == "0000") {    // CurrentSummationDelivered 
                    int value
                    try {
                        value = zigbee.convertHexToInt(it.value)
                    }
                    catch (e) {
                        logWarn "exception caught while converting ${it.value} to integer"
                        return null
                    }
                    energyEvent(value/getEnergyDiv())
                }
                else if (it.cluster == "0702" && it.attrId == "0001") {    // CurrentSummationReceived 
                    logDebug "Current Summation Received (0x0702:0001) raw value = ${zigbee.convertHexToInt(it.value)}"
                }
                else if (it.cluster == "0702" && it.attrId == "0100") {    // CurrentTier1SummationDelivered   
                    logDebug "CurrentTier1SummationDelivered Received (0x0702:0100) hex value = ${it.value}"
                }
                else if (it.cluster == "0702" && it.attrId == "0102") {    // CurrentTier2SummationDelivered  
                    logDebug "CurrentTier2SummationDelivered Received (0x0702:0102) hex value = ${it.value}"
                }
                else if (it.cluster == "0702" && it.attrId == "0200") {    // Status  Frient Energy Meter
                    logDebug "Status  (0x0702:0200) hex value = ${it.value}"
                    if (zigbee.convertHexToInt(it.value) & 0x01) {
                        logWarn "Check Meter!"
                    }
                    if (zigbee.convertHexToInt(it.value) & 0x02) {
                        logWarn "Low Battery!"
                    }
                }
                else if (it.cluster == "0702" && it.attrId == "0300") {    // PulseConfiguration Frient Energy Meter
                    logInfo "PulseConfiguration (0x0702:0300) raw value = ${zigbee.convertHexToInt(it.value)}"
                }
                else if (it.cluster == "0702" && it.attrId == "0301") {    // CurrentSummation Frient Energy Meter
                    logDebug "Current Summation (0x0702:0301) raw value = ${zigbee.convertHexToInt(it.value)}"
                }
                else if (it.cluster == "0702" && it.attrId == "0302") {    // InterFaceMode Frient Energy Meter
                    logInfo "Interface Mode (0x0702:0302) raw value = ${zigbee.convertHexToInt(it.value)}"
                }
                else if (it.cluster == "0702" && it.attrId == "0400") {
                    logDebug "power Instantaneous Demand (0x0702:0400) raw value = ${zigbee.convertHexToInt(it.value)}"
                    powerEvent(zigbee.convertHexToInt(it.value)/getPowerDiv())
                }
                else {
                    logWarn "Unprocessed attribute report: cluster=${it.cluster} attrId=${it.attrId} value=${it.value} status=${it.status} data=${descMap.data}"
                }
            } // for each attribute
        } // if attribute report
        else if (descMap.profileId == "0000") { //zdo
            parseZDOcommand(descMap)
        } 
        else if (descMap.clusterId != null && descMap.profileId == "0104") { // ZHA global command
            parseZHAcommand(descMap)
        } 
        else {
            logWarn "Unprocessed unknown command: cluster=${descMap.clusterId} command=${descMap.command} attrId=${descMap.attrId} value=${descMap.value} data=${descMap.data}"
        }
        return null
    } // descMap
}


def parseOnOffAttributes( it ) {
    logDebug "OnOff attribute ${it.attrId} cluster ${it.cluster } reported: value=${it.value}"
    def mode
    def attrName
    if (it.value == null) {
        logDebug "OnOff attribute ${it.attrId} cluster ${it.cluster } skipping NULL value status=${it.status}"
        return
    }
    def value = zigbee.convertHexToInt(it.value)
    switch (it.attrId) {
        case "4000" :    // non-Tuya GlobalSceneControl (bool), read-only
            attrName = "Global Scene Control"
            mode = value == 0 ? "off" : value == 1 ? "on" : null
            break
        case "4001" :    // non-Tuya OnTime (UINT16), read-only
            attrName = "On Time"
            mode = value
            break
        case "4002" :    // non-Tuya OffWaitTime (UINT16), read-only
            attrName = "Off Wait Time"
            mode = value
            break
        case "4003" :    // non-Tuya "powerOnState" (ENUM8), read-write, default=1 
            attrName = "Power On State"
            mode = value == 0 ? "off" : value == 1 ? "on" : value == 2 ?  "Last state" : "UNKNOWN"
            break
        case "8000" :    // command "childLock", [[name:"Child Lock", type: "ENUM", description: "Select Child Lock mode", constraints: ["off", "on"]]]
            attrName = "Child Lock"
            mode = value == 0 ? "off" : "on"
            break
        case "8001" :    // command "ledMode", [[name:"LED mode", type: "ENUM", description: "Select LED mode", constraints: ["Disabled", "Lit when On", "Lit when Off", "Always Green", "Red when On; Green when Off", "Green when On; Red when Off", "Always Red" ]]]
            attrName = "LED mode"
            if (isCircuitBreaker()) {
                mode = value == 0 ? "Always Green" : value == 1 ? "Red when On; Green when Off" : value == 2 ? "Green when On; Red when Off" : value == 3 ? "Always Red" : null
            }
            else {
                mode = value == 0 ? "Disabled"  : value == 1 ? "Lit when On" : value == 2 ? "Lit when Off" : value == 3 ? "Freeze": null
            }
            break
        case "8002" :    // command "powerOnState", [[name:"Power On State", type: "ENUM", description: "Select Power On State", constraints: ["off","on", "Last state"]]]
            attrName = "Power On State"
            mode = value == 0 ? "off" : value == 1 ? "on" : value == 2 ?  "Last state" : null
            break
        case "8003" : //  Over current alarm
            attrName = "Over current alarm"
            mode = value == 0 ? "Over Current OK" : value == 1 ? "Over Current Alarm" : null
            break
        default :
            logWarn "Unprocessed Tuya OnOff attribute ${it.attrId} cluster ${it.cluster } reported: value=${it.value}"
            return
    }
    logDebug "${attrName} is ${mode}"
}

def switchEvent( value ) {
    def map = [:] 
    boolean bWasChange = false
    if (state.switchDebouncing==true && value==state.lastSwitchState) {    // some plugs send only catchall events, some only read attr reports, but some will fire both...
        logDebug "Ignored duplicated switch event for model ${state.model}"
        runInMillis( debouncingTimer, switchDebouncingClear, [overwrite: true])
        return null
    }
    map.type = state.isDigital == true ? "digital" : "physical"
    if (state.lastSwitchState != value ) {
        bWasChange = true
        logDebug "Switch state changed from <b>${state.lastSwitchState}</b> to <b>${value}</b>"
        runInMillis(6000, pollPower, [overwrite: true])    // version 1.6.0 - poll the power attributes after switching on/off even if polling is disabled!
        state.switchDebouncing = true
        state.lastSwitchState = value
        runInMillis( debouncingTimer, switchDebouncingClear, [overwrite: true])
    }
    map.name = "switch"
    map.value = value
    if (state.isRefreshRequest == true || state.model == "TS0601") {
        map.descriptionText = "${device.displayName} switch is ${value}"
    }
    else {
        map.descriptionText = "${device.displayName} was turned ${value} [${map.type}]"
    }
    if (state.isRefreshRequest == true) map.descriptionText += " (refresh)"
    if (optimizations==false || bWasChange==true ) 
    {
        logInfo "${device.displayName} ${map.descriptionText}"
        sendEvent(map)
        runIn( 1, formatAttrib, [overwrite: true])    
        // version 1.6.3 10/01/2022
        if (energyMode == "FIXED") {
            if (map.value == "on") {
                powerEvent(settings?.fixedPower, isDigital=true)
            }
            else {
                powerEvent(0, isDigital=true)
            }
        }
    }
    clearIsDigital()
}

def voltageEvent( voltage, isDigital=false ) {
    if (settings.reportVoltage != true) {
        logDebug "ignored voltageEvent (${voltage}) - reportVoltage is disabled"
        return
    }    
    def map = [:] 
    map.name = "voltage"
    map.value = (voltage + 0.05) as int
    map.unit = "V"
    map.type = isDigital == true ? "digital" : "physical"
    map.descriptionText = "${map.name} is ${map.value} ${map.unit}"
    if (state.isRefreshRequest == true) map.descriptionText += " (refresh)"
    def lastVoltage = device.currentValue("voltage", true) ?: 0
    if ((Math.abs((voltage as int) - (lastVoltage as int)) >= (voltageThreshold as int)) || optimizations == false || state.isRefreshRequest == true ) {
        if (settings.reportVoltage == true) {
            logInfo "${map.descriptionText}"
            sendEvent(map)
            runIn( 1, formatAttrib, [overwrite: true])    
        }
    }
    else {
        logDebug "${device.displayName} ignored ${map.name} ${map.value} ${map.unit} (change from ${lastVoltage} is less than ${voltageThreshold} V)"
    }
}

def frequencyEvent( frequency, isDigital=false ) {
    if (settings.reportAmperage != true) {
        logDebug "ignored frequencyEvent (${frequency}) - reportAmperage is disabled"
        return
    }
    def map = [:] 
    map.name = "frequency"
    map.value = frequency
    map.unit = "Hz"
    map.type = isDigital == true ? "digital" : "physical"
    map.descriptionText = "${map.name} is ${map.value} ${map.unit}"
    if (state.isRefreshRequest == true) map.descriptionText += " (refresh)"
    def lastFrequency = device.currentValue("frequency", true) ?: 0
    if ((Math.abs((frequency*10 as int) - (lastFrequency*10 as int)) >= 1) || optimizations == false || state.isRefreshRequest == true  ) {
        logInfo "${map.descriptionText}"
        sendEvent(map)
        runIn( 1, formatAttrib, [overwrite: true])    
    }
    else {
        logDebug "ignored ${map.name} ${map.value} ${map.unit} (change from ${lastFrequency} is less than 0.1 Hz)"
    }
}

def powerFactorEvent( pf, isDigital=false ) {
    if (settings.reportAmperage != true) {
        logDebug "ignored powerFactorEvent (${pf}) - reportAmperage is disabled"
        return
    }    
    def map = [:] 
    map.name = "powerFactor"
    map.value = pf
    map.unit = "%"
    map.type = isDigital == true ? "digital" : "physical"
    map.descriptionText = "${map.name} is ${map.value} ${map.unit}"
    if (state.isRefreshRequest == true) map.descriptionText += " (refresh)"
    def lastPF = device.currentValue("powerFactor", true) ?: 0
    if ((Math.abs((pf*100 as int) - (lastPF*100 as int)) >= 1) || optimizations == false || state.isRefreshRequest == true  ) {
        logInfo "${map.descriptionText}"
        sendEvent(map)
        runIn( 1, formatAttrib, [overwrite: true])    
    }
    else {
        logDebug "ignored ${map.name} ${map.value} ${map.unit} (change from ${lastFrequency} is less than 0.1 %)"
    }
}

def powerEvent( power, isDigital=false ) {
    if (settings.reportPower != true) {
        logDebug "ignored powerEvent (${power}) - reportPower is disabled"
        return
    }
    def map = [:] 
    map.name = "power"
    map.value = power
    map.unit = "W"
    map.type = isDigital == true ? "digital" : "physical"
    map.descriptionText = "${map.name} is ${map.value} ${map.unit}"
    if (state.isRefreshRequest == true) map.descriptionText += " (refresh)"
    def lastPower = device.currentValue("power", true) ?: 0.0
    if ( (power as int) > MAX_POWER) {
        logDebug "ignored ${map.name} ${map.value} ${map.unit} (exceeds maximum power cap {MAX_POWER} W)"
        return
    }
    if ((Math.abs((power as int) - (lastPower as int)) >= (powerThreshold as int)) || optimizations == false || state.isRefreshRequest == true ) {
        if (settings?.reportPower == true) {
            logInfo "${map.descriptionText}"
            sendEvent(map)
            runIn( 1, formatAttrib, [overwrite: true])    
        }
    }
    else {
        logDebug "ignored ${map.name} ${map.value} ${map.unit} (change from ${lastPower} is less than ${powerThreshold} W)"
    }
}

def amperageEvent( amperage, isDigital=false ) {
    if (settings.reportAmperage != true) {
        logDebug "ignored amperageEvent (${amperage}) - reportAmperage is disabled"
        return
    }
    def map = [:] 
    map.name = "amperage"
    map.value = amperage
    map.unit = "A"
    map.type = isDigital == true ? "digital" : "physical"
    map.descriptionText = "${map.name} is ${map.value} ${map.unit}"
    if (state.isRefreshRequest == true) map.descriptionText += " (refresh)"
    def lastAmperage = device.currentValue("amperage", true) ?: 0.0
    if ((Math.abs((amperage*1000 as int) - (lastAmperage*1000 as int)) >= (amperageThreshold as int)) || optimizations == false || state.isRefreshRequest == true  ) {
        if (settings?.reportAmperage == true) {
            logInfo "${map.descriptionText}"
            sendEvent(map)
            runIn( 1, formatAttrib, [overwrite: true])    
        }
    }
    else {
        logDebug "ignored ${map.name} ${map.value} ${map.unit} (change from ${lastAmperage} is less than ${amperageThreshold} mA)"
    }
}

def energyEvent( energy_total, isDigital=false ) {
    if (! isEnergyEnabled()) {
        logDebug "ignored energyEvent (${energy_total}) - isEnergyEnabled is ${isEnergyEnabled()}"
        return
    }
    def map = [:] 
    if (isDigital == false) {
        state.lastEnergyRaw = energy_total
    }
    def energy = energy_total
    energy = (energy_total - safeToDouble(state.lastResetEnergy)).round(3)
    if (energy < 0.0) {
        logWarn "energyEvent: negative energy ${energy} (total=${energy_total} lastReset=${safeToDouble(state.lastResetEnergy).round(3)}), correcting it to 0!"
        energy = 0.0
    }
    logDebug "energy_total=${energy_total}, state.lastResetEnergy=${safeToDouble(state.lastResetEnergy)}"
    map.name = "energy"
    map.value = energy
    map.unit = "kWh"
    map.type = isDigital == true ? "digital" : "physical"
    if (isDigital == true ) {
        map.isStateChange = true
    }
    map.descriptionText = "${map.name} is ${map.value} ${map.unit}"
    if (state.isRefreshRequest == true) map.descriptionText += " (refresh)"
    lastEnergy = safeToDouble(device.currentValue("energy", true))
    if ( lastEnergy  != energy || optimizations==false || state.isRefreshRequest == true || isDigital == true ) {
        if (isEnergyEnabled()) {
            def newTotalCost = updateEnergyCost(lastEnergy, energy )
            energyCostEvent(newTotalCost, isDigital)
            sendEvent(map)
            def duration = calculateEnergyDuration()
            energyDurationEvent( duration )
            runIn( 1, formatAttrib, [overwrite: true])    
            logInfo "${map.descriptionText}, energyCost=\$${newTotalCost.round(2)} (rate=\$${energyPrice}), duration=${duration}"
        }
        else {
            logDebug "ignored ${map.name} ${map.value} ${map.unit} (energy reporting is disabled!)"
        }
    }
    else {
        logDebug "${device.displayName} ${map.name} is ${map.value} ${map.unit} (no change)"
    }
}

def scheduleHourlyAndDailyEnergy() {
    // http://www.quartz-scheduler.org/documentation/     
    // https://freeformatter.com/cron-expression-generator-quartz.html 
    schedule("0 0 * ? * * * ", hourlyEnergyEvent)
}

def calculateHourlyEnergy() {
    def energy = safeToDouble(device.currentValue("energy", true)) - safeToDouble(state.lastHourlyEnergy)
    if (energy < 0.0) {
        logWarn "calculateHourlyEnergy: negative energy ${energy}, correcting it to 0!"
        logDebug "device.currentValue=${safeToDouble(device.currentValue("energy", true))}, state.lastHourlyEnergy=${safeToDouble(state.lastHourlyEnergy)}"
        energy = 0.0
    }
    return energy as double
}

def hourlyEnergyEvent( hourlyEnergy=null, isDigital=true ) {
    //log.trace "hourlyEnergyEvent hourlyEnergy=${hourlyEnergy}"
    checkIfNotPresent()
    def map = [:] 
    double energy
    map.name = "hourlyEnergy"
    if (hourlyEnergy != null) {
        map.value = hourlyEnergy    // as set 
    }
    else {    // CRON
        energy = calculateHourlyEnergy().round(3)
        map.value = energy
        state.lastHourlyEnergy = device.currentValue("energy", true)
    }
    map.unit = "kWh"
    map.type = isDigital == true ? "digital" : "physical"
    map.isStateChange = true
    map.descriptionText = "${map.name} is ${map.value} ${map.unit}"
    if (! isEnergyEnabled()) {
        logDebug "ignored hourlyEnergyEvent (${map.value}) - isEnergyEnabled is ${isEnergyEnabled()}"
        return
    }
    else if ((device.currentValue('healthStatus') != 'online')) {
        logDebug "ignored hourlyEnergyEvent (${map.value}) - healthStatus is ${device.currentValue('healthStatus')}"
        return
    }
    else {
        logInfo "${map.descriptionText}"     // sent in the energy event
        sendEvent(map)
    }
}


def updateEnergyCost( previousE, newE) {
    def previousEnergy = safeToDouble(previousE)
    def newEnergy = safeToDouble(newE)
    //log.trace "updateEnergyCost: previousEnergy=${previousEnergy} newEnergy=${newEnergy}"
    def deltaPrice = (newEnergy - previousEnergy) * safeToDouble( energyPrice )
    if (deltaPrice < 0.0) {
        deltaPrice = 0.0
    }
    //log.trace "updateEnergyCost: deltaPrice = ${deltaPrice} oldPrice=${state.lastEnergyCost?:0}"
    def newTotalCost = (state.lastEnergyCost?:0 as double) + (deltaPrice as double)
    state.lastEnergyCost = newTotalCost
    //log.trace "updateEnergyCost: newTotalCost = ${newTotalCost}"
    return newTotalCost
}

def energyCostEvent( cost, isDigital=false ) {
    def map = [:] 
    map.name = "energyCost"
    map.value = safeToDouble(cost).round(2)
    map.unit = "\$"
    map.type = isDigital == true ? "digital" : "physical"
    map.descriptionText = "${map.name} is ${map.unit}${map.value} "
    if (isEnergyEnabled()) {
        sendEvent(map)    // Info log is in the Energy event
        runIn( 1, formatAttrib, [overwrite: true])    
    }
    else {
        logDebug "${device.displayName} IGNORED ${map.name} ${map.value} ${map.unit}"
    }
}

def energyDurationEvent( duration, isDigital=false ) {
    def map = [:] 
    map.name = "energyDuration"
    map.value = duration
    map.unit = ""
    map.type = isDigital == true ? "digital" : "physical"
    map.descriptionText = "${map.name} is ${map.unit}${map.value} "
    sendEvent(map)     // Info log is in the Energy event
}


def parseZDOcommand( Map descMap ) {
    switch (descMap.clusterId) {
        case "0006" :
            if (logEnable) log.info "${device.displayName} Received match descriptor request, data=${descMap.data} (Sequence Number:${descMap.data[0]}, Input cluster count:${descMap.data[5]} Input cluster: 0x${descMap.data[7]+descMap.data[6]})"
            break
        case "0013" : // device announcement
            if (logEnable) log.info "${device.displayName} Received device announcement, data=${descMap.data} (Sequence Number:${descMap.data[0]}, Device network ID: ${descMap.data[2]+descMap.data[1]}, Capability Information: ${descMap.data[11]})"
            state.rejoinCounter = (state.rejoinCounter ?: 0) + 1
            // sendZigbeeCommands(tuyaBlackMagic())
            // activeEndpoints()
            // configure()
            break
        case "8004" : // simple descriptor response
            if (logEnable) log.info "${device.displayName} Received simple descriptor response, data=${descMap.data} (Sequence Number:${descMap.data[0]}, status:${descMap.data[1]}, length:${hubitat.helper.HexUtils.hexStringToInt(descMap.data[4])}"
            parseSimpleDescriptorResponse( descMap )
            break
        case "8005" : // Active Endpoint Response
            if (logEnable) log.info "${device.displayName} Received endpoint response: cluster: ${descMap.clusterId} (endpoint response) endpointCount = ${ descMap.data[4]}  endpointList = ${descMap.data[5]}"
            break
        case "8021" : // bind response
            if (logEnable) log.info "${device.displayName} Received bind response, data=${descMap.data} (Sequence Number:${descMap.data[0]}, Status: ${descMap.data[1]=="00" ? 'Success' : '<b>Failure</b>'})"
            break
        case "8022" : // unbind response
            if (logEnable) log.info "${device.displayName} Received unbind response, data=${descMap.data} (Sequence Number:${descMap.data[0]}, Status: ${descMap.data[1]=="00" ? 'Success' : '<b>Failure</b>'})"
            break
        case "8034" : // leave response
            if (logEnable) log.info "${device.displayName} Received leave response, data=${descMap.data}"
            break
        case "8038" : // Management Network Update Notify
            if (logEnable) log.info "${device.displayName} Received Management Network Update Notify, data=${descMap.data}"
            break
        default :
            if (logEnable) log.warn "${device.displayName} Unprocessed ZDO command: cluster=${descMap.clusterId} command=${descMap.command} attrId=${descMap.attrId} value=${descMap.value} data=${descMap.data}"
            break    // 2022/09/16
    }
}

def activeEndpoints() {
    List<String> cmds = []
    
    cmds += ["he raw ${device.deviceNetworkId} 0 0 0x0005 {00 ${zigbee.swapOctets(device.deviceNetworkId)}} {0x0000}"] //get all the endpoints...
    String endpointIdTemp = device.endpointId ?: '01'
    cmds += ["he raw ${device.deviceNetworkId} 0 0 0x0004 {00 ${zigbee.swapOctets(device.deviceNetworkId)} $endpointIdTemp} {0x0000}"]
    
    sendZigbeeCommands(cmds) 
}

def parseSimpleDescriptorResponse(Map descMap) {
    //log.info "${device.displayName} Received simple descriptor response, data=${descMap.data} (Sequence Number:${descMap.data[0]}, status:${descMap.data[1]}, length:${hubitat.helper.HexUtils.hexStringToInt(descMap.data[4])}"
    if (logEnable==true) log.info "${device.displayName} Endpoint: ${descMap.data[5]} Application Device:${descMap.data[9]}${descMap.data[8]}, Application Version:${descMap.data[10]}"
    def inputClusterCount = hubitat.helper.HexUtils.hexStringToInt(descMap.data[11])
    def inputClusterList = ""
    for (int i in 1..inputClusterCount) {
        inputClusterList += descMap.data[13+(i-1)*2] + descMap.data[12+(i-1)*2] + ","
    }
    inputClusterList = inputClusterList.substring(0, inputClusterList.length() - 1)
    if (logEnable==true) log.info "${device.displayName} Input Cluster Count: ${inputClusterCount} Input Cluster List : ${inputClusterList}"
    if (getDataValue("inClusters") != inputClusterList)  {
        if (logEnable==true) log.warn "${device.displayName} inClusters=${getDataValue('inClusters')} differs from inputClusterList:${inputClusterList} - will be updated!"
        updateDataValue("inClusters", inputClusterList)
    }
    
    def outputClusterCount = hubitat.helper.HexUtils.hexStringToInt(descMap.data[12+inputClusterCount*2])
    def outputClusterList = ""
    if ( outputClusterCount >= 1 ) {
        for (int i in 1..outputClusterCount) {
            outputClusterList += descMap.data[14+inputClusterCount*2+(i-1)*2] + descMap.data[13+inputClusterCount*2+(i-1)*2] + ","
        }
        outputClusterList = outputClusterList.substring(0, outputClusterList.length() - 1)
    }
    
    if (logEnable==true) log.info "${device.displayName} Output Cluster Count: ${outputClusterCount} Output Cluster List : ${outputClusterList}"
    if (getDataValue("outClusters") != outputClusterList)  {
        if (logEnable==true) log.warn "${device.displayName} outClusters=${getDataValue('outClusters')} differs from outputClusterList:${outputClusterList} -  will be updated!"
        updateDataValue("outClusters", outputClusterList)
    }
}

def disableUnsupportedAttribute(String clusterId, String attrId) {
    switch (clusterId) {
        case "0006" :    // Switch
            logWarn "Switch polling is not supported -> Switch polling will be disabled."
            state.switchPollingSupported = false
            break
        case "0B04" : // Electrical Measurement attribute is not supported!
            switch (attrId) {
                case "0505" :    // Voltage
                    logWarn "Voltage polling is not supported -> Voltage polling will be disabled."
                    state.voltagePollingSupported = false
                    break
                case "0508" :     // Current
                    logWarn "Current polling is not supported -> Current polling will be disabled."
                    state.currentPollingSupported = false
                    break
                case "050B" :     // Power
                    logWarn "Power polling is not supported! -> Power polling will be disabled."
                    state.powerPollingSupported = false
                    break
                default :
                    logWarn "Read attribute response: unsupported Attribute ${attrId} for Electrical Measurement cluster ${clusterId}"
                    break
            }
            break
        case "0702" : // Simple Metering Cluster
            if (isFrientOutlet() || isFrientEnergyMonitor()) {
                logDebug "ignoring energy reporting error response for Frient products..."
            }
            else {
                logWarn "Energy measurement is not supported! -> Energy polling will be disabled."
                state.energyPollingSupported = false
            }
            break
        default :
            logWarn "Read attribute response: unsupported Attribute ${attrId} cluster ${clusterId}"
            break
    }
}

def parseZHAcommand( Map descMap) {
    switch (descMap.command) {
        case "01" : //read attribute response. If there was no error, the successful attribute reading would be processed in the main parse() method.
        case "02" : 
            if (descMap?.data.size() >= 3 && descMap.data[2] == "86") {    // status
                def status = descMap.data[2]
                def attrId = descMap.data[1] + descMap.data[0] 
                disableUnsupportedAttribute(descMap.clusterId, attrId)
            }
            else {
                switch (descMap.clusterId) {
                    case "EF00" :
                        //if (logEnable==true) log.warn "${device.displayName} Tuya cluster read attribute response: code ${status} attribute ${attrId} cluster ${descMap.clusterId} data ${descMap.data}"
                        //def attribute = getAttribute(descMap.data)
                        def value = getAttributeValue(descMap.data)
                        //if (logEnable==true) log.trace "${device.displayName} attribute=${attribute} value=${value}"
                        def map = [:]
                        def cmd = descMap.data[2]
                        switch (cmd) { // code : descMap.data[2]    ; attrId = descMap.data[1] + descMap.data[0] 
                            case "01" : // switch state on/of for all models except the DinRail
                                if (!isDinRail())  {
                                    logDebug "Tuya switch event cmd=(01) value=${value}"
                                    switchEvent(value==0 ? "off" : "on")
                                }
                                else {    //  Forward Energy Total _TZE200_eaac7dkw
                                    logInfo "(01) Forward/Real Energy : ${value} raw"
                                    energyEvent(value/getEnergyDiv())    // should be 100
                                }
                                break
                            case "03" :    //  _TZE200_eaac7dkw
                                logInfo "Monthly Energy : ${value}"
                                break
                            case "04" :    //  _TZE200_eaac7dkw
                                logInfo "Daily Energy : ${value}"
                                break
                            case "06" : 
                                if (!isDinRail()) {    
                                    logInfo "(06) Phase A : ${value}"
                                }
                                else if (isHoch()) {
                                    logWarn "skipped dp=6 for Hoch() value = ${value}"
                                }
                                else { // _TZE200_eaac7dkw // https://user-images.githubusercontent.com/26296347/198841477-b80f0bda-2f3e-4f5e-96ba-4fcc87a094ec.png  - combined power, voltage, amperage, etc... event
                                    //       +0  +1  +2  +3  +4  +5  +6  +6  +8  +9 +10 +11 +12 +13 +14 +15 +16 +17 +18 +19 +20
                                    //      [00, FC, 06, 00, 00, 0F, 00, 00, 06, 96, 00, 00, 00, 4A, 03, E4, 00, 1D, 13, 08, E2]   (@ 15:17:05)
                                    //      [00, EF, 06, 00, 00, 0F, 00, 00, 06, A3, 00, 00, 00, 4B, 03, E4, 00, 1D, 4D, 08, E3]   (@ 15:16:05)  227 V; 6.613 A; 1504 W';
                                    //                               |active power | |react. power |  PF    |00| current|Voltage
                                    logDebug "(06) combined reporting data: ${descMap.data}"
                                    def voltageRaw = zigbee.convertHexToInt(descMap.data[20]) + zigbee.convertHexToInt(descMap.data[19]) * 256
                                    logInfo "(06) Voltage : ${voltageRaw/getVoltageDiv()} V (raw ${voltageRaw})"
                                    voltageEvent(voltageRaw/getVoltageDiv()) 
                                    def currentRaw = zigbee.convertHexToInt(descMap.data[18]) + zigbee.convertHexToInt(descMap.data[17]) * 256
                                    logInfo "(06) Current : ${currentRaw/getCurrentDiv()} V (raw ${currentRaw})"
                                    amperageEvent(currentRaw/getCurrentDiv()) 
                                    def pfRaw = zigbee.convertHexToInt(descMap.data[15]) + zigbee.convertHexToInt(descMap.data[14]) * 256
                                    logInfo "(06) PF : ${pfRaw/getPowerFactorDiv()}  (raw ${pfRaw})"
                                    powerFactorEvent(pfRaw/getPowerFactorDiv())
                                    def reactivePowerRaw = zigbee.convertHexToInt(descMap.data[13]) + zigbee.convertHexToInt(descMap.data[12]) * 256
                                    logInfo "(06) React. Power : ${reactivePowerRaw/getPowerDiv()} W"
                                    def activePowerRaw = zigbee.convertHexToInt(descMap.data[9]) + zigbee.convertHexToInt(descMap.data[8]) * 256
                                    logInfo "(06) Active. Power : ${activePowerRaw/getPowerDiv()} W"
                                    powerEvent(activePowerRaw/getPowerDiv())
                                }
                                break
                            case "09" : // (09) Fault _TZE200_eaac7dkw    // { 0: 'clear', 1: 'over current threshold', 2: 'over power threshold', 4: 'over voltage threshold', 8: 'wrong frequency threshold' }
                                logInfo "(09) Fault : ${value}"
                                break
                            case "0A" : // (10)
                                logDebug "(10) unknown : ${value}"
                                break
                            case "0B" : // (11) Frozen set _TZE200_eaac7dkw
                                logInfo "Frozen set : ${value}"
                                break
                            case "10" : // (16) switch _TZE200_eaac7dkw
                                logDebug "(16) switch : ${value}"
                                switchEvent(value==0 ? "off" : "on")
                                break
                            case "11" : // (17) Energy
                                if (!isDinRail())  {
                                    energyEvent(value/getEnergyDiv())
                                }
                                else { // (17) Alarm Set _TZE200_eaac7dkw // { 0: 'not set', 1: 'Over current threshold', 3: 'Over voltage threshold' }
                                    logInfo "(17) AlarmSet1 : ${value}"
                                }
                                break
                            case "12" : // (18) Amperage
                                if (!isDinRail())  {
                                    amperageEvent(value/getCurrentDiv())
                                }
                                else { // (18) Meter ID
                                    logInfo "(18) AlarmSet2 : ${value}"    // AlarmSet2 
                                }
                                break
                            case "13" : // (19) Power
                                powerEvent(value/getPowerDiv())
                                break
                            case "14" : // (20) Voltage
                                voltageEvent(value/getVoltageDiv())    // voltage divider is 10 for EF00 cluster!
                                break
                            case "15" : // (21) Forward energy
                            case "16" : // (22) Forward energy
                            case "17" : // (23) Forward energy
                            case "18" : // (24) Forward energy
                                logInfo "(${cmd}) Forward energy : ${value}"
                                break
                            case "1D" : // hochChildLock: 29
                                if (txtEnable==true) log.info "${device.displayName} Child Lock = ${value==0 ? 'off' : 'on'}"
                                break
                            case "65" : // (101) Voltage HOCH    // DPID_ELECTRIC_ADD 101 // Total Energy ?
                                if ((device.getDataValue('manufacturer') in ["_TZE204_cjbofhxw"]) || isDinRail()) {
                                    logInfo "(101) Total  Energy : ${value} raw (${value/getEnergyDiv()} kWh)"
                                    energyEvent(value/getEnergyDiv())
                                }
                                else if (isHoch()) {
                                    logDebug "isHoch() cmd = ${cmd}  value = ${(zigbee.convertHexToInt(descMap.data[7]) + zigbee.convertHexToInt(descMap.data[6]) << 8)}"
                                    voltageEvent((zigbee.convertHexToInt(descMap.data[7]) + zigbee.convertHexToInt(descMap.data[6]) *256) / (getVoltageDiv() as Float))
                                }
                                else {
                                    logDebug "unknown Tuya cmd = ${cmd}  value = ${value}"
                                }
                                break
                            case "66" : // (102) Amperage HOCH or Produced Energy
                                if (isHoch()) {
                                    value = (zigbee.convertHexToInt(descMap.data[8]) + zigbee.convertHexToInt(descMap.data[7]) *256) 
                                    logInfo "(102)  Amperage HOCH : ${value/1000.0F} A (raw ${value})"
                                    amperageEvent((value as Float)/1000.0F)
                                }
                                else {
                                    logInfo "(102) Produced Energy : ${value} kWh  (raw ${value} )"
                                }
                                break
                            case "67" : // (103) hochActivePower: 103 Real Active Power [W]
                                value = (zigbee.convertHexToInt(descMap.data[8]) + zigbee.convertHexToInt(descMap.data[7]) *256) 
                                logInfo "(103) Real Active Power : ${value/10.0} W (raw ${value})"
                                powerEvent(value/10.0F)
                                break
                            case "68" : // (104) hochLeakageCurrent: 104
                                logInfo "(104) Hoch Leakage Current is : ${value/getCurrentDiv()} raw (${value}) A"
                                break
                            case "69" : // (105) temperatue for Hoch, frequency for others?
                                if (isHoch()) {
                                    logInfo "(105) Hoch temperature is : ${value} C  (raw ${value}) "
                                    sendEvent(name:'temperature', value:value, unit:'C')
                                }
                                else 
                                {
                                    logInfo "(105) frequency : ${value} raw (${value/getFrequencyDiv()}) Hz"
                                    frequencyEvent(value/getFrequencyDiv())
                                }
                                break
                            case "6A" : // (106) hochRemainingEnergy:
                                logInfo "(106) Hoch Remaining Energy is : ${value/getEnergyDiv()} raw (${value}) kWh"
                                break
                            case "6D" : // (109) Reactive Power [VAr]
                                logInfo "(109) Reactive Power : ${value} raw (${value/getPowerDiv()} VAr)"
                                break
                            case "6E" : // (110) Total Reactive Power) [VAr] for ??? or hochVoltageThreshold
                                if (isHoch()) {
                                    logInfo "(110) Hoch Voltage Threshold is : ${value} raw (${value}) V"
                                }
                                else {
                                    logInfo "(110) Total Reactive Power : ${value} raw (${value/getPowerDiv()} VAr)"
                                }
                                break
                            case "6F" : // (111) power factor for ??? or hochCurrentThreshold
                                if (isHoch()) {
                                    logInfo "(111) Hoch Current Threshold is : ${value} raw (${value}) A"
                                }
                                else {
                                    logInfo "(111) power factor : ${value} raw"
                                    powerFactorEvent(value/getPowerFactorDiv())
                                }
                                break
                            case "71" : // (113) hochTotalActivePower: 113
                                logInfo "(113) Hoch Total Active Power (energy) is : ${value/getEnergyDiv()} (raw ${value}) kWh"
                                energyEvent(value/getEnergyDiv())    // should be 100
                                break
                            case "75" : // (117) hochTotalReverseActivePower: 117
                                logInfo "(117) Hoch Total Reverse Active Power is : ${value/getPowerDiv()} raw (${value}) W"
                                break
                            
                            
                            case "09" : // hochCountdownTimer: 9
                            case "1A" : // hochFaultCode: 26
                            case "1B" : // hochRelayStatus: 27 (power recovery behaviour)
                            case "6A" : // hochRemainingEnergy: 106
                            case "6B" : // "recharge energy" : 107
                            case "6C" : // hochCostParameters: 108 (non-zero)
                            case "6D" : // hochLeakageParameters: 109 (non-zero)
                            //case "6E" : // hochVoltageThreshold: 110 (non-zero)
                            //case "6F" : // hochCurrentThreshold: 111 (non-zero)
                            case "70" : // hochTemperatureThreshold: 112 (non-zero)
                            case "72" : // hochEquipmentNumberType: 114
                            case "73" : //: "clear energy",115
                            case "74" : // hochLocking: 116  (test button pressed)
                            case "75" : // hochTotalReverseActivePower: 117
                            case "76" : // hochHistoricalVoltage: 118
                            case "77" : // hochHistoricalCurrent: 119
                                logWarn "UNHANDLED Tuya cmd = ${cmd}  value = ${value}"
                                break
                            default :
                                if (logEnable==true) log.warn "${device.displayName} Tuya unknown attribute: ${descMap.data[0]}${descMap.data[1]}=${descMap.data[2]}=${descMap.data[3]}${descMap.data[4]} data.size() = ${descMap.data.size()} value: ${value}}"
                                if (logEnable==true) log.warn "${device.displayName} map= ${descMap}"
                                break
                        }
                        break
                    case "0003" : // Frient
                        logDebug "Read attribute response: no status code ${status} attribute ${attrId} cluster ${descMap.clusterId}"
                        break
                    default :
                        if (logEnable==true) log.warn "${device.displayName} Read attribute response: unknown status code ${status} attribute ${attrId} cluster ${descMap.clusterId}"
                        break
                } // switch (descMap.clusterId)
            }  //command is read attribute response
            break
        case "04" : //write attribute response
            if (logEnable==true) log.info "${device.displayName} Received Write Attribute Response for cluster:${descMap.clusterId} , data=${descMap.data} (Status: ${descMap.data[0]=="00" ? 'Success' : '<b>Failure</b>'})"
            break
        case "07" : // Configure Reporting Response
            if (logEnable==true) log.info "${device.displayName} Received Configure Reporting Response for cluster:${descMap.clusterId} , data=${descMap.data} (Status: ${descMap.data[0]=="00" ? 'Success' : '<b>Failure</b>'})"
            // Status: Unreportable Attribute (0x8c)
            break
        case "09" : // Command: Read Reporting Configuration Response (0x09)
            // TS0121 Received Read Reporting Configuration Response (0x09) for cluster:0006 , data=[00, 00, 00, 00, 10, 00, 00, 58, 02] (Status: Success) min=0 max=600
            // TS0121 Received Read Reporting Configuration Response (0x09) for cluster:0702 , data=[00, 00, 00, 00, 25, 3C, 00, 10, 0E, 00, 00, 00, 00, 00, 00] (Status: Success) min=60 max=3600
            def status = zigbee.convertHexToInt(descMap.data[0])    // Status: Success (0x00)
            def attr = zigbee.convertHexToInt(descMap.data[3])*256 + zigbee.convertHexToInt(descMap.data[2])    // Attribute: OnOff (0x0000)
            if (status == 0) {
                def dataType = zigbee.convertHexToInt(descMap.data[4])    // Data Type: Boolean (0x10)
                def min = zigbee.convertHexToInt(descMap.data[6])*256 + zigbee.convertHexToInt(descMap.data[5])
                def max = zigbee.convertHexToInt(descMap.data[8]+descMap.data[7])
                def delta = 0
                if (descMap.data.size()>=10) { 
                    delta = zigbee.convertHexToInt(descMap.data[10]+descMap.data[9])
                }
                else {
                    if (logEnable==true) log.debug "${device.displayName} descMap.data.size = ${descMap.data.size()}"
                }
                if (logEnable==true) log.info "${device.displayName} Received Read Reporting Configuration Response (0x09) for cluster:${descMap.clusterId} attribute:${descMap.data[3]+descMap.data[2]}, data=${descMap.data} (Status: ${descMap.data[0]=="00" ? 'Success' : '<b>Failure</b>'}) min=${min} max=${max} delta=${delta}"
            }
            else {
                if (logEnable==true) log.info "${device.displayName} <b>Not Found (0x8b)</b> Read Reporting Configuration Response for cluster:${descMap.clusterId} attribute:${descMap.data[3]+descMap.data[2]}, data=${descMap.data} (Status: ${descMap.data[0]=="00" ? 'Success' : '<b>Failure</b>'})"
            }
            break
        case "0B" : // ZCL Default Response
            def status = descMap.data[1]
            if (status != "00") {
                switch (descMap.clusterId) {
                    case "0003" : // Identify response
                        if (txtEnable==true) log.warn "${device.displayName} Identify command is not supported by ${device.getDataValue('manufacturer')}"
                        break
                    case "0006" : // Switch state
                        if (logEnable==true) log.warn "${device.displayName} Switch state is not supported -> Switch polling will be disabled."
                        state.switchPollingSupported = false
                        break    // fixed in ver. 1.5.0
                    case "0B04" : // Electrical Measurement
                        if (logEnable==true) log.warn "${device.displayName} Electrical measurement is not supported -> Power, Voltage and Amperage polling will be disabled."
                        state.powerPollingSupported = false
                        state.voltagePollingSupported = false
                        state.currentPollingSupported = false
                        break
                    case "0702" : // Energy
                        if (logEnable==true) log.warn "${device.displayName} Energy measurement is not supported -> Energy polling will be disabled."
                        state.energyPollingSupported = false
                        break
                    default :
                        if (logEnable==true) log.info "${device.displayName} Received ZCL Default Response to Command ${descMap.data[0]} for cluster:${descMap.clusterId} , data=${descMap.data} (Status: ${descMap.data[1]=="00" ? 'Success' : '<b>Failure</b>'})"
                        break
                }
            }
            break
        case "24" :    // Tuya time sync
            if (settings?.logEnable) log.trace "${device.displayName} Tuya time sync"
            if (descMap?.clusterInt==0xEF00 && descMap?.command == "24") {        //getSETTIME
                if (settings?.logEnable) log.debug "${device.displayName} time synchronization request from device, descMap = ${descMap}"
                def offset = 0
                try {
                    offset = location.getTimeZone().getOffset(new Date().getTime())
                }
                catch(e) {
                    if (settings?.logEnable) log.error "${device.displayName} cannot resolve current location. please set location in Hubitat location setting. Setting timezone offset to zero"
                }
                def cmds = zigbee.command(0xEF00, 0x24, "0008" +zigbee.convertToHexString((int)(now()/1000),8) +  zigbee.convertToHexString((int)((now()+offset)/1000), 8))
                if (settings?.logEnable) log.trace "${device.displayName} now is: ${now()}"  // KK TODO - convert to Date/Time string!        
                if (settings?.logEnable) log.debug "${device.displayName} sending time data : ${cmds}"
                cmds.each{ sendHubCommand(new hubitat.device.HubAction(it, hubitat.device.Protocol.ZIGBEE)) }
                if (state.txCounter != null) state.txCounter = state.txCounter + 1
                return
            }
            break
        case "25" : // CHECK_ZIGBEE_GATEWAY_STATUS_CMD 0x25
            //logDebug "CHECK_ZIGBEE_GATEWAY_STATUS_CMD 0x25 Data=${descMap.data}"
            def  cmds =  ["he raw 0x${device.deviceNetworkId} 1 1 0xEF00 {11 01 25 ${descMap.data[0]+descMap.data[1]+'01'}}","delay 100"]    // Frame Control Field 0x11 : Disable Default Response: True; Frame Type: Cluster-specific (0x1)
            cmds.each{ sendHubCommand(new hubitat.device.HubAction(it, hubitat.device.Protocol.ZIGBEE)) }
            break
        default :
            if (logEnable==true) log.warn "${device.displayName} Unprocessed global command: cluster=${descMap.clusterId} command=${descMap.command} attrId=${descMap.attrId} value=${descMap.value} data=${descMap.data}"
            break    // 9/16/2022
    }
}

/*
private String getAttribute(ArrayList _data) {
    String retValue = ""
    if (_data.size() >= 5) {
        if (_data[2] == "01" && _data[3] == "01" && _data[4] == "00") {
            retValue = "switch"
        }
        else if (_data[2] == "02" && _data[3] == "02" && _data[4] == "00") {
            retValue = "level"
        }
    }
    return retValue
}
*/

private int getAttributeValue(ArrayList _data) {
    int retValue = 0
    try {    
    if (_data.size() >= 6) {
        int dataLength = zigbee.convertHexToInt(_data[5]) as Integer
        int power = 1;
        for (i in dataLength..1) {
            retValue = retValue + power * zigbee.convertHexToInt(_data[i+5])
            power = power * 256
        }
    }
}
    catch ( e ) {
        log.error "${device.displayName} Exception caught : data = ${_data}"
    }
    return retValue
}

def off() {
    if (alwaysOn == true) {
        logWarn "AlwaysOn option for ${device.displayName} is enabled , the command to switch it OFF is ignored!"
    }
    else {
        state.isDigital = true
        logDebug "Switching ${device.displayName} Off"
        def cmds = zigbee.off()
        if (device.getDataValue("model") == "HY0105") {
            cmds += zigbee.command(0x0006, 0x00, "", [destEndpoint: 0x02])
        }
        else if (state.model == "TS0601") {
            if (isDinRail()) {
                cmds = sendTuyaCommand("10", DP_TYPE_BOOL, "00")
            }
            else {
                cmds = zigbee.command(0xEF00, 0x0, "00010101000100")
            }
        }
        else if (isHEProblematic()) {
            cmds = ["he cmd 0x${device.deviceNetworkId}  0x01 0x0006 0 {}","delay 200"]
            logWarn "isHEProblematic() : sending off() : ${cmds}"
        }
        else if (device.endpointId == "F2") {
            cmds = ["he cmd 0x${device.deviceNetworkId} 0x01 0x0006 0 {}","delay 200"]
        }
        runInMillis( digitalTimer, clearIsDigital, [overwrite: true])
        if (state.txCounter != null) state.txCounter = state.txCounter + 1
        if (logEnable==true) log.trace "${device.displayName} off() sending ${cmds}"
        return cmds
    }
}

def on() {
    state.isDigital = true
    if (logEnable) {log.debug "${device.displayName} Switching ${device.displayName} On"}
    def cmds = zigbee.on()
    if (device.getDataValue("model") == "HY0105") {
        cmds += zigbee.command(0x0006, 0x01, "", [destEndpoint: 0x02])
    }    
    else if (state.model == "TS0601") {
        if (isDinRail()) {
            cmds = sendTuyaCommand("10", DP_TYPE_BOOL, "01")
        }
        else {
            cmds = zigbee.command(0xEF00, 0x0, "00010101000101")
        }
    }
    else if (isHEProblematic()) {
        cmds = ["he cmd 0x${device.deviceNetworkId} 0x01 0x0006 1 {}","delay 200"]
        logWarn "isHEProblematic() : sending off() : ${cmds}"
    }
    else if (device.endpointId == "F2") {
        cmds = ["he cmd 0x${device.deviceNetworkId} 0x01 0x0006 1 {}","delay 200"]
    }
    runInMillis( digitalTimer, clearIsDigital, [overwrite: true])
    if (state.txCounter != null) state.txCounter = state.txCounter + 1
    if (logEnable==true) log.trace "${device.displayName} on() sending ${cmds}"
    return cmds
}

def clearIsDigital() { state.isDigital = false }

def isRefreshRequestClear() { state.isRefreshRequest = false }

def switchDebouncingClear() { state.switchDebouncing = false }

// version 1.6.0 - poll the power attributes after switching on/off even if polling is disabled!
def pollPower() {
    if (logEnable) {log.debug "${device.displayName} pollPower().."}
    List<String> cmds = []
    if (state.powerPollingSupported & state.voltagePollingSupported & state.currentPollingSupported == true) {
        if (settings?.reportPower == true || settings?.reportVoltage == true || settings?.reportAmperage == true) {
            cmds += zigbee.readAttribute(0x0B04, [0x050B, 0x0505, 0x0508], [destEndpoint :safeToInt(state.destinationEP)], delay=200)    // Power, Voltage and Amperage at once!
        }
    }
    else {
        cmds += zigbee.electricMeasurementPowerRefresh()    // just power
    }
    state.isRefreshRequest = true
    runInMillis( refreshTimer, isRefreshRequestClear, [overwrite: true])       // 3 seconds
    if (state.txCounter != null) state.txCounter = state.txCounter + 1
    return cmds
}

def pollOnce()
{
    poll()
}


// Sends refresh / readAttribute commands to the plug
//
def poll( refreshAll = false ) {
    logDebug "polling.. refreshAll is ${refreshAll}"
    checkDriverVersion()
    List<String> cmds = []
    def ep = safeToInt(state.destinationEP)
    /*
    if (state.switchPollingSupported == true && refreshAll == true ) {
        cmds = zigbee.onOffRefresh()                            // switch - polled only on full Refresh
    }
*/
    if (state.powerPollingSupported & state.voltagePollingSupported & state.currentPollingSupported == true) {
        if (settings?.reportPower == true || settings?.reportVoltage == true || settings?.reportAmperage == true) {
            logDebug "polling all 0x0B04 attributes"
            cmds += zigbee.readAttribute(0x0B04, [0x050B, 0x0505, 0x0508, 0x0300], [destEndpoint :ep], delay=200)    // Power, Voltage and Amperage at once. Frequency added 03/27/2023
        }
    }
    else {
        if (state.powerPollingSupported == true && settings?.reportPower == true) 
            cmds += zigbee.electricMeasurementPowerRefresh()    // Power ( cluster 0B04, attr. 050B )
        if (state.voltagePollingSupported == true && settings?.reportVoltage == true)
            cmds += zigbee.readAttribute(0x0B04, 0x0505, [destEndpoint :ep], delay=200)        // voltage
        if (state.currentPollingSupported == true  && settings?.reportAmperage == true) {
            cmds += zigbee.readAttribute(0x0B04, 0x0508, [destEndpoint :ep], delay=100)        // current
            cmds += zigbee.readAttribute(0x0B04, 0x0300, [destEndpoint :ep], delay=200)        // frequency
            cmds += zigbee.readAttribute(0x0B04, 0x0510, [destEndpoint :ep], delay=200)        // powerFactor
        }
    }    
    if (state.energyPollingSupported == true && refreshAll == true ) {
        cmds += zigbee.readAttribute(0x0702, 0x0000, [destEndpoint :ep], delay=200)            // energy - polled only on full Refresh    ATTRIBUTE_READING_INFO_SET
    }
    if ((state.switchPollingSupported == true && refreshAll == true) /*|| cmds == [] */) {
        cmds += zigbee.onOffRefresh()                            // switch - polled only on full Refresh or nothing else to poll
    }
    if (cmds == []) { // if nothing to poll...
        cmds += zigbee.readAttribute(0x0000, 0x0001, [destEndpoint :ep], delay=200)
    }
    state.isRefreshRequest = refreshAll
    runInMillis( refreshTimer, isRefreshRequestClear, [overwrite: true])           // 3 seconds
    sendZigbeeCommands(cmds)    // 11/16/2022
}


def refresh() {
    logInfo "refresh()..."
    state.isRefreshRequest = true
    poll( refreshAll = true )
    runInMillis( refreshTimer, isRefreshRequestClear, [overwrite: true])           // 3 seconds
}

def ping() {
    logInfo "ping() is not implemented"
}

def autoPoll() {
    if (logEnable) {log.debug "${device.displayName} autoPoll()"}
    checkIfNotPresent()
    if (optimizations == true) 
        poll( refreshAll = false )
    else 
        poll( refreshAll = true )
}

def tuyaBlackMagic() {
    List<String> cmds = []
    if (state.txCounter != null) state.txCounter = state.txCounter + 1
    cmds += zigbee.readAttribute(0x0000, [0x0004, 0x0000, 0x0001, 0x0005, 0x0007, 0xfffe], [:], delay=150) // Cluster: Basic, attributes: Man.name, ZLC ver, App ver, Model Id, Power Source, attributeReportingStatus
    cmds += zigbee.writeAttribute(0x0000, 0xffde, 0x20, 0x0d, [:], delay=50)
    return cmds
}

def fixOtherTuyaOddities() {
    List<String> cmds = []
    def ep = device.getEndpointId()
    logDebug "ep=${ep} isF2=${ep=='F2'}"
    if (isHEProblematic() || ep == 'F2') {
        log.warn "fixing other Tuya oddities ..."
        def endpoint = '01'
        cmds = ["he raw 0x${device.deviceNetworkId} 0 0 0x8002 {40 00 00 00 00 40 8f 5f 11 52 52 00 41 2c 52 00 00} {0x0000}", "delay 50",]    // node descriptor response as for Aqara E1 hub, doesn't seem to improve anything ...
        cmds +=   ["zdo bind 0x${device.deviceNetworkId} 0x${endpoint} 0x01 0x0006 {${device.zigbeeId}} {}", "delay 251", ]
        cmds +=  ["zdo bind 0x${device.deviceNetworkId} 0x${endpoint} 0x01 0x0B04 {${device.zigbeeId}} {}", "delay 252", ]
        //int intMinTime = 60; int intMaxTime = 3600; 
        cmds += ["he cr 0x${device.deviceNetworkId} 0x${endpoint} 2820 1285 33 60 3600 {0500} {}", "delay 253", ]        // voltage //zigbee.configureReporting(0x0B04, 0x0505,  DataType.UINT16, intMinTime, intMaxTime, 5)    // voltage
        cmds += ["he cr 0x${device.deviceNetworkId} 0x${endpoint} 2820 1288 33 60 3600 {3200} {}", "delay 254", ]        // current //zigbee.configureReporting(0x0B04, 0x0508,  DataType.UINT16, intMinTime, intMaxTime, 50)    // amperage
        cmds += ["he cr 0x${device.deviceNetworkId} 0x${endpoint} 2820 1291 41 60 3600 {0A00} {}", "delay 255", ]        // power //zigbee.configureReporting(0x0B04, 0x050B,  DataType.INT16, intMinTime, intMaxTime, 10)    // power
        cmds += ["he cr 0x${device.deviceNetworkId} 0x${endpoint} 1794 0 37 60 3600 {010000000000} {}", "delay 256", ]   // energy //zigbee.configureReporting(0x0702, 0x0000,  DataType.UINT48, intMinTime, intMaxTime, 1)    // energy
        if (!isTuyaSpecificCluster()) {
            cmds += zigbee.configureReporting(0x0B04, 0x0300, DataType.UINT16, 5, 3600, 1, [destEndpoint :0x01 ], delay=257)    // TODO: check why is always enabled?
        }
        cmds += zigbee.readAttribute(0x0B04, [0x050B, 0x0505, 0x0508], [destEndpoint : 0x01], delay=200)    // Power, Voltage and Amperage at once!
        cmds += zigbee.readAttribute(0x0006, 0x0000, [destEndpoint : 0x01], delay=200)    // Power, Voltage and Amperage at once!
        cmds += zigbee.readAttribute(0x0000, 0x0001, [destEndpoint : 0x01], delay=200)    // App version
        return cmds
    }
    else {
        return Collections.emptyList()
    }
}

/*
    configure() method is called: 
       *  unconditionally during the initial pairing, immediately after Installed() method
       *  when Initialize button is pressed
       *  from updated() when preferences are saved
*/
def configure() {
    if (txtEnable==true) log.info "${device.displayName} configure().."
    /*
    log.warn "running configure in 5 seconds..."
    pauseExecution(5000)
    */
    scheduleHourlyAndDailyEnergy()
        
    List<String> cmds = []
    cmds =  tuyaBlackMagic()
    cmds += fixOtherTuyaOddities()
    if (isHEProblematic() || device.getEndpointId() == 'F2') {
        logWarn "skipping onOff standard cluster configuration for a problematic Tuya device ${device.getDataValue('manufacturer')} ..."
    }
    else {
        if (isFrientEnergyMonitor()) {
            logDebug "skipping onOff standard configuration for Frient Energy Monitor..."
        }
        else {
            cmds += refresh()
            cmds += zigbee.onOffConfig()
        }
    }

    if (! isEnergyEnabled()) {
        device.deleteCurrentState("energy")
        device.deleteCurrentState("energyCost")
        device.deleteCurrentState("energyDuration")
        device.deleteCurrentState("hourlyEnergy")
    }
    if (settings.reportPower == false) {
        device.deleteCurrentState("power")
    }
    if (settings.reportVoltage == false) {
        device.deleteCurrentState("voltage")
    }
    if (settings.reportAmperage == false) {
        device.deleteCurrentState("amperage")
        device.deleteCurrentState("frequency")
        device.deleteCurrentState("powerFactor")
    }
    if (settings.attribEnable == false) {
        device.deleteCurrentState("html")
    }
    
    
    if (autoReportingEnabled == true ) {
        if (isEnergyEnabled()) {    // TODO - only when automatic reporting option is selected! // TODO: research on how to disable automatic reporting
            cmds += configureReporting("Write", ENERGY,  energyMinReportingTime.toString(), energyMaxReportingTime.toString(), energyThreshold.toString(), sendNow=false)
        }
        if (reportPower == true) {
            cmds += configureReporting("Write", POWER,  energyMinReportingTime.toString(), energyMaxReportingTime.toString(), powerThreshold.toString(), sendNow=false)
        }
        if (reportVoltage == true) {
            cmds += configureReporting("Write", VOLTAGE,  energyMinReportingTime.toString(), energyMaxReportingTime.toString(), voltageThreshold.toString(), sendNow=false)
        }
        if (reportAmperage == true) {
            cmds += configureReporting("Write", AMPERAGE,  energyMinReportingTime.toString(), energyMaxReportingTime.toString(), amperageThreshold.toString(), sendNow=false)
            cmds += configureReporting("Write", FREQUENCY, energyMinReportingTime.toString(), energyMaxReportingTime.toString(), "1", sendNow=false)
            cmds += configureReporting("Write", POWER_FACTOR, energyMinReportingTime.toString(), energyMaxReportingTime.toString(), "1", sendNow=false)
        }
    }
    else {
        if (logEnable==true) log.info "${device.displayName} Automatic reporting configuration is skipped!"
        // TODO - actually disable the automatic reporting !
    }
    //
    if (isFrientEnergyMonitor() == true) {
        def modeName =  develcoInterfaceMode.find{it.key==settings?.frientEnergyMeterMode}
        if (modeName != null) {
            logDebug "setting frientEnergyMeterMode to ${modeName.value} (${settings?.frientEnergyMeterMode})"
            cmds += setEnergyMeterMode( modeName.value )
        }
        logDebug "setting FrientEnergyMonitor pulseConfiguration (${settings?.pulseConfiguration} )"
        cmds += pulseConfiguration( settings?.pulseConfiguration )
    }
    
    sendZigbeeCommands(cmds)
    //  
    if (isHEProblematic() ) {
        logWarn "<b>WARNING! This ${device.getDataValue('model')} plug manufacturer ${device.getDataValue('manufacturer')} is known to be problematic with HE!</b>"
    }
}

def autoCron( timeInSeconds ) {
    if (timeInSeconds < 60) {
        schedule("*/$timeInSeconds * * * * ? *", autoPoll)
        return timeInSeconds.toString() + " seconds"
    }
    else {
        def minutes = (timeInSeconds / 60 ) as int
        if (minutes < 60) {
            schedule("0 */$minutes * ? * *", autoPoll)    
            return minutes.toString() + " minutes"
        }
        else {
            def hours = (minutes / 60 ) as int
            if (hours > 23) hours = 23
            schedule("0 0 */$hours ? * *", autoPoll)                    
            return hours.toString() + " hours"
        }
    }
}



// This method is called when the preferences of a device are updated.
def updated(){
    if (txtEnable==true) log.info "${device.displayName} Updating ${device.getLabel()} (${device.getName()}) model ${state.model}"
    if (txtEnable==true) log.info "${device.displayName} Debug logging is <b>${logEnable}</b> Description text logging is  <b>${txtEnable}</b>"
    if (logEnable==true) {
        runIn(86400, logsOff, [overwrite: true, misfire: "ignore"])    // turn off debug logging after 24 hours
        if (txtEnable==true) log.info "${device.displayName} Debug logging will be automatically switched off after 24 hours"
    }
    else {
        unschedule(logsOff)
    }
    def autoPollTime
    if (autoPollingEnabled?.value==true) {
        if ( pollingInterval != null ) {
            autoPollTime = autoCron( pollingInterval )
        }
        else {
            autoPollTime = autoCron( defaultPollingInterval )
        }
        if (txtEnable==true) log.info "${device.displayName} Auto polling is <b>enabled</b>, polling interval is ${autoPollTime} "
    }
    else {
        unschedule(autoPoll)
        log.info "${device.displayName} Auto polling is <b>disabled</b>"
    }
    if (txtEnable==true) log.info "${device.displayName} configuring the switch and energy reporting.."
    
    if (attribEnable == true ) {
        runIn( 1, formatAttrib, [overwrite: true])    
    }
    /* changed in ver 1.7.3. 03/27/2023 - do not send empty html attribute - will this break anything?
    else {
        sendEvent(name: "html", value: "<table></table>", isChanged: true)
    }
    */
    formatAttrib()
    configure()
}



void initializeVars( boolean fullInit = false ) {
    //
    def preservedResetEnergy = state.lastResetEnergy ?: 0            // preserve state.lastResetEnergy even on full reset!
    def preservedLastHourlyEnergy = state.lastHourlyEnergy ?: 0  
    if (logEnable==true) log.info "${device.displayName} InitializeVars()... fullInit = ${fullInit}"
    if (fullInit == true ) {
        if (logEnable==true) log.warn "${device.displayName} clearing states and preferences ..."
        if (logEnable==true) log.warn "${device.displayName} preservedResetEnergy = ${preservedResetEnergy}"
        state.clear()
        state.driverVersion = driverVersionAndTimeStamp()
    }
    if (device.currentValue('healthStatus') == null) sendHealthStatusEvent('unknown')    
    
    def mm = device.getDataValue("model")
    if ( mm != null) {
        state.model = mm
        if (logEnable==true) log.trace "${device.displayName} model = ${state.model}"
    }
    else {
        if (txtEnable==true) log.warn "${device.displayName} Model not found, please re-pair the device!"
        state.model = UNKNOWN
    }
    
    state.rxCounter = 0
    state.txCounter = 0
    if (state.lastEnergyRaw == null) state.lastEnergyRaw = 0.0
    if (state.lastEnergyCost == null) state.lastEnergyCost = 0.0
    if (state.lastSwitchState == null) state.lastSwitchState = "unknown"
    if (fullInit == true || state.notPresentCounter == null) state.notPresentCounter = 0
    if (fullInit == true || state.isDigital == null) state.isDigital = true
    if (fullInit == true || state.isRefreshRequest == null) state.isRefreshRequest = true
    if (fullInit == true || state.switchDebouncing == null) state.switchDebouncing = false
    if (state.lastResetEnergy == null) {
        log.warn "state.lastResetEnergy = ${state.lastResetEnergy}, resetting it back to ${preservedResetEnergy}!"
        state.lastResetEnergy = preservedResetEnergy                               // do not reset on Initialize!
    }
    if (state.lastHourlyEnergy == null) {
        state.lastHourlyEnergy = preservedLastHourlyEnergy
    }
    if (state.lastResetDate == null) state.lastResetDate = FormattedDateTimeFromUnix( now() )    // do not reset on Initialize!
    if (_DEBUG == false) { if (fullInit == true || settings?.logEnable == null) device.updateSetting("logEnable", true) }
    else                 { if (fullInit == true || settings?.logEnable == null) device.updateSetting("logEnable", true) }
    if (fullInit == true || settings?.txtEnable == null) device.updateSetting("txtEnable", true)
    if (fullInit == true || settings?.autoPollingEnabled == null) { device.updateSetting("autoPollingEnabled", isReportingConfigurable() ? false : true) }
    if (fullInit == true || settings?.autoReportingEnabled == null) { device.updateSetting("autoReportingEnabled", isReportingConfigurable() ? true : false) }
    if (fullInit == true || settings?.optimizations == null) device.updateSetting("optimizations", true)
    if (fullInit == true || settings?.reportPower == null) device.updateSetting("reportPower", true)
    if (fullInit == true || settings?.reportVoltage == null) device.updateSetting("reportVoltage", true)
    if (fullInit == true || settings?.reportAmperage == null) device.updateSetting("reportAmperage", true)
    if (fullInit == true || settings?.energyMode == null) device.updateSetting("energyMode", [value: (isReportingConfigurable() ? "REPORTED" : "POLLED"), type:"enum"])
    if (fullInit == true || settings?.fixedPower == null) device.updateSetting("fixedPower", [value:100, type:"number"])
    if (fullInit == true || settings?.energyMinReportingTime == null) device.updateSetting("energyMinReportingTime", [value:30, type:"number"])
    if (fullInit == true || settings?.energyMaxReportingTime == null) device.updateSetting("energyMaxReportingTime", [value:900, type:"number"])
    if (fullInit == true || settings?.energyThreshold == null) device.updateSetting("energyThreshold", [value:1, type:"number"])
    if (fullInit == true || settings?.energyPrice == null) device.updateSetting("energyPrice", [value:0.21326, type:"decimal"])
    if (fullInit == true || settings?.powerThreshold == null) device.updateSetting("powerThreshold", [value:1, type:"number"])
    if (fullInit == true || settings?.amperageThreshold == null) device.updateSetting("amperageThreshold",[value:25, type:"number"])
    if (fullInit == true || settings?.voltageThreshold == null) device.updateSetting("voltageThreshold", 1)
    if (fullInit == true || settings?.attribEnable == null) device.updateSetting("attribEnable", false)
    if (fullInit == true || settings?.pulseConfiguration == null) device.updateSetting("pulseConfiguration", [value:1000, type:"number"])
    if (fullInit == true || settings?.frientEnergyMeterMode == null) device.updateSetting("frientEnergyMeterMode", [value:"0", type:"enum"])    // electricity

    if (fullInit == true || settings?.pollingInterval == null) device.updateSetting("pollingInterval", defaultPollingInterval)
    if (settings?.alwaysOn == null)  device.updateSetting("alwaysOn", false)       // do not change the "alwaysOn" setting if already set!

    if (fullInit == true || state.switchPollingSupported == null) state.switchPollingSupported = true
    if (fullInit == true || state.voltagePollingSupported == null) state.voltagePollingSupported = true
    if (fullInit == true || state.currentPollingSupported == null) state.currentPollingSupported = true
    if (fullInit == true || state.powerPollingSupported == null) {
        if (isOsramPlug01()) {
            /*if (logEnable==true)*/ log.debug "${device.displayName} correcting power reporting for ${device.getDataValue('manufacturer')}"
            state.powerPollingSupported = false
            device.deleteCurrentState("power")
            device.updateSetting("reportVoltage",  [value: "false", type: "bool"])
            device.updateSetting("reportAmperage", [value: "false", type: "bool"])
            device.updateSetting("energyMode", [value:"FIXED", type:"enum"])
        }
        else  {
            state.powerPollingSupported = true
        }
    }
    if (isFrientEnergyMonitor() == true) {
        log.warn "disabling V/A reporting for Frient Energy monitor"
        if (fullInit == true || settings?.energyMode == null) device.updateSetting("energyMode", [value:"REPORTED", type:"enum"])
        if (fullInit == true || settings?.reportVoltage == null) device.updateSetting("reportVoltage", [value: false, type: "bool"])
        if (fullInit == true || settings?.reportAmperage == null) device.updateSetting("reportAmperage", [value: false, type: "bool"])
    }
    if (fullInit == true || state.energyPollingSupported == null) state.energyPollingSupported = true
    if (fullInit == true || state.rejoinCounter == null) state.rejoinCounter = 0
    
    def ep = device.getEndpointId()
    if ( ep  != null && ep != 'F2') {
        state.destinationEP = ep
        if (logEnable==true) log.trace "${device.displayName} destinationEP = ${state.destinationEP}"
    }
    else {
        if (txtEnable==true) log.warn "${device.displayName} Destination End Point not found or invalid(${ep}), please re-pair the device!"
        state.destinationEP = "01"    // fallback EP
    }    
}

def driverVersionAndTimeStamp() {version()+' '+timeStamp()}

def checkDriverVersion() {
    if (state.driverVersion == null || driverVersionAndTimeStamp() != state.driverVersion) {
        if (txtEnable==true) log.info "${device.displayName} updating the settings from driver version ${state.driverVersion} to version ${driverVersionAndTimeStamp()}"
        // correct some typos prior version 1.7.2
        if (settings?.energyTreshold != null) { device.updateSetting("energyThreshold", [value:settings?.energyTreshold , type:"number"]); settings?.remove("energyTreshold")}
        if (settings?.powerTreshold != null) { device.updateSetting("powerThreshold", [value:settings?.powerTreshold , type:"number"]); settings?.remove("powerTreshold")}
        if (settings?.amperageTreshold != null) { device.updateSetting("amperageThreshold", [value:settings?.amperageTreshold , type:"number"]); settings?.remove("amperageTreshold")}
        if (settings?.voltageTreshold != null) { device.updateSetting("voltageThreshold", [value:settings?.voltageTreshold , type:"number"]); settings?.remove("voltageTreshold")}
        if (state.lastAmperage != null) state.remove("lastAmperage")
        if (state.lastVoltage != null) state.remove("lastVoltage")
        if (state.lastEnergy != null) state.remove("lastEnergy")
        if (state.lastPower != null) state.remove("lastPower")
        if (state.lastPresenceState != null) state.remove("lastPresenceState")
        device.deleteCurrentState("presence")    // completely removed in ver 1.7.3
        state.driverVersion = driverVersionAndTimeStamp()
        
        runIn(1, 'initializeVars',  [overwrite: true])
    }
}

def logInitializeResults() {
    if (logEnable==true) log.info "${device.displayName} switchPollingSupported  = ${state.switchPollingSupported}"
    if (logEnable==true) log.info "${device.displayName} voltagePollingSupported = ${state.voltagePollingSupported}"
    if (logEnable==true) log.info "${device.displayName} currentPollingSupported = ${state.currentPollingSupported}"
    if (logEnable==true) log.info "${device.displayName} powerPollingSupported   = ${state.powerPollingSupported}"
    if (logEnable==true) log.info "${device.displayName} energyPollingSupported  = ${state.energyPollingSupported}"
    if (logEnable==true) log.info "${device.displayName} Initialization finished"
}

def initialize() {
    if (txtEnable==true) log.warn "${device.displayName} Initialize()..."
    unschedule()
    initializeVars(fullInit = true)
    runIn( 1, resetEnergy, [overwrite: true])      // 09/18/2022
    runIn( 2, refresh, [overwrite: true])      // 09/18/2022
    runIn( 11, updated, [overwrite: true])          // calls also configure()
    runIn( 12, logInitializeResults, [overwrite: true])
    scheduleHourlyAndDailyEnergy()
}

// This method is called when the device is first created.
def installed() {
    if (txtEnable==true) log.info "${device.displayName} Installed()..."
    initializeVars(fullInit = true)
    runIn( 5, initialize, [overwrite: true])
    if (logEnable==true) log.debug "${device.displayName} calling initialize() after 5 seconds..."
    // HE will automatically call configure() method here
}

void uninstalled() {
    if (logEnable==true) log.info "${device.displayName} Uninstalled()..."
    unschedule()     // unschedule any existing schedules
}

// not used !
def powerRefresh() {
    def cmds = zigbee.electricMeasurementPowerRefresh()
    cmds.each{
        sendHubCommand(new hubitat.device.HubMultiAction(delayBetween(cmds,200), hubitat.device.Protocol.ZIGBEE))
    }
    if (state.txCounter != null) state.txCounter = state.txCounter + 1
}

// called when any event was received from the Zigbee device in parse() method..
def setPresent() {
    if ((device.currentValue("healthStatus", true) ?: "unknown") != "online") {
        sendHealthStatusEvent("online")
        runIn( 1, formatAttrib, [overwrite: true])    
    }
    state.notPresentCounter = 0
}

// called from autoPoll()
def checkIfNotPresent() {
    if (state.notPresentCounter != null) {
        state.notPresentCounter = state.notPresentCounter + 1
        if (state.notPresentCounter > presenceCountThreshold) {
            if ((device.currentValue("healthStatus", true) ?: "unknown") != "offline" ) {
                sendHealthStatusEvent("offline")
                if (logEnable==true) log.warn "${device.displayName} not present!"
                runIn( 1, formatAttrib, [overwrite: true])    
            }
        }
    }
}

private getPACKET_ID() {
    return zigbee.convertToHexString(Math.abs(new Random().nextInt() % 65536), 4) 
}

private sendTuyaCommand(dp, dp_type, fncmd, delay=200) {
    ArrayList<String> cmds = []
    cmds += zigbee.command(CLUSTER_TUYA, SETDATA, [:], delay, PACKET_ID + dp + dp_type + zigbee.convertToHexString((int)(fncmd.length()/2), 4) + fncmd )
    if (settings?.logEnable) log.trace "${device.displayName} sendTuyaCommand = ${cmds}"
    state.txCounter = state.txCounter ?:0 + 1
    return cmds
}


void sendZigbeeCommands(List<String> cmds) {
    if (logEnable) {log.trace "${device.displayName} sendZigbeeCommands : ${cmds}"}
	sendHubCommand(new hubitat.device.HubMultiAction(cmds, hubitat.device.Protocol.ZIGBEE))
    if (state.txCounter != null) state.txCounter = state.txCounter + 1
}

def logsOff(){
    log.warn "${device.displayName} debug logging disabled..."
    device.updateSetting("logEnable", [value:"false",type:"bool"])
}

boolean isTuyaE00xCluster( String description )
{
    if(description.indexOf('cluster: E000') >= 0 || description.indexOf('cluster: E001') >= 0) {
        if (logEnable) log.debug "${device.displayName} Tuya cluster: E000 or E001 - don't know how to handle it, skipping it for now..."
        return true
    }
    else
        return false
}

// return true if further processing in the main parse method should be cancelled !
boolean otherTuyaOddities( String description ) {
  
    if (description.indexOf('cluster: 0000') >= 0 && description.indexOf('attrId: 0004') >= 0) {
        if (logEnable) log.debug "${device.displayName} skipping Tuya parse of  cluster 0 attrId 4"             // parseDescriptionAsMap throws exception when processing Tuya cluster 0 attrId 4 
        return true
    }
    def descMap = [:]
    try {
        descMap = zigbee.parseDescriptionAsMap(description)
    }
    catch ( e ) {
        if (logEnable) log.warn "${device.displayName} exception caught while parsing <b>otherTuyaOddities</b> descMap:  ${descMap}"
        return true
    }
    //if (logEnable) {log.trace "${device.displayName} Checking Tuya Oddities Desc Map: $descMap"}        
    if (descMap.attrId == null ) {
        //if (logEnable) log.trace "${device.displayName} otherTuyaOddities - Cluster ${descMap.clusterId} NO ATTRIBUTE, skipping"
        return false
    }
    boolean bWasAtLeastOneAttributeProcessed = false
    // attribute report received
    List attrData = [[cluster: descMap.cluster ,attrId: descMap.attrId, value: descMap.value, status: descMap.status]]
    descMap.additionalAttrs.each {
        attrData << [cluster: descMap.cluster, attrId: it.attrId, value: it.value, status: it.status]
        //log.trace "Tuya oddity: filling in attrData ${attrData}"
    }
    attrData.each {
        //log.trace "each it=${it}"
        def map = [:]
        if (it.status == "86") {
            if (settings?.logEnable) log.info "${device.displayName} Tuya Cluster ${descMap.cluster} <b>unsupported attrId ${it.attrId}</b>"
            // TODO - skip parsing?
        }
        switch (it.cluster) {
            case "0000" :
                if (it.attrId in ["0001"]) {
                    if (settings?.logEnable) log.debug "${device.displayName} Tuya check-in Cluster 0 attrId 1 (application version is ${it.value})"
                    bWasAtLeastOneAttributeProcessed = true
                }
                else if (it.attrId in ["FFE0", "FFE1", "FFE2", "FFE4"]) {
                    if (settings?.logEnable) log.debug "${device.displayName} Tuya Cluster ${descMap.cluster} attrId ${it.attrId} value ${it.value})"
                    bWasAtLeastOneAttributeProcessed = true
                }
                else if (it.attrId in ["FFFE", "FFDF"]) {
                    if (settings?.logEnable) log.debug "${device.displayName} Tuya Cluster ${descMap.cluster} attrId ${it.attrId} value ${it.value})"
                    bWasAtLeastOneAttributeProcessed = true
                }
                else {
                    if (logEnable) log.debug "${device.displayName} otherTuyaOddities - Cluster ${descMap.cluster} attrId ${it.attrId} value ${it.value}) N/A, skipping"
                }
                break
            case "0006" :
                if (it.attrId in ["4000", "4001", "4002", "4004", "8000", "8001", "8002", "8003"]) {
                    parseOnOffAttributes(it)
                    bWasAtLeastOneAttributeProcessed = true
                }
                else {
                    //if (settings?.logEnable) log.warn "${device.displayName} unprocessed On/Off Cluster ${it.cluster} attrId ${it.attrId} value ${it.value}"
                }
                break
            default :
                //if (logEnable) log.trace "${device.displayName} otherTuyaOddities - Cluster ${it.cluster} N/A, skipping"
                break
        } // switch
    } // for each attribute
    return bWasAtLeastOneAttributeProcessed
}



def childLock( mode ) {
    ArrayList<String> cmds = []
    if (state.model == "TS0601") {
        def dp = "1D" // hochChildLock: 29
        def value = mode == "off" ? "00" : "01"
        cmds += sendTuyaCommand(dp, DP_TYPE_BOOL, value)
    }
    else {
        // doesn't work for TS0121 _TZ3000_g5xawfcq :( 
        def value = mode == "off" ? "00" : mode == "on" ? "01" : null
        if (value != null) {
            cmds += zigbee.writeAttribute(zigbee.ON_OFF_CLUSTER, 0x8000, DataType.BOOLEAN, value.toInteger())
            if (settings?.logEnable) log.trace "${device.displayName} sending child lock mode : ${mode}"
            sendZigbeeCommands( cmds )    
        }
        else {
            if (settings?.logEnable) log.warn "${device.displayName} please select a Child Lock option"
        }
    }
}

def ledMode( mode ) {
    ArrayList<String> cmds = []
    String value = null
    if (state.model == "TS0601") {
        if (settings?.logEnable) log.warn "${device.displayName} LED mode not implemented for TS0601: ${mode}"
        // continue anyway ..
    }
    if (isCircuitBreaker()) {
        value = mode == "Always Green" ? "00" : mode == "Red when On; Green when Off" ? "01" : mode == "Green when On; Red when Off" ? "02" : mode == "Always Red" ? "03" : null
    }
    else {
        value = mode == "Disabled" ? "00" : mode == "Lit when On" ? "01" : mode == "Lit when Off" ? "02" : mode == "Freeze" ? "03" : null
    }
    if (value != null) {
        cmds += zigbee.writeAttribute(zigbee.ON_OFF_CLUSTER, 0x8001, DataType.ENUM8, value.toInteger())
        if (settings?.logEnable) log.trace "${device.displayName} sending LED mode : ${mode}"
        sendZigbeeCommands( cmds )    
    }
    else {
        if (mode.contains("---")) {
            if (settings?.logEnable) log.warn "${device.displayName} please select a LED mode option"
        }
        else {
            if (settings?.logEnable) log.warn "${device.displayName} LED mode ${mode} is not supported for your model:${device.getDataValue('model') } manufacturer:${device.getDataValue('manufacturer')}"
        }
    }
}

def powerOnState( mode ) {
    ArrayList<String> cmds = []
    String value = null
    Integer attribute = 0
    if (state.model == "TS0601") {
        if (settings?.logEnable) log.warn "${device.displayName} Power On State not implemented for TS0601: ${mode}"
        // continue anyway ..
    }
    else if (isSengledOutlet() || isJascoProductsOutlet() || (isFrientEnergyMonitor() || isFrientOutlet() || isCCM300() || isSiHAS()) || isSmartThingsOutlet() || isThirdReality()) {
        value = mode == "off" ? "00" : mode == "on" ? "01" : mode == "Last state" ? "02" : null
        attribute = 0x4003
    }
    else {    // Tuya TS004F
        value = mode == "off" ? "00" : mode == "on" ? "01" : mode == "Last state" ? "02" : null
        attribute = 0x8002
    }
    if (value != null) {
        cmds += zigbee.writeAttribute(zigbee.ON_OFF_CLUSTER, attribute, DataType.ENUM8, value.toInteger())
        if (settings?.logEnable) log.trace "${device.displayName} sending Power On State mode : ${mode}"
        sendZigbeeCommands( cmds )    
    }
    else {
        if (settings?.logEnable) log.warn "${device.displayName} please select a Power On State option"
    }
}

private getIDENTIFY_CMD_IDENTIFY() { 0x00 }
private getIDENTIFY_CMD_QUERY() { 0x01 }
private getIDENTIFY_CMD_TRIGGER() { 0x40 }

def intTo16bitUnsignedHex(value) {
	def hexStr = zigbee.convertToHexString(value.toInteger(),4)
	return new String(hexStr.substring(2, 4) + hexStr.substring(0, 2))
}

def intTo8bitUnsignedHex(value) {
	return zigbee.convertToHexString(value.toInteger(), 2)
}

Integer safeToInt(val, Integer defaultVal=0) {
	return "${val}"?.isInteger() ? "${val}".toInteger() : defaultVal
}

Double safeToDouble(val, Double defaultVal=0.0) {
	return "${val}"?.isDouble() ? "${val}".toDouble() : defaultVal
}

def identify() {
	List<String> cmds = []
	cmds += "he cmd 0x${device.deviceNetworkId} 0x${device.endpointId} 0x0003 ${IDENTIFY_CMD_IDENTIFY} { 0x${intTo16bitUnsignedHex(30)} }"    // Identify for 30 seconds
	//cmds += "he cmd 0x${device.deviceNetworkId} 0x${device.endpointId} 0x0003 ${IDENTIFY_CMD_TRIGGER} { 0x${intTo8bitUnsignedHex(EFFECT_BREATHE)} 0x${intTo8bitUnsignedHex(0)} }"    // Trigger Effect
    if (txtEnable==true) log.info "${device.displayName} sending Identify to ${device.getDataValue('manufacturer')}"
    //cmds += zigbee.command(0x0003, 0x00, "0500")        // 5 seconds?
    if (state.txCounter != null) state.txCounter = state.txCounter + 1
	return cmds;
}

def disableReporting(String measurement, Boolean sendNow=true) {
    // TODO
}

def configureReporting(String operation, String measurement,  String minTime="0", String maxTime="0", String delta="0", Boolean sendNow=true ) {
    int intMinTime = safeToInt(minTime)
    int intMaxTime = safeToInt(maxTime)
    int intDelta = safeToInt(delta)
    def ep = safeToInt(state.destinationEP)
    if (ep==null || ep==0) ep = 1
    
    logDebug "configureReporting operation=${operation}, measurement=${measurement}, minTime=${intMinTime}, maxTime=${intMaxTime}, delta=${intDelta} )"

    List<String> cmds = []      
    
    switch (measurement) {
        case ONOFF :
            if (operation == "Write") {
                cmds += zigbee.onOffConfig(intMinTime, intMaxTime)  // Configure On/Off 
            }
            cmds +=  zigbee.reportingConfiguration(0x0006, 0x0000, [destEndpoint :ep], 250)    // read it back
            break
        case ENERGY :    // default delta = 1 Wh (0.001 kWh)
            if (operation == "Write") {
                // attr. 0x0000 = Current Summation Delivered UINT48;
                if (isHeiman()) {intDelta = intDelta * 10}    // Heiman "SmartPlug"
                cmds += zigbee.configureReporting(0x0702, 0x0000,  DataType.UINT48, intMinTime, intMaxTime, intDelta)
                // attr. 0x0400 = Instantaneous Demand INT24 (!)
                // if (isHeiman()) {intDelta = intDelta * 10}    // also Bitron => "902010/25"
                // TODO !!!!!!!
            }
            cmds += zigbee.reportingConfiguration(0x0702, 0x0000, [destEndpoint :ep], 250)
            break
        case INST_POWER :        // 0x702:0x400
            if (operation == "Write") {
                if (isHeiman()) {intDelta = intDelta * 10}    // Heiman "SmartPlug"
                // TODO - check if DataType 0x29 is used for power configuration for Samsung and CentraLite plugs ... 
                cmds += zigbee.configureReporting(0x0702, 0x0400,  DataType.INT16, intMinTime, intMaxTime, intDelta)
            }
            cmds += zigbee.reportingConfiguration(0x0702, 0x0400, [destEndpoint :ep], 250)
            break
        case POWER :        // Active power default delta = 1
            if (operation == "Write") {
                if (isHeiman()) {intDelta = intDelta * 10}    // Heiman "SmartPlug"
                // TODO - check if DataType 0x29 is used for power configuration for Samsung and CentraLite plugs ... 
                cmds += zigbee.configureReporting(0x0B04, 0x050B,  DataType.INT16, intMinTime, intMaxTime, intDelta)    // bug fixes in ver  1.6.0 - thanks @guyee
            }
            cmds += zigbee.reportingConfiguration(0x0B04, 0x050B, [destEndpoint :ep], 250)
            break
        case VOLTAGE :    // RMS Voltage default delta = 1
            if (operation == "Write") {
                if (isHeiman()) {intDelta = intDelta * 100}          // Heiman "SmartPlug"
                else if (isSercomm()) {intDelta = intDelta * 125}    // Telstra smart plug 1v = 125
                cmds += zigbee.configureReporting(0x0B04, 0x0505,  DataType.UINT16, intMinTime, intMaxTime, intDelta)
            }
            cmds += zigbee.reportingConfiguration(0x0B04, 0x0505, [destEndpoint :ep], 250)
            break
        case AMPERAGE :    // RMS Current default delta = 100 mA = 0.1 A
            if (operation == "Write") {
                if (isHeiman() || isDevelco()) {intDelta = (intDelta / 10) as int}  
                if (intDelta < 1) {intDelta = 1}
                cmds += zigbee.configureReporting(0x0B04, 0x0508,  DataType.UINT16, intMinTime, intMaxTime, intDelta)
            }
            cmds += zigbee.reportingConfiguration(0x0B04, 0x0508, [destEndpoint :ep], 250)
            break
        case FREQUENCY :    // added 03/27/2023
            if (operation == "Write") {
                cmds += zigbee.configureReporting(0x0B04, 0x0300,  DataType.UINT16, intMinTime, intMaxTime, intDelta)
            }
            cmds += zigbee.reportingConfiguration(0x0B04, 0x0300, [destEndpoint :ep], 250)
            break
        case POWER_FACTOR : // added 03/27/2023
            if (operation == "Write") {
                cmds += zigbee.configureReporting(0x0B04, 0x0510,  DataType.UINT16, intMinTime, intMaxTime, intDelta)
            }
            cmds += zigbee.reportingConfiguration(0x0B04, 0x0510, [destEndpoint :ep], 250)
            break
        default :
            break
    }
    if (cmds != null) {
        if (sendNow == true) {
            sendZigbeeCommands(cmds)
        }
        else {
            return cmds
        }
    }
}

def setEnergyPrice( price )
{
    if (price != null) {
        def priceDouble = safeToDouble( price ).round(6)
        if (priceDouble >= 0.001) {
            refresh()        //  poll(true)
            runIn(3, 'setEnergyPriceDelayed',  [overwrite: true, data: priceDouble])
        }
        else {
            if (settings?.txtEnable) log.warn "${device.displayName} please enter energy price between \$0.001 and \$99.999"
        }
    }
}

def setEnergyPriceDelayed( priceDouble )
{
    device.updateSetting("energyPrice", [value:priceDouble, type:"decimal"])
    if (settings?.txtEnable) log.info "${device.displayName} energy price was set to ${priceDouble} on ${FormattedDateTimeFromUnix(now())}"
}

def resetEnergy() {
    if (settings?.logEnable) log.debug "resetEnergy() : state.lastEnergyRaw = ${state.lastEnergyRaw}"
    def now = FormattedDateTimeFromUnix( now() )
    state.lastResetDate = now
    state.lastEnergyCost = 0.0
    state.lastResetEnergy = state.lastEnergyRaw
    state.lastHourlyEnergy = state.lastEnergyRaw
    //
    runInMillis( 100, afterResetEvents, [overwrite: true])

}

def afterResetEvents() {
    energyEvent( 0, isDigital=true )
    hourlyEnergyEvent( 0, isDigital=true )
    energyCostEvent( 0, isDigital=true ) 
    energyDurationEvent( 0, isDigital=true  )
    if (settings?.txtEnable) log.info "${device.displayName} Energy (total:${state.lastEnergyRaw} kWh) was reset on ${state.lastResetDate}"
}

def calculateEnergyDuration() {
	def energyTimeMS = unixFromFormattedDateTime( state.lastResetDate )
	if (!energyTimeMS) {
		return "Unknown"
	}
    def duration = roundTwoPlaces((new Date().time - energyTimeMS) / 60000)
		
		if (duration >= (24 * 60)) {
			return getFormattedDuration(duration, (24 * 60), "Day")
		}
		else if (duration >= 60) {
			return getFormattedDuration(duration, 60, "Hour")
		}
		else {
			return getFormattedDuration(duration, 0, "Min")    // was "Minute"
		}
}

def getFormattedDuration(duration, divisor, name) {
	if (divisor) {
		duration = roundTwoPlaces(duration / divisor)
	}	
	return "${duration} ${name}${duration == 1 ? '' : 's'}"
}

def roundTwoPlaces(val) {
	return Math.round(safeToDouble(val) * 100) / 100
}

 
@Field static final String dateFormat = 'yyyy-MM-dd HH:mm:ss.SSS'

def unixFromFormattedDateTime( formattedDateTime ) {
    def unixDateTime = Date.parse(dateFormat, formattedDateTime).time
    return unixDateTime
}

def FormattedDateTimeFromUnix( unixDateTime ) {
    def formattedDateTime = new Date(unixDateTime).format(dateFormat, location.timeZone) 
    return formattedDateTime
}

void formatAttrib() {
    if (attribEnable == false) {
        /* changed in ver 1.7.3. 03/27/2023 - do not send empty html attribute - will this break anything?
        sendEvent(name: "html", value: "<table></table>", isChanged: false)     
        */
        return
    }
    if (settings?.logEnable) log.debug "formatAttrib"
    String attrStr = "<style>td{text-align:left;}</style><table id='hubInfoTable'>"
    
    attrStr += addToAttr("status", "healthStatus")
    if (!isFrientEnergyMonitor()) {
        attrStr += addToAttr("Switch","switch")
    }
    if (reportPower == true) {
        attrStr += addToAttr("Power", "power"/*, convert ="int"*/)
    }
    if (reportVoltage == true) {
        attrStr += addToAttr("Voltage","voltage")
    }
    if (reportAmperage == true) {
        attrStr += addToAttr("Amperage","amperage", convert = "double")
    }
    if (isEnergyEnabled()) {
        attrStr += addToAttr("Energy","energy")
        attrStr += addToAttr("Last hour","hourlyEnergy")
        attrStr += addToAttr("Cost","energyCost")
        attrStr += addToAttr("Duration","energyDuration")
    }
    attrStr += "</table>"
    updateAttr("html", attrStr)
    if (attrStr.length() > 1024) { updateAttr("html", "Max Attribute Size Exceeded: ${attrStr.length()}") }
}

String combineAttr(String name, List<String> keys) {
    String retResult = '<tr><td align="left">'
    retResult += name + '</td><td align="left">'
    
    String keyResult = ""
    for (i = 0;i < keys.size(); i++) {
        keyResult += device.currentValue(keys[i],true)
        String attrUnit = getUnitFromState(keys[i])
        if (attrUnit != null) keyResult += " " + attrUnit
        if (i < keys.size() - 1) keyResult += " / "
    }
            
    retResult += keyResult + '</td></tr>'
    return retResult
}

String addToAttr(String name, String key, String convert = "none") {
    String retResult = '<tr><td>'
    retResult += name + '</td><td>'

    String attrUnit = getUnitFromState(key)
    if (attrUnit == null) attrUnit = ""

    def curVal = device.currentValue(key,true)
    if (curVal != null) {
        if (convert == "int") {
              retResult += safeToInt(curVal).toString() + " " + attrUnit
        } 
        else if (convert == "double") {
            retResult += safeToDouble(curVal).toString() + " " + attrUnit
        } 
        else 
            retResult += curVal.toString() + " " + attrUnit
    }
    else {
        retResult += "n/a"
    }
    retResult += '</td></tr>'
    return retResult
}

String getUnitFromState(String attrName){
   	return device.currentState(attrName)?.unit
}

void updateAttr(String aKey, aValue, String aUnit = "") {
    sendEvent(name:aKey, value:aValue, unit:aUnit)
}

def deviceNotification(text) {
    if (settings?.logEnable) log.debug "deviceNotification: ${text}"
}

def logDebug(msg) {
    if (settings?.logEnable) {
        log.debug "${device.displayName} " + msg
    }
}

def logInfo(msg) {
    if (settings?.txtEnable) {
        log.info "${device.displayName} " + msg
    }
}

def logWarn(msg) {
    if (settings?.logEnable) {
        log.warn "${device.displayName} " + msg
    }
}

def pulseConfiguration( pulses ) {
    List<String> cmds = []
    if (pulses != null) {
        def pulsesInt = safeToInt( pulses )
        if (pulsesInt >= 100 && pulsesInt <= 100000) {
            if (state.txCounter != null) state.txCounter = state.txCounter + 1
            cmds += zigbee.writeAttribute(0x0702, 0x0300, DataType.UINT16, pulsesInt, [mfgCode: 0x1015], delay=250)
            cmds += zigbee.readAttribute(0x0702, 0x0300, [mfgCode: 0x1015], delay=100)
            logDebug "sending pulse configuration : ${pulsesInt}"
        }
        else {
            logWarn "please enter a valid pulse configuration value between 100 and 10000 (default is 1000)"
        }
    }
    return cmds
}


def setEnergyMeterMode( mode ) {
    ArrayList<String> cmds = []
    if (mode != null) {
        def key = develcoInterfaceMode.find{it.value==mode}?.key
        logDebug "sending setEnergyMeterMode ${mode} key=${key}"
        if (key != null) {
            cmds += zigbee.writeAttribute(0x0702, 0x0302, DataType.UINT8, safeToInt(key), [mfgCode: 0x1015], delay=251)
            cmds += zigbee.readAttribute(0x0702, 0x0302, [mfgCode: 0x1015], delay=101)
        }
        else {
            logWarn "invalid energy mode ${mode}"
        }
    }
    return cmds
}

def sendHealthStatusEvent(value) {
    sendEvent(name: "healthStatus", value: value, descriptionText: "${device.displayName} healthStatus set to $value")
}


def test() {
        ArrayList<String> cmds = []
        cmds += zigbee.readAttribute(0x0000, 0x0001, [destEndpoint : 0x01], delay=200)    // App version
        cmds += zigbee.readAttribute(0x0702, 0x0000, [destEndpoint : 0x01], delay=200)            // energy - polled only on full Refresh    ATTRIBUTE_READING_INFO_SET
    return cmds
}


