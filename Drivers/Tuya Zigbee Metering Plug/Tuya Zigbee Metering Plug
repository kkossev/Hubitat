/**
 *  Tuya Zigbee Metering Plug driver for Hubitat Elevation - Power, Energy, Voltage, Amperage
 *
 *  https://community.hubitat.com/t/release-tuya-zigbee-metering-plug/86465
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License. You may obtain a copy of the License at:
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *  for the specific language governing permissions and limitations under the License.
 *
 *  The inital version was based on "SmartThings/iquix" DHT
 *
 *  ver. 1.0.0 2021-11-09 kkossev - first version: - reads Power, Energy, Voltage, Amperage once every 60 seconds
 *  ver. 1.0.1 2021-11-10 kkossev - added 'pollingInterval' preference; 'amperage' attribute name bug fix; 
 *  ver. 1.1.0 2021-11-12 kkossev - added 'PresenceSensor' capability; the automatic polling can be switched off.
 *  ver. 1.1.1 2021-11-25 kkossev - added Tuya Outlet TS011F fingerprint
 *  ver. 1.1.2 2021-12-24 kkossev - added Tuya / Neo NAS-WR01 fingerprint; fingerprint inClusters correction
 *  ver. 1.2.0 2021-12-29 kkossev - major refactoring and optimizations
 *  ver. 1.2.1 2021-12-29 kkossev - added AlwaysOn option
 *  ver. 1.3.0 2022-01-01 kkossev - added 'HIKING TOMZN DDS238-2 TS0601'
 *  ver. 1.3.1 2022-01-02 kkossev - minor bug fixes
 *  ver. 1.3.2 2022-01-12 kkossev - Tuya cluster command bug fix (HIKING TOMZN TS0601)
 *  ver. 1.4.0 2022-01-23 kkossev - debug / trace logging cleanup; initialize switch and energy automatic reporting mode; energy and switch are excluded from polling; 
 *                                  default debug loging is false, optimizations are true; switch digital/physical bug fixed; added driver version check
 *  ver. 1.4.1 2022-01-27 kkossev - added XH-002P Outlet TS011F fingerprint (no power monitoring!)
 *  ver. 1.4.2 2022-02-20 kkossev - missing Switch capability bug fix
 *  ver. 1.4.3 2022-02-15 kkossev - added 'Tuya RC-RCBO Circuit Breaker' 
 *  ver. 1.4.4 2022-05-08 kkossev - added new fingerprints; [overwrite: true] explicit option for runIn timers; settings reset bug fix; 
 *  ver. 1.4.5 2022-05-24 kkossev - added _TZ3000_5f43h46b XUELILI 16A UK; _TZ3000_r6buo8ba; _TZ3000_ksw8qtmt NOUS A1Z; _TZ3000_1h2x4akh Ajax/Zignito; _TZ3000_ky0fq4ho DIN Relay; GreenPower cluster 0xF2 fix?
 *                                  added childLock, ledMode, powerOnState configuration commands; importURL is the development branch
 *  ver. 1.4.6 2022-06-04 kkossev - added _TZ3000_gjnozsaz;  added on/off switches for power, amperage, voltage and energy reporting (logs+Events); added device display name in all logs
 *  ver. 1.5.0 2022-06-05 kkossev - Bug fix - all settings were reset back in to the defaults on hub reboot; parsing 'other Tuya oddities..'; over current alarm 0x8003; 'Freeze' LED mode (sets the backlight to the current state); 
 *  ver. 1.5.1 2022-06-12 kkossev - ChildLock bug fix
 *  ver. 1.5.2 2022-09-09 kkossev - added _TZ3000_cehuw1lw _TZ3000_typdpbpg; automatic reporting configuration bug fixes
 * 
 *
 */
import groovy.json.*
import groovy.transform.Field
import hubitat.zigbee.zcl.DataType

def version() { "1.5.2" }
def timeStamp() {"2022/09/09 1:46 PM"}

@Field static final Boolean debug = false

metadata {
    definition (name: "Tuya Zigbee Metering Plug", namespace: "kkossev", author: "Krassimir Kossev", importUrl: "https://raw.githubusercontent.com/kkossev/Hubitat/development/Drivers/Tuya%20Zigbee%20Metering%20Plug/Tuya%20Zigbee%20Metering%20Plug", singleThreaded: true ) {
        capability "EnergyMeter"
        capability "PowerMeter"
        capability "CurrentMeter"
        capability "VoltageMeasurement"
        capability "Actuator"    
        capability "Switch"
        capability "Outlet"
        capability "Refresh"
        capability "Health Check"
        capability "Sensor"
        capability "PresenceSensor"
        capability "Polling"
        
        command "initialize", [[name: "Manually initialize the plug after switching drivers.  \n\r     ***** Will load device default values! *****" ]]
        command "childLock", [[name:"Child Lock", type: "ENUM", description: "Select Child Lock mode", constraints: ["--- Select ---", "off", "on"]]]
        command "ledMode", [[name:"LED mode", type: "ENUM", description: "Select LED mode", constraints: ["--- Select ---", "Disabled", "Lit when On", "Lit when Off", "Freeze", "Always Green", "Red when On; Green when Off", "Green when On; Red when Off", "Always Red" ]]]
        command "powerOnState", [[name:"Power On State", type: "ENUM", description: "Select Power On State", constraints: ["--- Select ---", "off", "on", "Last state"]]]
        
        if (debug == true) {
            command "identify", [[name: "Identify the plug for 30 seconds"]]    // works for OSRAM plug only :( 
            command "configureReporting", [ 
                [name: "operation*",   type: "ENUM", constraints: ["--- Select ---", "Read", "Write"]],
                [name: "measurement*", type: "ENUM", constraints: ["--- Select ---", ONOFF, ENERGY, POWER, VOLTAGE, AMPERAGE], description: "Select measurement to configure"],
                [name: "Minimum Reporting Interval (seconds)", type: "STRING", defaultValue : "10", description: "Select Minimum reporting time (in seconds)"],
                [name: "Maximum Reporting Interval (seconds)", type: "STRING", defaultValue : "3600", description: "Select Maximim reporting time (in seconds)"],
                [name: "Minimum measurement change",           type: "STRING", defaultValue : "1", description: "Select Minimum measurement change to be reported"]
            ]
            //command "test", [[name: "test", type: "STRING", description: "test", defaultValue : ""]]
        }

        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0004,0005,0006,0702,0B04", outClusters:"0019,000A", manufacturer:"_TZ3000_vtscrpmw", model:"TS0121",  deviceJoinName: "Tuya Outlet" //Tuya Smart Plug
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0004,0005,0006,0702,0B04", outClusters:"0019,000A", manufacturer:"_TZ3000_3ooaz3ng", model:"TS0121",  deviceJoinName: "Tuya Outlet" //Tuya Smart Plug        
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0004,0005,0006,0702 0B04", outClusters:"0019,000A", manufacturer:"_TZ3000_rdtixbnu", model:"TS0121",  deviceJoinName: "Tuya Outlet" //Tuya Smart Plug    
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0004,0005,0006,0702,0B04", outClusters:"0019,000A", model:"TS0121", manufacturer:"_TZ3000_g5xawfcq",  deviceJoinName: "Blitzwolf BW-SHP13" //Blitzwolf BW-SHP13  
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0702,0B04,E000,E001", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_cphmq0q7", deviceJoinName: "Tuya Outlet TS011F" //TS011F   
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0702,0B04,E000,E001", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_ps3dmato",  deviceJoinName: "Lellki WK35 Plug Wall Socket"   
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0702,0B04,E000,E001", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_1h2x4akh",  deviceJoinName: "Ajax/Zignito Plug Wall Socket"   
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,0702,0B04,E000,E001,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_w0qqde0g", deviceJoinName: "Neo NAS-WR01 Outlet TS011F"  
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,E000,E001,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_v1pdxuqq", deviceJoinName: "XH-002P Outlet TS011F No Power Monitoring"  // - no power monitoring !
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,E000,E001,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_hyfvrar3", deviceJoinName: "TS011F No Power Monitoring"  // - no power monitoring !
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,E000,E001,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_cymsnfvf", deviceJoinName: "TS011F No Power Monitoring"  // - no power monitoring !
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,E000,E001,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_bfn1w0mm", deviceJoinName: "TS011F No Power Monitoring"  // - no power monitoring !
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,E000,E001,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_gjnozsaz", deviceJoinName: "NEO ZigBee On Off Power Metering Plug"  // https://ultrasmart.pl/en_GB/p/NEO-ZigBee-On-Off-Power-Metering-Plug/81
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0004,0005,EF00", outClusters:"0019,000A", model:"TS0601", manufacturer:"_TZE200_byzdayie", deviceJoinName: "HIKING TOMZN DDS238-2 TS0601_din"  
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0004,0005,EF00", outClusters:"0019,000A", model:"TS0601", manufacturer:"_TZE200_fsb6zw01", deviceJoinName: "Tuya Energy Device"  
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0004,0005,EF00", outClusters:"0019,000A", model:"TS0601", manufacturer:"_TZE200_hkdl5fmv", deviceJoinName: "Tuya RC-RCBO Circuit Breaker"
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,0702,0B04,E001,E000,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_ky0fq4ho", deviceJoinName: "ATMS1602Z DIN Relay"
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,0702,0B04,E001,E000,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_ksw8qtmt", deviceJoinName: "Smart ZigBee Socket NOUS A1Z" //https://nous.technology/product/a1z-1.html
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,0702,0B04,E001,E000,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_5f43h46b", deviceJoinName: " XUELILI 16A UK Standards Smart Outlet"
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,0702,0B04,E001,E000,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_cehuw1lw", deviceJoinName: "Haozee Smart Zigbee Plug 16A/20A EU Outlet" // https://www.aliexpress.com/item/1005002344798281.html  //
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,0702,0B04,E001,E000,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_typdpbpg", deviceJoinName: "Tuya Smart Zigbee Plug AU 16A" // https://www.aliexpress.com/item/1005004505868292.html
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0B04,0702", outClusters:"0003,0019,0006,E001", model:"TS011F", manufacturer:"_TZ3000_r6buo8ba", deviceJoinName: "US Power Outlet"  // https://www.aliexpress.com/item/1005004128965720.htm
    }
    
    
    
    preferences {
        input (name: "logEnable", type: "bool", title: "<b>Debug logging</b>", description: "<i>Debug information, useful for troubleshooting. Recommended value is <b>false</b></i>", defaultValue: false)
        input (name: "txtEnable", type: "bool", title: "<b>Description text logging</b>", description: "<i>Display measured values in HE log page. Recommended value is <b>true</b></i>", defaultValue: true)
        input (name: "autoPollingEnabled", type: "bool", title: "<b>Automatic polling</b>", description: "<i>Enable outlet automatic polling for power, voltage, amperage, energy and switch state. Recommended value is <b>true</b></i>", defaultValue: true)
        if (autoPollingEnabled?.value == true) {
            input (name: "pollingInterval", type: "number", title: "<b>Polling interval</b>, seconds", description: "<i>The time period when the smart plug will be polled for power, voltage and amperage readings. Recommended value is <b>60 seconds</b></i>", 
                   range: "10..3600", defaultValue: defaultPollingInterval)
        }
        input (name: "alwaysOn", type: "bool", title: "<b>Always On</b>", description: "<i>Disable switching OFF for plugs that must be always On</i>", defaultValue: false)
        input (name: "optimizations", type: "bool", title: "<b>Optimize polling and logging</b>", description: "<i>Additional optimizations to reduce the hub load</i>. Recommended value is <b>true</b>", defaultValue: true)
        if (optimizations?.value == true) {
            input (name: "reportEnergy", type:    "bool", title: "<b>Energy Reporting On or Off</b>",  description:  "<i>(Disable reporting when not desired)</i>", defaultValue: true)
            if (reportEnergy?.value == true) {
                input (name: "energyMinReportingTime", type: "number", title: "<b>Energy shortest reporting interval</b>, seconds", description: "<i>The minimum allowed time between two Energy reports. Recommended value is <b>60 seconds</b></i>", 
                   range: "10..86399", defaultValue: 60)
                input (name: "energyMaxReportingTime", type: "number", title: "<b>Energy longest reporting interval</b>, seconds", description: "<i>The maximum time without any Energy reports. Recommended value is <b>3600 seconds</b></i>", 
                   range: "120..86400", defaultValue: 3600)
                input (name: "energyTreshold", type: "number", title: "<b>Energy minimum change to be reported</b>, Wh", description: "<i>The minimum Energy change that will trigger reporting.</i>", 
                   range: "0..10000", defaultValue: 0)
            }
            input (name: "reportAmperage", type: "bool", title: "<b>Amperage Reporting On or Off</b>", description: "<i>(Disable reporting when not desired)</i>", defaultValue: true)
            input (name: "reportVoltage", type:  "bool", title: "<b>Voltage Reporting On or Off</b>",  description: "<i>(Disable reporting when not desired)</i>", defaultValue: true)
            input (name: "reportPower", type:    "bool", title: "<b>Power Reporting On or Off</b>",  description:   "<i>(Disable reporting when not desired)</i>", defaultValue: true)
        } 
    }
}

// Constants
@Field static final Integer powerDiv = 1
@Field static final Integer energyDiv = 100
@Field static final Integer currentDiv = 1000
@Field static final Integer presenceCountTreshold = 3
@Field static final Integer defaultPollingInterval = 60
@Field static final Integer debouncingTimer = 300
@Field static final Integer digitalTimer = 1000
@Field static final Integer refreshTimer = 3000
@Field static String UNKNOWN = "UNKNOWN"
@Field static final String ONOFF = "Switch"
@Field static final String POWER = "Power"
@Field static final String ENERGY = "Energy"
@Field static final String VOLTAGE = "Voltage"
@Field static final String AMPERAGE = "Amperage"

def isTS0121() {state.model == "TS0121"}
def isCircuitBreaker() {device.getDataValue("manufacturer") in ["_TZ3000_ky0fq4ho"]}

def parse(String description) {
    if (logEnable == true) log.debug "${device.displayName} parse: description is $description"
    checkDriverVersion()
    if (state.rxCounter != null) state.rxCounter = state.rxCounter + 1
    setPresent()
    if (isTuyaE00xCluster(description) == true || otherTuyaOddities(description) == true) {
        return null
    }
    def event = [:]
    try {
        event = zigbee.getEvent(description)
    }
    catch ( e ) {
        log.warn "${device.displayName} parse: exception caught while parsing description:  ${description}"
        //return null
    }
    if (event) {
        if (logEnable==true) log.debug "${device.displayName} Event enter: $event"
        switch (event.name) {
            case "switch" :
                switchEvent( event.value )
                break
            // for smart plugs that can be configured to fire atimaticallty power and energy events ..
            case "power" :    
                powerEvent(event.value/powerDiv)
                break
            case "energy" :
                energyEvent(event.value/energyDiv)
                break
            default :
                if (txtEnable) {log.warn "${device.displayName} received <b>unhandled event</b> ${event.name} = $event.value"} 
                break
        }
        return null //event
    }
    else {
        //List result = []
        def descMap = [:]
        try {
            descMap = zigbee.parseDescriptionAsMap(description)
        }
        catch ( e ) {
            log.warn "${device.displayName} parse: exception caught while parsing descMap:  ${descMap}"
            return null
        }
        //if (logEnable) {log.debug "${device.displayName} parse: Desc Map: $descMap"}
        if (descMap.attrId != null ) {
            // attribute report received
            List attrData = [[cluster: descMap.cluster ,attrId: descMap.attrId, value: descMap.value, status: descMap.status]]
            descMap.additionalAttrs.each {
                attrData << [cluster: descMap.cluster, attrId: it.attrId, value: it.value, status: it.status]
            }
            attrData.each {
                def map = [:]
                if (it.status == "86") {
                    disableUnsupportedAttribute(descMap.cluster, it.attrId)
                }
                else if (it.value && it.cluster == "0B04" && it.attrId == "050B") {
                        powerEvent(zigbee.convertHexToInt(it.value)/powerDiv)
                        if (state.lastPower != zigbee.convertHexToInt(it.value)/powerDiv ) {
                            if (logEnable) {log.trace "${device.displayName} power changed from <b>${state.lastPower}</b> to <b>${zigbee.convertHexToInt(it.value)/powerDiv}</b>"}
                            state.lastPower = zigbee.convertHexToInt(it.value)/powerDiv
                        }
                }
                else if (it.value && it.cluster == "0B04" && it.attrId == "0505") {
                    voltageEvent(zigbee.convertHexToInt(it.value)/powerDiv)
                }
                else if (it.value && it.cluster == "0B04" && it.attrId == "0508") {
                    amperageEvent(zigbee.convertHexToInt(it.value)/currentDiv)
                }
                else if (it.value && it.cluster == "0B04" && it.attrId == "0510") {    //Power Factor Attribute ID: 0x0510
                    if (txtEnable) {log.info "${device.displayName} power Factor reported: ${it.value}" }    // not tested
                }
                else if (it.value && it.cluster == "0702" && it.attrId == "0000") {
                    energyEvent(zigbee.convertHexToInt(it.value)/energyDiv)
                }
                /*
                else if ( it.cluster == "0000" && it.attrId in ["0001", "FFE0", "FFE1", "FFE2", "FFE4", "FFFE", "FFDF"]) {
                    if (logEnable) {log.debug "${device.displayName} Tuya specific attribute ${it.attrId}  cluster ${it.cluster } reported: value=${it.value}" }    // not tested
                }
                else if ( it.cluster == "0006" && it.attrId in ["8000", "8001", "8002"]) {
                    parseOnOffAttributes(it)
                }
                */
                else {
                    if (logEnable==true) log.warn "${device.displayName} Unprocessed attribute report: cluster=${it.cluster} attrId=${it.attrId} value=${it.value} status=${it.status} data=${descMap.data}"
                }
                //if (logEnable) {log.debug "${device.displayName} Parse returned $map"}
            } // for each attribute
        } // if attribute report
        else if (descMap.profileId == "0000") { //zdo
            parseZDOcommand(descMap)
        } 
        else if (descMap.clusterId != null && descMap.profileId == "0104") { // ZHA global command
            parseZHAcommand(descMap)
        } 
        else {
            if (logEnable==true)  log.warn "${device.displayName} Unprocesed unknown command: cluster=${descMap.clusterId} command=${descMap.command} attrId=${descMap.attrId} value=${descMap.value} data=${descMap.data}"
        }
        return null //result
    } // descMap
}


def parseOnOffAttributes( it ) {
    if (logEnable) {log.debug "${device.displayName} OnOff attribute ${it.attrId} cluster ${it.cluster } reported: value=${it.value}" }
    def mode
    def attrName
    if (it.value == null) {
        //if (logEnable) log.trace "${device.displayName} OnOff attribute ${it.attrId} cluster ${it.cluster } skipping NULL value status=${it.status}"
        return
    }
    def value = it.value as int
    switch (it.attrId) {
        case "8000" :    // command "childLock", [[name:"Child Lock", type: "ENUM", description: "Select Child Lock mode", constraints: ["off", "on"]]]
            attrName = "Child Lock"
            mode = value == 0 ? "off" : "on"
            break
        case "8001" :    // command "ledMode", [[name:"LED mode", type: "ENUM", description: "Select LED mode", constraints: ["Disabled", "Lit when On", "Lit when Off", "Always Green", "Red when On; Green when Off", "Green when On; Red when Off", "Always Red" ]]]
            attrName = "LED mode"
            if (isCircuitBreaker()) {
                mode = value == 0 ? "Always Green" : value == 1 ? "Red when On; Green when Off" : value == 2 ? "Green when On; Red when Off" : value == 3 ? "Always Red" : null
            }
            else {
                mode = value == 0 ? "Disabled"  : value == 1 ? "Lit when On" : value == 2 ? "Lit when Off" : value == 3 ? "Freeze": null
            }
            break
        case "8002" :    // command "powerOnState", [[name:"Power On State", type: "ENUM", description: "Select Power On State", constraints: ["off","on", "Last state"]]]
            attrName = "Power On State"
            mode = value == 0 ? "off" : value == 1 ? "on" : value == 2 ?  "Last state" : null
            break
        case "8003" : //  Over current alarm
            attrName = "Over current alarm"
            mode = value == 0 ? "Over Current OK" : value == 1 ? "Over Current Alarm" : null
            break
        default :
            if (logEnable) log.warn "${device.displayName} Unprocessed Tuya OnOff attribute ${it.attrId} cluster ${it.cluster } reported: value=${it.value}"
            return
    }
    if (txtEnable) log.info "${device.displayName} ${attrName} is ${mode}"
}

def switchEvent( value ) {
    def map = [:] 
    boolean bWasChange = false
    if (state.switchDebouncing==true && value==state.lastSwitchState) {    // some plugs send only catchall events, some only readattr reports, but some will fire both...
        if (logEnable) {log.debug "${device.displayName} Ignored duplicated switch event for model ${state.model}"} 
        runInMillis( debouncingTimer, switchDebouncingClear, [overwrite: true])
        return null
    }
    map.type = state.isDigital == true ? "digital" : "physical"
    if (state.lastSwitchState != value ) {
        bWasChange = true
        if (logEnable) {log.debug "${device.displayName} Switch state changed from <b>${state.lastSwitchState}</b> to <b>${value}</b>"}
        if (autoPollingEnabled == true) {
            runInMillis(5000, pollPower, [overwrite: true])
            runIn( pollingInterval, autoPoll, [overwrite: true]) // restart polling interval timer
        }
        state.switchDebouncing = true
        state.lastSwitchState = value
        runInMillis( debouncingTimer, switchDebouncingClear, [overwrite: true])
    }
    map.name = "switch"
    map.value = value
    if (state.isRefreshRequest == true || state.model == "TS0601") {
        map.descriptionText = "${device.displayName} switch is ${value}"
    }
    else {
        map.descriptionText = "${device.displayName} was turned ${value} [${map.type}]"
    }
    if (optimizations==false || bWasChange==true ) 
    {
        if (txtEnable) {log.info "${device.displayName} ${map.descriptionText}"}
        sendEvent(map)
    }
    clearIsDigital()
}

def voltageEvent( voltage ) {
    def map = [:] 
    map.name = "voltage"
    map.value = voltage
    map.unit = "V"
    if (state.lastVoltage != voltage || optimizations == false || state.isRefreshRequest == true ) {
        state.lastVoltage = voltage
        if (settings?.reportVoltage == true) {
            if (txtEnable) {log.info "${device.displayName} ${map.name} is ${map.value} ${map.unit}"}
            sendEvent(map)
        }
    }
}

def powerEvent( power ) {
    def map = [:] 
    map.name = "power"
    map.value = power
    map.unit = "W"
    if (state.lastPower != power || optimizations == false || state.isRefreshRequest == true ) {
        state.lastPower = power    
        if (settings?.reportPower == true) {
            if (txtEnable) {log.info "${device.displayName} ${map.name} is ${map.value} ${map.unit}"}
            sendEvent(map)
        }
    }
}

def amperageEvent( amperage ) {
    def map = [:] 
    map.name = "amperage"
    map.value = amperage
    map.unit = "A"
    if (state.lastAmperage != amperage || optimizations == false || state.isRefreshRequest == true  ) {
        state.lastAmperage = amperage    
        if (settings?.reportAmperage == true) {
            if (txtEnable) {log.info "${device.displayName} ${map.name} is ${map.value} ${map.unit}"}
            sendEvent(map)
        }
    }
}

def energyEvent( energy ) {
    def map = [:] 
    map.name = "energy"
    map.value = energy
    map.unit = "kWh"
    if (state.lastEnergy != energy || optimizations==false || state.isRefreshRequest == true ) {
        state.lastEnergy = energy
        if (true) {        // energy is reported once per hour without being polled!
            if (txtEnable) {log.info "${device.displayName} ${map.name} is ${map.value} ${map.unit}"}
            sendEvent(map)
        }
    }
    else {
        if (logEnable) {log.debug "${device.displayName} ${map.name} is ${map.value} ${map.unit} (no change)"}
    }
}



def parseZDOcommand( Map descMap ) {
    switch (descMap.clusterId) {
        case "0006" :
            if (logEnable) log.info "${device.displayName} Received match descriptor request, data=${descMap.data} (Sequence Number:${descMap.data[0]}, Input cluster count:${descMap.data[5]} Input cluster: 0x${descMap.data[7]+descMap.data[6]})"
            break
        case "0013" : // device announcement
            if (logEnable) log.info "${device.displayName} Received device announcement, data=${descMap.data} (Sequence Number:${descMap.data[0]}, Device network ID: ${descMap.data[2]+descMap.data[1]}, Capability Information: ${descMap.data[11]})"
            break
        case "8004" : // simple descriptor response
            if (logEnable) log.info "${device.displayName} Received simple descriptor response, data=${descMap.data} (Sequence Number:${descMap.data[0]}, status:${descMap.data[1]}, lenght:${hubitat.helper.HexUtils.hexStringToInt(descMap.data[4])}"
            parseSimpleDescriptorResponse( descMap )
            break
        case "8005" : // endpoint response
            if (logEnable) log.info "${device.displayName} Received endpoint response: cluster: ${descMap.clusterId} (endpoint response) endpointCount = ${ descMap.data[4]}  endpointList = ${descMap.data[5]}"
            break
        case "8021" : // bind response
            if (logEnable) log.info "${device.displayName} Received bind response, data=${descMap.data} (Sequence Number:${descMap.data[0]}, Status: ${descMap.data[1]=="00" ? 'Success' : '<b>Failure</b>'})"
            break
        case "8038" : // Management Network Update Notify
            if (logEnable) log.info "${device.displayName} Received Management Network Update Notify, data=${descMap.data}"
            break
        default :
            if (logEnable) log.warn "${device.displayName} Unprocessed ZDO command: cluster=${descMap.clusterId} command=${descMap.command} attrId=${descMap.attrId} value=${descMap.value} data=${descMap.data}"
    }
}

def parseSimpleDescriptorResponse(Map descMap) {
    //log.info "${device.displayName} Received simple descriptor response, data=${descMap.data} (Sequence Number:${descMap.data[0]}, status:${descMap.data[1]}, lenght:${hubitat.helper.HexUtils.hexStringToInt(descMap.data[4])}"
    if (logEnable==true) log.info "${device.displayName} Endpoint: ${descMap.data[5]} Application Device:${descMap.data[9]}${descMap.data[8]}, Application Version:${descMap.data[10]}"
    def inputClusterCount = hubitat.helper.HexUtils.hexStringToInt(descMap.data[11])
    def inputClusterList = ""
    for (int i in 1..inputClusterCount) {
        inputClusterList += descMap.data[13+(i-1)*2] + descMap.data[12+(i-1)*2] + ","
    }
    inputClusterList = inputClusterList.substring(0, inputClusterList.length() - 1)
    if (logEnable==true) log.info "${device.displayName} Input Cluster Count: ${inputClusterCount} Input Cluster List : ${inputClusterList}"
    if (getDataValue("inClusters") != inputClusterList)  {
        if (logEnable==true) log.warn "${device.displayName} inClusters=${getDataValue('inClusters')} differs from inputClusterList:${inputClusterList} - will be updated!"
        updateDataValue("inClusters", inputClusterList)
    }
    
    def outputClusterCount = hubitat.helper.HexUtils.hexStringToInt(descMap.data[12+inputClusterCount*2])
    def outputClusterList = ""
    for (int i in 1..outputClusterCount) {
        outputClusterList += descMap.data[14+inputClusterCount*2+(i-1)*2] + descMap.data[13+inputClusterCount*2+(i-1)*2] + ","
    }
    outputClusterList = outputClusterList.substring(0, outputClusterList.length() - 1)
    if (logEnable==true) log.info "${device.displayName} Output Cluster Count: ${outputClusterCount} Output Cluster List : ${outputClusterList}"
    if (getDataValue("outClusters") != outputClusterList)  {
        if (logEnable==true) log.warn "${device.displayName} outClusters=${getDataValue('outClusters')} differs from outputClusterList:${outputClusterList} -  will be updated!"
        updateDataValue("outClusters", outputClusterList)
    }
}

def disableUnsupportedAttribute(String clusterId, String attrId) {
    switch (clusterId) {
        case "0006" :    // Switch
            if (logEnable==true) log.warn "${device.displayName} Switch polling is not supported -> Switch polling will be disabled."
            state.switchPollingSupported = false
            break
        case "0B04" : // Electrical Measurement attribute is not supported!
            switch (attrId) {
                case "0505" :    // Voltage
                    if (logEnable==true) log.warn "${device.displayName} Voltage polling is not supported -> Voltage polling will be disabled."
                    state.voltagePollingSupported = false
                    break
                case "0508" :     // Current
                    if (logEnable==true) log.warn "${device.displayName} Current polling is not supported -> Current polling will be disabled."
                    state.currentPollingSupported = false
                    break
                case "050B" :     // Power
                    if (logEnable==true) log.warn "${device.displayName} Power polling is not supported! -> Power polling will be disabled."
                    state.powerPollingSupported = false
                    break
                default :
                    if (logEnable==true) log.warn "${device.displayName} Read attribute response: unsupported Attributte ${attrId} for Electrical Measurement cluster ${clusterId}"
                    break
            }
            break
        case "0702" : // Simple Metering Cluster
            if (logEnable==true) log.warn "${device.displayName} Energy measurement is not supported! -> Energy polling will be disabled."
            state.energyPollingSupported = false
            break
        default :
            if (logEnable==true) log.warn "${device.displayName} Read attribute response: unsupported Attributte ${attrId} cluster ${clusterId}"
            break
    }
}

def parseZHAcommand( Map descMap) {
    switch (descMap.command) {
        case "01" : //read attribute response. If there was no error, the successful attribute reading would be processed in the main parse() method.
            def status = descMap.data[2]
            def attrId = descMap.data[1] + descMap.data[0] 
            if (status == "86") {
                disableUnsupportedAttribute(descMap.clusterId, attrId)
                if (logEnable==true) log.trace "${device.displayName} descMap = ${descMap}"
            }
            else {
                switch (descMap.clusterId) {
                    case "EF00" :
                        //if (logEnable==true) log.warn "${device.displayName} Tuya cluster read attribute response: code ${status} Attributte ${attrId} cluster ${descMap.clusterId} data ${descMap.data}"
                        def attribute = getAttribute(descMap.data)
                        def value = getAttributeValue(descMap.data)
                        //if (logEnable==true) log.trace "${device.displayName} attribute=${attribute} value=${value}"
                        def map = [:]
                        def cmd = descMap.data[2]
                        switch (cmd) { // code : descMap.data[2]    ; attrId = descMap.data[1] + descMap.data[0] 
                            case "01" : // switch
                                switchEvent(value==0 ? "off" : "on")
                                break
                            case "11" : // Energy
                                energyEvent(value/100)
                                break
                            case "12" : // Amperage
                                amperageEvent(value/1000)
                                break
                            case "13" : // Power
                                powerEvent(value/10)
                                break
                            case "14" : // Voltage
                                voltageEvent(value/10)
                                break
                            case "1D" : // hochChildLock: 29
                                if (txtEnable==true) log.info "${device.displayName} Child Lock = ${value==0 ? 'off' : 'on'}"
                                break
                            case "65" : // Voltage HOCH
                                voltageEvent((zigbee.convertHexToInt(descMap.data[7]) | zigbee.convertHexToInt(descMap.data[6]) << 8) / 10)
                                break
                            case "66" : // Amperage HOCH
                                amperageEvent((zigbee.convertHexToInt(descMap.data[8]) | zigbee.convertHexToInt(descMap.data[7]) << 8) / 1000)
                                break
                            case "67" : // hochActivePower: 103
                                powerEvent((zigbee.convertHexToInt(descMap.data[8]) | zigbee.convertHexToInt(descMap.data[7]) << 8) / 10)
                                break
                            case "69" : // hochTemperature: 105
                                log.info "${device.displayName} temperature is ${(zigbee.convertHexToInt(descMap.data[9]))}"
                                break
                            case "09" : // hochCountdownTimer: 9
                            case "1A" : // hochFaultCode: 26
                            case "1B" : // hochRelayStatus: 27 (power recovery behaviour)
                            case "68" : // hochLeakageCurrent: 104
                            case "6A" : // hochRemainingEnergy: 106
                            case "6B" : // "recharge energy" : 107
                            case "6C" : // hochCostParameters: 108 (non-zero)
                            case "6D" : // hochLeakageParameters: 109 (non-zero)
                            case "6E" : // hochVoltageThreshold: 110 (non-zero)
                            case "6F" : // hochCurrentThreshold: 111 (non-zero)
                            case "70" : // hochTemperatureThreshold: 112 (non-zero)
                            case "71" : // hochTotalActivePower: 113
                            case "72" : // hochEquipmentNumberType: 114
                            case "73" : //: "clear energy",115
                            case "74" : // hochLocking: 116  (test button pressed)
                            case "75" : // hochTotalReverseActivePower: 117
                            case "76" : // hochHistoricalVoltage: 118
                            case "77" : // hochHistoricalCurrent: 119
                                log.trace "${device.displayName} cmd = ${cmd}  value = ${(zigbee.convertHexToInt(descMap.data[7]) | zigbee.convertHexToInt(descMap.data[6]) << 8)}"
                                break
                            default :
                                if (logEnable==true) log.warn "${device.displayName} Tuya unknown attribute: ${descMap.data[0]}${descMap.data[1]}=${descMap.data[2]}=${descMap.data[3]}${descMap.data[4]} data.size() = ${descMap.data.size()} value: ${value}}"
                                if (logEnable==true) log.warn "${device.displayName} map= ${descMap}"
                                break
                        }
                        break
                    default :
                        if (logEnable==true) log.warn "${device.displayName} Read attribute response: unknown status code ${status} Attributte ${attrId} cluster ${descMap.clusterId}"
                        break
                } // switch (descMap.clusterId)
            }  //command is read attribute response
            break
        case "04" : //write attribute response
            if (logEnable==true) log.info "${device.displayName} Received Write Attribute Response for cluster:${descMap.clusterId} , data=${descMap.data} (Status: ${descMap.data[0]=="00" ? 'Success' : '<b>Failure</b>'})"
            break
        case "07" : // Configure Reporting Response
            if (logEnable==true) log.info "${device.displayName} Received Configure Reporting Response for cluster:${descMap.clusterId} , data=${descMap.data} (Status: ${descMap.data[0]=="00" ? 'Success' : '<b>Failure</b>'})"
            // Status: Unreportable Attribute (0x8c)
            break
        case "09" : // Command: Read Reporting Configuration Response (0x09)
            // TS0121 Received Read Reporting Configuration Response (0x09) for cluster:0006 , data=[00, 00, 00, 00, 10, 00, 00, 58, 02] (Status: Success) min=0 max=600
            // TS0121 Received Read Reporting Configuration Response (0x09) for cluster:0702 , data=[00, 00, 00, 00, 25, 3C, 00, 10, 0E, 00, 00, 00, 00, 00, 00] (Status: Success) min=60 max=3600
            def status = zigbee.convertHexToInt(descMap.data[0])    // Status: Success (0x00)
            def attr = zigbee.convertHexToInt(descMap.data[3])*256 + zigbee.convertHexToInt(descMap.data[2])    // Attribute: OnOff (0x0000)
            if (status == 0) {
                def dataType = zigbee.convertHexToInt(descMap.data[4])    // Data Type: Boolean (0x10)
                def min = zigbee.convertHexToInt(descMap.data[6])*256 + zigbee.convertHexToInt(descMap.data[5])
                def max = zigbee.convertHexToInt(descMap.data[8]+descMap.data[7])
                if (logEnable==true) log.info "${device.displayName} Received Read Reporting Configuration Response (0x09) for cluster:${descMap.clusterId} attribite:${descMap.data[3]+descMap.data[2]}, data=${descMap.data} (Status: ${descMap.data[0]=="00" ? 'Success' : '<b>Failure</b>'}) min=${min} max=${max}"
            }
            else {
                if (logEnable==true) log.info "${device.displayName} <b>Not Found (0x8b)</b> Read Reporting Configuration Response for cluster:${descMap.clusterId} attribite:${descMap.data[3]+descMap.data[2]}, data=${descMap.data} (Status: ${descMap.data[0]=="00" ? 'Success' : '<b>Failure</b>'})"
            }
            break
        case "0B" : // ZCL Default Response
            def status = descMap.data[1]
            if (status != "00") {
                switch (descMap.clusterId) {
                    case "0003" : // Identify response
                        if (txtEnable==true) log.warn "${device.displayName} Identify command is not supported by ${device.getDataValue('manufacturer')}"
                        break
                    case "0006" : // Switch state
                        if (logEnable==true) log.warn "${device.displayName} Switch state is not supported -> Switch polling will be disabled."
                        state.switchPollingSupported = false
                        break    // fixed in ver. 1.5.0
                    case "0B04" : // Electrical Measurement
                        if (logEnable==true) log.warn "${device.displayName} Electrical measurement is not supported -> Power, Voltage and Amperage polling will be disabled."
                        state.powerPollingSupported = false
                        state.voltagePollingSupported = false
                        state.currentPollingSupported = false
                        break
                    case "0702" : // Energy
                        if (logEnable==true) log.warn "${device.displayName} Energy measurement is not supported -> Energy polling will be disabled."
                        state.energyPollingSupported = false
                        break
                    default :
                        if (logEnable==true) log.info "${device.displayName} Received ZCL Default Response to Command ${descMap.data[0]} for cluster:${descMap.clusterId} , data=${descMap.data} (Status: ${descMap.data[1]=="00" ? 'Success' : '<b>Failure</b>'})"
                        break
                }
            }
            break
        case "24" :    // Tuya time sync
            if (settings?.logEnable) log.trace "${device.displayName} Tuya time sync"
            if (descMap?.clusterInt==0xEF00 && descMap?.command == "24") {        //getSETTIME
                if (settings?.logEnable) log.debug "${device.displayName} time synchronization request from device, descMap = ${descMap}"
                def offset = 0
                try {
                    offset = location.getTimeZone().getOffset(new Date().getTime())
                }
                catch(e) {
                    if (settings?.logEnable) log.error "${device.displayName} cannot resolve current location. please set location in Hubitat location setting. Setting timezone offset to zero"
                }
                def cmds = zigbee.command(0xEF00, 0x24, "0008" +zigbee.convertToHexString((int)(now()/1000),8) +  zigbee.convertToHexString((int)((now()+offset)/1000), 8))
                if (settings?.logEnable) log.trace "${device.displayName} now is: ${now()}"  // KK TODO - convert to Date/Time string!        
                if (settings?.logEnable) log.debug "${device.displayName} sending time data : ${cmds}"
                cmds.each{ sendHubCommand(new hubitat.device.HubAction(it, hubitat.device.Protocol.ZIGBEE)) }
                if (state.txCounter != null) state.txCounter = state.txCounter + 1
                return
            }
            break
        default :
            if (logEnable==true) log.warn "${device.displayName} Unprocessed global command: cluster=${descMap.clusterId} command=${descMap.command} attrId=${descMap.attrId} value=${descMap.value} data=${descMap.data}"
    }
}

private String getAttribute(ArrayList _data) {
    String retValue = ""
    if (_data.size() >= 5) {
        if (_data[2] == "01" && _data[3] == "01" && _data[4] == "00") {
            retValue = "switch"
        }
        else if (_data[2] == "02" && _data[3] == "02" && _data[4] == "00") {
            retValue = "level"
        }
    }
    return retValue
}

private int getAttributeValue(ArrayList _data) {
    int retValue = 0
    try {    
    if (_data.size() >= 6) {
        int dataLength = zigbee.convertHexToInt(_data[5]) as Integer
        int power = 1;
        for (i in dataLength..1) {
            retValue = retValue + power * zigbee.convertHexToInt(_data[i+5])
            power = power * 256
        }
    }
}
    catch ( e ) {
        log.error "${device.displayName} Exception caught : data = ${_data}"
    }
    return retValue
}

def off() {
    if (alwaysOn == true) {
        if (logEnable==true) log.warn "${device.displayName} AlwaysOn option for ${device.displayName} is enabled , the command to switch it OFF is ignored!"
    }
    else {
        state.isDigital = true
        if (logEnable) {log.debug "${device.displayName} Switching ${device.displayName} Off"}
        def cmds = zigbee.off()
        if (state.model == "TS0601") {
            cmds = zigbee.command(0xEF00, 0x0, "00010101000100")
        }
        runInMillis( digitalTimer, clearIsDigital, [overwrite: true])
        if (state.txCounter != null) state.txCounter = state.txCounter + 1
        return cmds
    }
}

def on() {
    state.isDigital = true
    if (logEnable) {log.debug "${device.displayName} Switching ${device.displayName} On"}
    def cmds = zigbee.on()
    if (state.model == "TS0601") {
        cmds = zigbee.command(0xEF00, 0x0, "00010101000101")
    }
    runInMillis( digitalTimer, clearIsDigital, [overwrite: true])
    if (state.txCounter != null) state.txCounter = state.txCounter + 1
    return cmds
}

def clearIsDigital() { state.isDigital = false }

def isRefreshRequestClear() { state.isRefreshRequest = false }

def switchDebouncingClear() { state.switchDebouncing = false }



// * PING is used by Device-Watch in attempt to reach the Device
def ping() {
    return refresh()
}

def pollPower() {
    if (logEnable) {log.debug "${device.displayName} pollPower().."}
    List<String> cmds = []
    if (state.powerPollingSupported & state.voltagePollingSupported & state.currentPollingSupported == true) {
        if (settings?.reportPower == true || settings?.reportVoltage == true || settings?.reportAmperage == true) {
            cmds += zigbee.readAttribute(0x0B04, [0x050B, 0x0505, 0x0508], dummy, delay=200)    // Power, Voltage and Amperage at once!
        }
    }
    else {
        cmds += zigbee.electricMeasurementPowerRefresh()    // just power
    }
    state.isRefreshRequest = true
    runInMillis( refreshTimer, isRefreshRequestClear, [overwrite: true])       // 3 seconds
    if (state.txCounter != null) state.txCounter = state.txCounter + 1
    return cmds
}


// Sends refresh / readAttribute commands to the plug
def poll( refreshAll = false ) {
    if (logEnable) {log.trace "${device.displayName} polling.. refreshAll is ${refreshAll}"}
    checkDriverVersion()
    List<String> cmds = []
    if (state.switchPollingSupported == true && refreshAll == true ) {
        cmds = zigbee.onOffRefresh()                            // switch - polled only on full Refresh
    }
    if (state.powerPollingSupported & state.voltagePollingSupported & state.currentPollingSupported == true) {
        if (settings?.reportPower == true || settings?.reportVoltage == true || settings?.reportAmperage == true) {
            if (logEnable) {log.trace "${device.displayName} polling all"}
            cmds += zigbee.readAttribute(0x0B04, [0x050B, 0x0505, 0x0508], dummy, delay=200)    // Power, Voltage and Amperage at once!
        }
    }
    else {
        if (state.powerPollingSupported == true && settings?.reportPower == true) 
            cmds += zigbee.electricMeasurementPowerRefresh()    // Power ( cluster 0B04, attr. 050B )
        if (state.voltagePollingSupported == true && settings?.reportVoltage == true)
            cmds += zigbee.readAttribute(0x0B04, 0x0505)        // voltage
        if (state.currentPollingSupported == true  && settings?.reportAmperage == true)
            cmds += zigbee.readAttribute(0x0B04, 0x0508)        // current
    }    
    if (state.energyPollingSupported == true && refreshAll == true )
        cmds += zigbee.readAttribute(0x0702, 0x0000)            // energy - polled only on full Refresh
    state.isRefreshRequest = true
    runInMillis( refreshTimer, isRefreshRequestClear, [overwrite: true])           // 3 seconds
    if (state.txCounter != null) state.txCounter = state.txCounter + 1
    return cmds
}


def refresh() {
    if (logEnable) {log.debug "${device.displayName} refresh()..."}
    poll( true )
}

def autoPoll() {
    if (logEnable) {log.debug "${device.displayName} autoPoll()"}
    checkIfNotPresent()
    if (autoPollingEnabled?.value == true) {
        if ( pollingInterval != null ) 
            runIn( pollingInterval, autoPoll, [overwrite: true])
        else
            runIn( defaultPollingInterval, autoPoll, [overwrite: true])
    }
    if (optimizations == true) 
        poll( refreshAll = false )
    else 
        poll( refreshAll = true )
}

def tuyaBlackMagic() {
    if (state.txCounter != null) state.txCounter = state.txCounter + 1
    return zigbee.readAttribute(0x0000, [0x0004, 0x000, 0x0001, 0x0005, 0x0007, 0xfffe], [:], delay=200)    // Cluster: Basic, attributes: Man.name, ZLC ver, App ver, Model Id, Power Source, attributeReportingStatus
}

/*
    configure() method is called: 
       *  unconditionally during the initial pairing, immediately after Installed() method
       *  when Initialize button is pressed
       *  from updated() when preferencies are saved
*/
def configure() {
    if (txtEnable==true) log.info "${device.displayName} configure().."
    List<String> cmds = []
    cmds += tuyaBlackMagic()
    cmds += refresh()
    cmds += zigbee.onOffConfig()
    cmds += zigbee.configureReporting(0x0702, 0x0000, DataType.UINT48, energyMinReportingTime as int, energyMaxReportingTime as int, energyTreshold as int)// +    // Energy reporting
           //zigbee.electricMeasurementPowerConfig(1, 600, 1) 
    sendZigbeeCommands(cmds)
}


// This method is called when the preferences of a device are updated.
def updated(){
    if (txtEnable==true) log.info "${device.displayName} Updating ${device.getLabel()} (${device.getName()}) model ${state.model} presence: ${device.currentValue("presence")} AlwaysOn is <b>${alwaysOn}</b> "
    if (txtEnable==true) log.info "${device.displayName} Debug logging is <b>${logEnable}</b> Description text logging is  <b>${txtEnable}</b>"
    if (logEnable==true) {
        runIn(86400, logsOff, [overwrite: true])    // turn off debug logging after 24 hours
        if (txtEnable==true) log.info "${device.displayName} Debug logging will be automatically switched off after 24 hours"
    }
    else {
        unschedule(logsOff)
    }

    if (autoPollingEnabled?.value==true) {
        if ( pollingInterval != null ) {
            runIn( pollingInterval, autoPoll, [overwrite: true])
            if (txtEnable==true) log.info "${device.displayName} Auto polling is <b>enabled</b>, polling interval is ${pollingInterval} seconds"
        }
        else {
            runIn( defaultPollingInterval, autoPoll, [overwrite: true])
        }
    }
    else {
        unschedule(autoPoll)
        if (txtEnable==true) log.info "${device.displayName} Auto polling is <b>disabled</b>"
    }
    if (txtEnable==true) log.info "${device.displayName} configuring the switch and energy reporting.."
    configure()
}



void initializeVars( boolean fullInit = true ) {
    if (logEnable==true) log.info "${device.displayName} InitializeVars()... fullInit = ${fullInit}"
    if (fullInit == true ) {
        state.clear()
        state.driverVersion = driverVersionAndTimeStamp()
    }
    if (fullInit == true || state.rxCounter == null) state.rxCounter = 0
    if (fullInit == true || state.txCounter == null) state.txCounter = 0
    if (fullInit == true || state.lastPower == null) state.lastPower = 0.0
    if (fullInit == true || state.lastVoltage == null) state.lastVoltage = 0.0
    if (fullInit == true || state.lastAmperage == null) state.lastAmperage = 0.0
    if (fullInit == true || state.lastEnergy == null) state.lastEnergy = 0.0
    if (fullInit == true || state.lastSwitchState == null) state.lastSwitchState = "unknown"
    if (fullInit == true || state.lastPresenceState == null) state.lastPresenceState = "unknown"
    if (fullInit == true || state.notPresentCounter == null) state.notPresentCounter = 0
    if (fullInit == true || state.switchPollingSupported == null) state.switchPollingSupported = true
    if (fullInit == true || state.voltagePollingSupported == null) state.voltagePollingSupported = true
    if (fullInit == true || state.currentPollingSupported == null) state.currentPollingSupported = true
    if (fullInit == true || state.powerPollingSupported == null) state.powerPollingSupported = true
    if (fullInit == true || state.energyPollingSupported == null) state.energyPollingSupported = true
    if (fullInit == true || state.isDigital == null) state.isDigital = true
    if (fullInit == true || state.isRefreshRequest == null) state.isRefreshRequest = true
    if (fullInit == true || state.switchDebouncing == null) state.switchDebouncing = false
    if (fullInit == true || settings?.logEnable == null) device.updateSetting("logEnable", false)
    if (fullInit == true || settings?.txtEnable == null) device.updateSetting("txtEnable", true)
    if (fullInit == true || settings?.autoPollingEnabled == null) device.updateSetting("autoPollingEnabled", true)
    if (fullInit == true || settings?.optimizations == null) device.updateSetting("optimizations", true)
    if (fullInit == true || settings?.reportEnergy == null) device.updateSetting("reportEnergy", true)
    if (fullInit == true || settings?.reportPower == null) device.updateSetting("reportPower", true)
    if (fullInit == true || settings?.reportVoltage == null) device.updateSetting("reportVoltage", true)
    if (fullInit == true || settings?.reportAmperage == null) device.updateSetting("reportAmperage", true)
    if (fullInit == true || settings?.energyMinReportingTime == null) device.updateSetting("energyMinReportingTime", 60)
    if (fullInit == true || settings?.energyMaxReportingTime == null) device.updateSetting("energyMaxReportingTime", 3600)
    if (fullInit == true || settings?.energyTreshold == null) device.updateSetting("energyTreshold", 0)
    if (fullInit == true || settings?.pollingInterval == null) device.updateSetting("pollingInterval", defaultPollingInterval)
    if (settings?.alwaysOn == null)  device.updateSetting("alwaysOn", false)       // do not change the "alwaysOn" setting if already set!

    def mm = device.getDataValue("model")
    if ( mm != null) {
        state.model = mm
        if (logEnable==true) log.trace "${device.displayName} model = ${state.model}"
    }
    else {
        if (txtEnable==true) log.warn "${device.displayName} Model not found, please re-pair the device!"
        state.model = UNKNOWN
    }
    def ep = device.getEndpointId()
    if ( ep  != null && ep != 0xF2) {
        state.destinationEP = ep
        if (logEnable==true) log.trace "${device.displayName} destinationEP = ${state.destinationEP}"
    }
    else {
        if (txtEnable==true) log.warn "${device.displayName} Destination End Point not found, please re-pair the device!"
        state.destinationEP = "01"    // fallback EP
    }    
}

def driverVersionAndTimeStamp() {version()+' '+timeStamp()}

def checkDriverVersion() {
    if (state.driverVersion != null && driverVersionAndTimeStamp() == state.driverVersion) {
        //log.trace "${device.displayName} driverVersion is the same ${driverVersionAndTimeStamp()}"
    }
    else {
        if (txtEnable==true) log.info "${device.displayName} updating the settings from driver version ${state.driverVersion} to ${driverVersionAndTimeStamp()}"
        initializeVars( fullInit = false ) 
        state.driverVersion = driverVersionAndTimeStamp()
    }
}

def logInitializeRezults() {
    if (logEnable==true) log.info "${device.displayName} switchPollingSupported  = ${state.switchPollingSupported}"
    if (logEnable==true) log.info "${device.displayName} voltagePollingSupported = ${state.voltagePollingSupported}"
    if (logEnable==true) log.info "${device.displayName} currentPollingSupported = ${state.currentPollingSupported}"
    if (logEnable==true) log.info "${device.displayName} powerPollingSupported   = ${state.powerPollingSupported}"
    if (logEnable==true) log.info "${device.displayName} energyPollingSupported  = ${state.energyPollingSupported}"
    if (logEnable==true) log.info "${device.displayName} Initialization finished"
}

def initialize() {
    if (txtEnable==true) log.info "${device.displayName} Initialize()..."
    unschedule()
    initializeVars()
    updated()            // calls also configure()
    runIn( 12, logInitializeRezults, [overwrite: true])
}

// This method is called when the device is first created.
def installed() {
    if (txtEnable==true) log.info "${device.displayName} Installed()..."
    initializeVars()
    runIn( 5, initialize, [overwrite: true])
    if (logEnable==true) log.debug "${device.displayName} calling initialize() after 5 seconds..."
    // HE will autoomaticall call configure() method here
}

void uninstalled() {
    if (logEnable==true) log.info "${device.displayName} Uninstalled()..."
    unschedule()     //Unschedule any existing schedules
}

// not used !
def powerRefresh() {
    def cmds = zigbee.electricMeasurementPowerRefresh()
    cmds.each{
        sendHubCommand(new hubitat.device.HubMultiAction(delayBetween(cmds,200), hubitat.device.Protocol.ZIGBEE))
    }
    if (state.txCounter != null) state.txCounter = state.txCounter + 1
}

// called when any event was received from the Zigbee device in parse() method..
def setPresent() {
    if (state.lastPresenceState != "present") {
    	sendEvent(name: "presence", value: "present") 
        state.lastPresenceState = "present"
    }
    state.notPresentCounter = 0
}

// called from autoPoll()
def checkIfNotPresent() {
    if (state.notPresentCounter != null) {
        state.notPresentCounter = state.notPresentCounter + 1
        if (state.notPresentCounter > presenceCountTreshold) {
            if (state.lastPresenceState != "not present") {
    	        sendEvent(name: "presence", value: "not present")
                state.lastPresenceState = "not present"
                if (logEnable==true) log.warn "${device.displayName} not present!"
            }
        }
    }
}

void sendZigbeeCommands(List<String> cmds) {
    if (logEnable) {log.trace "${device.displayName} sendZigbeeCommands received : ${cmds}"}
	sendHubCommand(new hubitat.device.HubMultiAction(cmds, hubitat.device.Protocol.ZIGBEE))
    if (state.txCounter != null) state.txCounter = state.txCounter + 1
    // TODO - multiple commands ???
}

def logsOff(){
    log.warn "${device.displayName} debug logging disabled..."
    device.updateSetting("logEnable", [value:"false",type:"bool"])
}

boolean isTuyaE00xCluster( String description )
{
    if(description.indexOf('cluster: E000') >= 0 || description.indexOf('cluster: E001') >= 0) {
        if (logEnable) log.debug "${device.displayName} Tuya cluster: E000 or E001 - don't know how to handle it, skipping it for now..."
        return true
    }
    else
        return false
}



// return true if further processing in the main parse method should be cancelled !
boolean otherTuyaOddities( String description ) {
  
    if (description.indexOf('cluster: 0000') >= 0 && description.indexOf('attrId: 0004') >= 0) {
        if (logEnable) log.debug "${device.displayName} skipping Tuya parse of  cluster 0 attrId 4"             // parseDescriptionAsMap throws exception when processing Tuya cluster 0 attrId 4 
        return true
    }
    def descMap = [:]
    try {
        descMap = zigbee.parseDescriptionAsMap(description)
    }
    catch ( e ) {
        if (logEnable) log.warn "${device.displayName} exception caught while parsing <b>otherTuyaOddities</b> descMap:  ${descMap}"
        return true
    }
    //if (logEnable) {log.trace "${device.displayName} Checking Tuya Oddities Desc Map: $descMap"}        
    if (descMap.attrId == null ) {
        //if (logEnable) log.trace "${device.displayName} otherTuyaOddities - Cluster ${descMap.clusterId} NO ATTRIBUTE, skipping"
        return false
    }
    boolean bWasAtLeastOneAttributeProcessed = false
    // attribute report received
    List attrData = [[cluster: descMap.cluster ,attrId: descMap.attrId, value: descMap.value, status: descMap.status]]
    descMap.additionalAttrs.each {
        attrData << [cluster: descMap.cluster, attrId: it.attrId, value: it.value, status: it.status]
        //log.trace "tyua oddity: filling in attrData ${attrData}"
    }
    attrData.each {
        //log.trace "each it=${it}"
        def map = [:]
        if (it.status == "86") {
            if (settings?.logEnable) log.info "${device.displayName} Tuya Cluster ${descMap.cluster} <b>unsupported attrId ${it.attrId}</b>"
            // TODO - skip parsing?
        }
        switch (it.cluster) {
            case "0000" :
                if (it.attrId in ["0001"]) {
                    if (settings?.logEnable) log.info "${device.displayName} Tuya check-in Cluster 0 attrId 1 (application version is ${it.value})"
                    bWasAtLeastOneAttributeProcessed = true
                }
                else if (it.attrId in ["FFE0", "FFE1", "FFE2", "FFE4"]) {
                    if (settings?.logEnable) log.info "${device.displayName} Tuya Cluster ${descMap.cluster} attrId ${it.attrId} value ${it.value})"
                    bWasAtLeastOneAttributeProcessed = true
                }
                else if (it.attrId in ["FFFE", "FFDF"]) {
                    if (settings?.logEnable) log.info "${device.displayName} Tuya Cluster ${descMap.cluster} attrId ${it.attrId} value ${it.value})"
                    bWasAtLeastOneAttributeProcessed = true
                }
                else {
                    //if (logEnable) log.trace "${device.displayName} otherTuyaOddities - Cluster ${it.cluster} (Cluster ${cluster}) attrId ${it.attrId} N/A, skipping"
                }
                break
            case "0006" :
                if (it.attrId in ["8000", "8001", "8002", "8003"]) {
                    parseOnOffAttributes(it)
                    bWasAtLeastOneAttributeProcessed = true
                }
                if (it.attrId in ["4001", "4002"]) {
                    if (settings?.logEnable) log.info "${device.displayName} Tuya Cluster ${it.cluster} attrId ${it.attrId} value ${it.value}"
                    bWasAtLeastOneAttributeProcessed = true
                }
                break
            default :
                //if (logEnable) log.trace "${device.displayName} otherTuyaOddities - Cluster ${it.cluster} N/A, skipping"
                break
        } // switch
    } // for each attribute
    return bWasAtLeastOneAttributeProcessed
}



def childLock( mode ) {
    ArrayList<String> cmds = []
    if (state.model == "TS0601") {
        def dp = "1D" // hochChildLock: 29
        def value = mode == "off" ? "00" : "01"
        cmds += sendTuyaCommand(dp, DP_TYPE_BOOL, value)
    }
    else {
        // doesn't work for TS0121 _TZ3000_g5xawfcq :( 
        def value = mode == "off" ? "00" : mode == "on" ? "01" : null
        if (value != null) {
            cmds += zigbee.writeAttribute(zigbee.ON_OFF_CLUSTER, 0x8000, DataType.BOOLEAN, value.toInteger())
            if (settings?.logEnable) log.trace "${device.displayName} sending child lock mode : ${mode}"
            sendZigbeeCommands( cmds )    
        }
        else {
            if (settings?.logEnable) log.warn "${device.displayName} please select a Child Lock option"
        }
    }
}

def ledMode( mode ) {
    ArrayList<String> cmds = []
    String value = null
    if (state.model == "TS0601") {
        if (settings?.logEnable) log.warn "${device.displayName} LED mode not implemented for TS0601: ${mode}"
        // continue anyway ..
    }
    if (isCircuitBreaker()) {
        value = mode == "Always Green" ? "00" : mode == "Red when On; Green when Off" ? "01" : mode == "Green when On; Red when Off" ? "02" : mode == "Always Red" ? "03" : null
    }
    else {
        value = mode == "Disabled" ? "00" : mode == "Lit when On" ? "01" : mode == "Lit when Off" ? "02" : mode == "Freeze" ? "03" : null
    }
    if (value != null) {
        cmds += zigbee.writeAttribute(zigbee.ON_OFF_CLUSTER, 0x8001, DataType.ENUM8, value.toInteger())
        if (settings?.logEnable) log.trace "${device.displayName} sending LED mode : ${mode}"
        sendZigbeeCommands( cmds )    
    }
    else {
        if (mode.contains("---")) {
            if (settings?.logEnable) log.warn "${device.displayName} please select a LED mode option"
        }
        else {
            if (settings?.logEnable) log.warn "${device.displayName} LED mode ${mode} is not supported for your model:${device.getDataValue('model') } manufacturer:${device.getDataValue('manufacturer')}"
        }
    }
}

def powerOnState( mode ) {
    ArrayList<String> cmds = []
    String value = null
    if (state.model == "TS0601") {
        if (settings?.logEnable) log.warn "${device.displayName} Power On State not implemented for TS0601: ${mode}"
        // continue anyway ..
    }
    value = mode == "off" ? "00" : mode == "on" ? "01" : mode == "Last state" ? "02" : null
    if (value != null) {
        cmds += zigbee.writeAttribute(zigbee.ON_OFF_CLUSTER, 0x8002, DataType.ENUM8, value.toInteger())
        if (settings?.logEnable) log.trace "${device.displayName} sending LED mode : ${mode}"
        sendZigbeeCommands( cmds )    
    }
    else {
        if (settings?.logEnable) log.warn "${device.displayName} please select a Power On State option"
    }
}

private getIDENTIFY_CMD_IDENTIFY() { 0x00 }
private getIDENTIFY_CMD_QUERY() { 0x01 }
private getIDENTIFY_CMD_TRIGGER() { 0x40 }

def intTo16bitUnsignedHex(value) {
	def hexStr = zigbee.convertToHexString(value.toInteger(),4)
	return new String(hexStr.substring(2, 4) + hexStr.substring(0, 2))
}

def intTo8bitUnsignedHex(value) {
	return zigbee.convertToHexString(value.toInteger(), 2)
}

Integer safeToInt(val, Integer defaultVal=0) {
	return "${val}"?.isInteger() ? "${val}".toInteger() : defaultVal
}

Double safeToDouble(val, Double defaultVal=0.0) {
	return "${val}"?.isDouble() ? "${val}".toDouble() : defaultVal
}

def identify() {
	List<String> cmds = []
	cmds += "he cmd 0x${device.deviceNetworkId} 0x${device.endpointId} 0x0003 ${IDENTIFY_CMD_IDENTIFY} { 0x${intTo16bitUnsignedHex(30)} }"    // Identify for 30 seconds
	//cmds += "he cmd 0x${device.deviceNetworkId} 0x${device.endpointId} 0x0003 ${IDENTIFY_CMD_TRIGGER} { 0x${intTo8bitUnsignedHex(EFFECT_BREATHE)} 0x${intTo8bitUnsignedHex(0)} }"    // Trigger Effect
    if (txtEnable==true) log.info "${device.displayName} sending Identify to ${device.getDataValue('manufacturer')}"
    //cmds += zigbee.command(0x0003, 0x00, "0500")        // 5 seconds?
    if (state.txCounter != null) state.txCounter = state.txCounter + 1
	return cmds;
}

def configureReporting(String operation, String measurement,  String minTime, String maxTime, String delta ) {
    int intMinTime = safeToInt(minTime)
    int intMaxTime = safeToInt(maxTime)
    int intDelta = safeToInt(delta)
    
    if (settings?.logEnable) log.trace "${device.displayName} configureReporting operation=${operation}, measurement=${measurement}  minTime=${intMinTime}, maxTime=${intMaxTime}, delta=${intDelta} )"

    List<String> cmds = []      
    
    switch (measurement) {
        case ONOFF :
            if (operation == "Write") {
                cmds += zigbee.onOffConfig(intMinTime, intMaxTime)  // Configure On/Off 
            }
            else {
                cmds +=  zigbee.reportingConfiguration(0x0006, 0x0000, [:], 250)
            }
            break
        case ENERGY :
            if (operation == "Write") {
                cmds += zigbee.configureReporting(0x0702, 0x0000,  DataType.UINT48, intMinTime, intMaxTime)
            }
            else {
                cmds += zigbee.reportingConfiguration(0x0702, 0x0000, [:], 250)
            }
            break
        case POWER :
            if (operation == "Write") {
                cmds += zigbee.configureReporting(0x0B04, 0x050B,  DataType.UINT48, intMinTime, intMaxTime)    // bug fixes in ver 1.5.2 
            }
            else {
                cmds += zigbee.reportingConfiguration(0x0B04, 0x050B, [:], 250)
            }
            break
        case VOLTAGE :
            if (operation == "Write") {
                cmds += zigbee.configureReporting(0x0B04, 0x0505,  DataType.UINT48, intMinTime, intMaxTime)
            }
            else {
                cmds += zigbee.reportingConfiguration(0x0B04, 0x0505, [:], 250)
            }
            break
        case AMPERAGE :
            if (operation == "Write") {
                cmds += zigbee.configureReporting(0x0B04, 0x0508,  DataType.UINT48, intMinTime, intMaxTime)    // bug fixes in ver 1.5.2 
            }
            else {
                cmds += zigbee.reportingConfiguration(0x0B04, 0x0508, [:], 250)
            }
            break
        default :
            break
    }
    if (cmds != null) {
        sendZigbeeCommands(cmds)
    }
}
 
def test(String description)
{
    //  await endpoint.write('genBasic', {0xffde: {value: 0x13, type: 0x20}});
    //  await endpoint.read('genOnOff', [0x0000, 0x4001, 0x4002, 0x5000, 0x8000, 0x8001, 0x8002, 0x8003]);
    List<String> cmds = []
    cmds += tuyaBlackMagic()
    cmds += zigbee.writeAttribute(0x0000, 0xffde, 0x20, 0x13)
    cmds += zigbee.readAttribute(0x0006, [0x0000, 0x4001, 0x4002, 0x5000, 0x8000, 0x8001, 0x8002, 0x8003], [:], delay=200) 
    log.warn "${device.displayName} test"
    sendZigbeeCommands(cmds)
}

