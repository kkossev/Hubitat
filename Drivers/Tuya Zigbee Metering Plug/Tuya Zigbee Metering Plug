/**
 *  Tuya Zigbee Metering Plug driver for Hubitat Elevation - Power, Energy, Voltage, Amperage
 *
 *  https://community.hubitat.com/t/release-tuya-zigbee-metering-plug/86465
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License. You may obtain a copy of the License at:
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *  for the specific language governing permissions and limitations under the License.
 *
 *  The inital version was based on "SmartThings/iquix" DHT
 *
 *  ver. 1.0.0 2021-11-09 kkossev - first version: - reads Power, Energy, Voltage, Amperage once every 60 seconds
 *  ver. 1.0.1 2021-11-10 kkossev - added 'pollingInterval' preference; 'amperage' attribute name bug fix; 
 *  ver. 1.1.0 2021-11-12 kkossev - added 'PresenceSensor' capability; the automatic polling can be switched off.
 *  ver. 1.1.1 2021-11-25 kkossev - added Tuya Outlet TS011F fingerprint
 *  ver. 1.1.2 2021-12-24 kkossev - added Tuya / Neo NAS-WR01 fingerprint; fingerprint inClusters correction
 *  ver. 1.2.0 2021-12-29 kkossev - major refactoring and optimizations
 *  ver. 1.2.1 2021-12-29 kkossev - added AlwaysOn option
 *  ver. 1.3.0 2022-01-01 kkossev - added 'HIKING TOMZN DDS238-2 TS0601'
 *  ver. 1.3.1 2022-01-02 kkossev - minor bug fixes
 *  ver. 1.3.2 2022-01-12 kkossev - Tuya cluster command bug fix (HIKING TOMZN TS0601)
 *  ver. 1.4.0 2022-01-23 kkossev - debug / trace logging cleanup; initialize switch and energy automatic reporting mode; energy and switch are excluded from polling; 
 *                                  default debug loging is false, optimizations are true; switch digital/physical bug fixed; added driver version check
 *  ver. 1.4.1 2022-01-27 kkossev - added XH-002P Outlet TS011F fingerprint (no power monitoring!)
 *  ver. 1.4.2 2022-02-20 kkossev - missing Switch capability bug fix
 *  ver. 1.4.3 2022-02-15 kkossev - added 'Tuya RC-RCBO Circuit Breaker' 
 *  ver. 1.4.4 2022-05-08 kkossev - added new fingerprints; [overwrite: true] explicit option for runIn timers; settings reset bug fix; 
 *  ver. 1.4.5 2022-05-24 kkossev - added _TZ3000_5f43h46b XUELILI 16A UK; _TZ3000_r6buo8ba; _TZ3000_ksw8qtmt NOUS A1Z; _TZ3000_1h2x4akh Ajax/Zignito; _TZ3000_ky0fq4ho DIN Relay; GreenPower cluster 0xF2 fix?
 *                                  added childLock, ledMode, powerOnState configuration commands; importURL is the development branch
 *  ver. 1.4.6 2022-06-04 kkossev - added _TZ3000_gjnozsaz;  added on/off switches for power, amperage, voltage and energy reporting (logs+Events); added device display name in all logs
 *  ver. 1.5.0 2022-06-05 kkossev - Bug fix - all settings were reset back in to the defaults on hub reboot; parsing 'other Tuya oddities..'; over current alarm 0x8003; 'Freeze' LED mode (sets the backlight to the current state); 
 *  ver. 1.5.1 2022-06-12 kkossev - ChildLock bug fix
 *  ver. 1.5.2 2022-09-09 kkossev - added _TZ3000_cehuw1lw _TZ3000_typdpbpg; 
 *  ver. 1.6.0 2022-09-12 kkossev - removed 'Health Check' and 'Polling' capabilities (ping and poll buttons); automatic reporting configuration bug fixes; added individual thresholds for W,A,V;
 *                                  added autoReportingEnabled switch(default:false); added resetEnergy command; disabled attributes states are now deleted; added energyPrice (decimal) preference; added setEnergyPrice command; added energyCost calculation and event;
 *  ver. 1.6.1 2022-09-19 kkossev - added html attribute; added energyDuration; added hourlyEnergy; energy and energyCosts are reset on Initialize button; energyCost and hourlyEnergy types changed to NUMBER; fixed autoPoll bug;
 * 
 */
import groovy.json.*
import groovy.transform.Field
import hubitat.zigbee.zcl.DataType

def version() { "1.6.1" }
def timeStamp() {"2022/09/19 11:02 PM"}

@Field static final Boolean debug = false
@Field static final Boolean enerygyCostCalculation = true

metadata {
    definition (name: "Tuya Zigbee Metering Plug", namespace: "kkossev", author: "Krassimir Kossev", importUrl: "https://raw.githubusercontent.com/kkossev/Hubitat/development/Drivers/Tuya%20Zigbee%20Metering%20Plug/Tuya%20Zigbee%20Metering%20Plug", singleThreaded: true ) {
        capability "EnergyMeter"
        capability "PowerMeter"
        capability "CurrentMeter"
        capability "VoltageMeasurement"
        capability "Actuator"    
        capability "Switch"
        capability "Outlet"
        capability "Refresh"
        capability "Sensor"
        capability "PresenceSensor"
        
        attribute "energyCost", "NUMBER"
		attribute "energyDuration", "string"
        attribute "html", "string"
        attribute "hourlyEnergy", "NUMBER"
        //attribute "dailyEnergy", "string"
        
        command "initialize", [[name: "Manually initialize the plug after switching drivers.\n\r ***** Will load device default values! *****" ]]
        command "childLock", [[name:"Child Lock", type: "ENUM", description: "Select Child Lock mode", constraints: ["--- Select ---", "off", "on"]]]
        command "ledMode", [[name:"LED mode", type: "ENUM", description: "Select LED mode", constraints: ["--- Select ---", "Disabled", "Lit when On", "Lit when Off", "Freeze", "Always Green", "Red when On; Green when Off", "Green when On; Red when Off", "Always Red" ]]]
        command "powerOnState", [[name:"Power On State", type: "ENUM", description: "Select Power On State", constraints: ["--- Select ---", "off", "on", "Last state"]]]
        command "setEnergyPrice", [[name:"setEnergyPrice", type: "STRING", description: "Set the energy cost (rate) for 1 KWh. The value is shown in the Preferences section", constraints: ["STRING"], defaultValue : "0.12"]]
        command "resetEnergy", [[name: "Reset the acumulated Energy value" ]]
        if (debug == true) {
            command "test", [[name: "test", type: "STRING", description: "test", defaultValue : ""]]
            command "formatAttrib"
        }
        
        if (debug == true) {
            command "activeEndpoints"
            command "identify", [[name: "Identify the plug for 30 seconds"]]    // works for my OSRAM plug only? :( 
            command "configureReporting", [ 
                [name: "operation*",   type: "ENUM", constraints: ["--- Select ---", "Read", "Write"]],
                [name: "measurement*", type: "ENUM", constraints: ["--- Select ---", ONOFF, ENERGY, POWER, VOLTAGE, AMPERAGE], description: "Select measurement to configure"],
                [name: "Minimum Reporting Interval (seconds)", type: "STRING", defaultValue : "30", description: "Select Minimum reporting time (in seconds)"],
                [name: "Maximum Reporting Interval (seconds)", type: "STRING", defaultValue : "900", description: "Select Maximim reporting time (in seconds)"],
                [name: "Minimum measurement change",           type: "STRING", defaultValue : "1", description: "Select Minimum measurement change to be reported"]
            ]
            //command "test", [[name: "test", type: "STRING", description: "test", defaultValue : ""]]
        }

        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0004,0005,0006,0702,0B04", outClusters:"0019,000A", manufacturer:"_TZ3000_vtscrpmw", model:"TS0121",  deviceJoinName: "Tuya Outlet" //Tuya Smart Plug
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0004,0005,0006,0702,0B04", outClusters:"0019,000A", manufacturer:"_TZ3000_3ooaz3ng", model:"TS0121",  deviceJoinName: "Tuya Outlet" //Tuya Smart Plug        
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0004,0005,0006,0702 0B04", outClusters:"0019,000A", manufacturer:"_TZ3000_rdtixbnu", model:"TS0121",  deviceJoinName: "Tuya Outlet" //Tuya Smart Plug    
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0004,0005,0006,0702,0B04", outClusters:"0019,000A", model:"TS0121", manufacturer:"_TZ3000_g5xawfcq",  deviceJoinName: "Blitzwolf BW-SHP13" //Blitzwolf BW-SHP13  
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0702,0B04,E000,E001", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_cphmq0q7", deviceJoinName: "Tuya Outlet TS011F" //TS011F   
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0702,0B04,E000,E001", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_ps3dmato",  deviceJoinName: "Lellki WK35 Plug Wall Socket"   
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0702,0B04,E000,E001", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_1h2x4akh",  deviceJoinName: "Ajax/Zignito Plug Wall Socket"   
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,0702,0B04,E000,E001,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_w0qqde0g", deviceJoinName: "Neo NAS-WR01 Outlet TS011F"  
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,E000,E001,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_v1pdxuqq", deviceJoinName: "XH-002P Outlet TS011F No Power Monitoring"  // - no power monitoring !
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,E000,E001,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_hyfvrar3", deviceJoinName: "TS011F No Power Monitoring"  // - no power monitoring !
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,E000,E001,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_cymsnfvf", deviceJoinName: "TS011F No Power Monitoring"  // - no power monitoring !
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,E000,E001,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_bfn1w0mm", deviceJoinName: "TS011F No Power Monitoring"  // - no power monitoring !
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,E000,E001,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_gjnozsaz", deviceJoinName: "NEO ZigBee On Off Power Metering Plug"  // https://ultrasmart.pl/en_GB/p/NEO-ZigBee-On-Off-Power-Metering-Plug/81
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0004,0005,EF00", outClusters:"0019,000A", model:"TS0601", manufacturer:"_TZE200_byzdayie", deviceJoinName: "HIKING TOMZN DDS238-2 TS0601_din"  
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0004,0005,EF00", outClusters:"0019,000A", model:"TS0601", manufacturer:"_TZE200_fsb6zw01", deviceJoinName: "Tuya Energy Device"  
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0004,0005,EF00", outClusters:"0019,000A", model:"TS0601", manufacturer:"_TZE200_hkdl5fmv", deviceJoinName: "Tuya RC-RCBO Circuit Breaker"
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,0702,0B04,E001,E000,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_ky0fq4ho", deviceJoinName: "ATMS1602Z DIN Relay"
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,0702,0B04,E001,E000,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_ksw8qtmt", deviceJoinName: "Smart ZigBee Socket NOUS A1Z" //https://nous.technology/product/a1z-1.html
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,0702,0B04,E001,E000,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_5f43h46b", deviceJoinName: " XUELILI 16A UK Standards Smart Outlet"
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,0702,0B04,E001,E000,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_cehuw1lw", deviceJoinName: "Haozee Smart Zigbee Plug 16A/20A EU Outlet" // https://www.aliexpress.com/item/1005002344798281.html  //
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0003,0004,0005,0006,0702,0B04,E001,E000,0000", outClusters:"0019,000A", model:"TS011F", manufacturer:"_TZ3000_typdpbpg", deviceJoinName: "Tuya Smart Zigbee Plug AU 16A" // https://www.aliexpress.com/item/1005004505868292.html
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0003,0004,0005,0006,0B04,0702", outClusters:"0003,0019,0006,E001", model:"TS011F", manufacturer:"_TZ3000_r6buo8ba", deviceJoinName: "US Power Outlet"  // https://www.aliexpress.com/item/1005004128965720.htm
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0006,0003,0004,0005,E001,0B04,0702", outClusters:"", model:"TS011F", manufacturer:"_TZ3000_okaz9tjs", deviceJoinName: "Lonsonho US Plug 20A Power Monitor"  // 
    }
    
    
    
    preferences {
        input (name: "logEnable", type: "bool", title: "<b>Debug logging</b>", description: "<i>Debug information, useful for troubleshooting. Recommended setting is <b>off</b></i>", defaultValue: false)
        input (name: "txtEnable", type: "bool", title: "<b>Description text logging</b>", description: "<i>Display measured values in HE log page. Recommended setting is <b>on</b></i>", defaultValue: true)
        input (name: "autoReportingEnabled", type: "bool", title: "<b>Automatic reporting configuration</b>", description: "<i>Enable outlet automatic reporting, if supported by the device. Default setting is <b>off</b></i>", defaultValue: false)
        input (name: "autoPollingEnabled", type: "bool", title: "<b>Automatic polling</b>", description: "<i>Enable outlet automatic polling for power, voltage, amperage, energy and switch state. Recommended setting is <b>on</b></i>", defaultValue: true)
        if (autoPollingEnabled?.value == true) {
            input (name: "pollingInterval", type: "number", title: "<b>Polling interval</b>, seconds", description: "<i>The time period when the smart plug will be polled for power, voltage and amperage readings. Recommended setting is <b>60 seconds</b></i>", 
                   range: "10..3600", defaultValue: defaultPollingInterval)
        }
        input (name: "alwaysOn", type: "bool", title: "<b>Always On</b>", description: "<i>Disable switching OFF for plugs that must be always On</i>", defaultValue: false)
        input (name: "optimizations", type: "bool", title: "<b>Optimize polling and logging</b>", description: "<i>Additional optimizations to reduce the hub load</i>. Recommended value is <b>on</b>", defaultValue: true)
        if (optimizations?.value == true || autoReportingEnabled?.value == true) {
            input (name: "energyMinReportingTime", type: "number", title: "<b>Shortest reporting interval</b>, seconds", description: "<i>The minimum allowed time between two automatic reports. Recommended setting is <b>30 seconds</b></i>", 
                range: "10..86399", defaultValue: 30)
            input (name: "energyMaxReportingTime", type: "number", title: "<b>Longest reporting interval</b>, seconds", description: "<i>The maximum time without automatic reports. Recommended setting is <b>900 seconds</b></i>", 
                range: "120..86400", defaultValue: 900)
            input (name: "reportEnergy", type:    "bool", title: "<b>Energy Reporting Off or On</b>",  description:  "<i>(Disable reporting when not desired)</i>", defaultValue: true)
            if (reportEnergy?.value == true) {
                input (name: "energyPrice", type: "decimal", title: "<b>Energy price for 1 KWh</b>, \$", description: "<i>Energy price for KWh used in the Energy Cost calculations.</i>", /*range: "0.01..99.99",*/ defaultValue: 0.12)
                input (name: "energyTreshold", type: "number", title: "<b>Energy minimum change to be reported</b>, Wh", description: "<i>The minimum Energy change that will trigger reporting.</i>", range: "1..10000", defaultValue: 1)
            }
            input (name: "reportPower", type:    "bool", title: "<b>Power Reporting Off or On</b>",  description:   "<i>(Disable reporting (Off) when not desired)</i>", defaultValue: true)
            if (reportPower?.value == true) {
                input (name: "powerTreshold", type: "number", title: "<b>Power minimum change to be reported</b>, W", description: "<i>The minimum Power change that will trigger reporting.</i>", range: "1..10000", defaultValue: 1)
            }
            input (name: "reportAmperage", type: "bool", title: "<b>Amperage Reporting Off or On</b>", description: "<i>(Disable reporting (Off) when not desired)</i>", defaultValue: true)
            if (reportAmperage?.value == true) {
                input (name: "amperageTreshold", type: "number", title: "<b>Amperage minimum change to be reported</b>, mA", description: "<i>The minimum Amperage change that will trigger reporting.</i>", range: "1..10000", defaultValue: 25)
            }
            input (name: "reportVoltage", type:  "bool", title: "<b>Voltage Reporting Off or On</b>",  description: "<i>(Disable reporting (Off) when not desired)</i>", defaultValue: true)
            if (reportVoltage?.value == true) {
                input (name: "voltageTreshold", type: "number", title: "<b>Voltage minimum change to be reported</b>, V", description: "<i>The minimum Voltage change that will trigger reporting.</i>", range: "1..10000", defaultValue: 1)
            }
            // energyTreshold powerTreshold amperageTreshold voltageTreshold        reportEnergy reportPower reportAmperage reportVoltage
        } 
        input (name: "attribEnable", type:  "bool", title: "<b>Enable HTML Attribute Creation?</b>",  description: "<i>html attribute for use in HE dashboards</i>", defaultValue: false)
    }
}

// Constants
@Field static final Integer powerDiv = 1
@Field static final Integer energyDiv = 100
@Field static final Integer currentDiv = 1000
@Field static final Integer presenceCountTreshold = 3
@Field static final Integer defaultPollingInterval = 60
@Field static final Integer debouncingTimer = 300
@Field static final Integer digitalTimer = 1000
@Field static final Integer refreshTimer = 3000
@Field static final String UNKNOWN = "UNKNOWN"
@Field static final String ONOFF = "Switch"
@Field static final String POWER = "Power"
@Field static final String ENERGY = "Energy"
@Field static final String VOLTAGE = "Voltage"
@Field static final String AMPERAGE = "Amperage"

def isTS0121() {state.model == "TS0121"}
def isCircuitBreaker() {device.getDataValue("manufacturer") in ["_TZ3000_ky0fq4ho"]}

def parse(String description) {
    if (logEnable == true) log.debug "${device.displayName} parse: description is $description"
    checkDriverVersion()
    if (state.rxCounter != null) state.rxCounter = state.rxCounter + 1
    setPresent()
    if (isTuyaE00xCluster(description) == true || otherTuyaOddities(description) == true) {
        return null
    }
    def event = [:]
    try {
        event = zigbee.getEvent(description)
    }
    catch ( e ) {
        log.warn "${device.displayName} parse: exception caught while parsing description:  ${description}"
        //return null
    }
    if (event) {
        if (logEnable==true) log.debug "${device.displayName} Event enter: $event"
        switch (event.name) {
            case "switch" :
                switchEvent( event.value )
                break
            // for smart plugs that can be configured to fire atimaticallty power and energy events ..
            case "power" :    
                powerEvent(event.value/powerDiv)
                break
            case "energy" :
                energyEvent(event.value/energyDiv)
                break
            default :
                if (txtEnable) {log.warn "${device.displayName} received <b>unhandled event</b> ${event.name} = $event.value"} 
                break
        }
        return null //event
    }
    else {
        //List result = []
        def descMap = [:]
        try {
            descMap = zigbee.parseDescriptionAsMap(description)
        }
        catch ( e ) {
            log.warn "${device.displayName} parse: exception caught while parsing descMap:  ${descMap}"
            return null
        }
        //if (logEnable) {log.debug "${device.displayName} parse: Desc Map: $descMap"}
        if (descMap.attrId != null ) {
            // attribute report received
            List attrData = [[cluster: descMap.cluster ,attrId: descMap.attrId, value: descMap.value, status: descMap.status]]
            descMap.additionalAttrs.each {
                attrData << [cluster: descMap.cluster, attrId: it.attrId, value: it.value, status: it.status]
            }
            attrData.each {
                def map = [:]
                if (it.status == "86") {
                    disableUnsupportedAttribute(descMap.cluster, it.attrId)
                }
                else if (it.value && it.cluster == "0B04" && it.attrId == "050B") {
                        powerEvent(zigbee.convertHexToInt(it.value)/powerDiv)
                        if (state.lastPower != zigbee.convertHexToInt(it.value)/powerDiv ) {
                            if (logEnable) {log.trace "${device.displayName} power changed from <b>${state.lastPower}</b> to <b>${zigbee.convertHexToInt(it.value)/powerDiv}</b>"}
                            state.lastPower = zigbee.convertHexToInt(it.value)/powerDiv
                        }
                }
                else if (it.value && it.cluster == "0B04" && it.attrId == "0505") {
                    voltageEvent(zigbee.convertHexToInt(it.value)/powerDiv)
                }
                else if (it.value && it.cluster == "0B04" && it.attrId == "0508") {
                    amperageEvent(zigbee.convertHexToInt(it.value)/currentDiv)
                }
                else if (it.value && it.cluster == "0B04" && it.attrId == "0510") {    //Power Factor Attribute ID: 0x0510
                    if (txtEnable) {log.info "${device.displayName} power Factor reported: ${it.value}" }    // not tested
                }
                else if (it.value && it.cluster == "0702" && it.attrId == "0000") {
                    energyEvent(zigbee.convertHexToInt(it.value)/energyDiv)
                }
                /*
                else if ( it.cluster == "0000" && it.attrId in ["0001", "FFE0", "FFE1", "FFE2", "FFE4", "FFFE", "FFDF"]) {
                    if (logEnable) {log.debug "${device.displayName} Tuya specific attribute ${it.attrId}  cluster ${it.cluster } reported: value=${it.value}" }    // not tested
                }
                else if ( it.cluster == "0006" && it.attrId in ["8000", "8001", "8002"]) {
                    parseOnOffAttributes(it)
                }
                */
                else {
                    if (logEnable==true) log.warn "${device.displayName} Unprocessed attribute report: cluster=${it.cluster} attrId=${it.attrId} value=${it.value} status=${it.status} data=${descMap.data}"
                }
                //if (logEnable) {log.debug "${device.displayName} Parse returned $map"}
            } // for each attribute
        } // if attribute report
        else if (descMap.profileId == "0000") { //zdo
            parseZDOcommand(descMap)
        } 
        else if (descMap.clusterId != null && descMap.profileId == "0104") { // ZHA global command
            parseZHAcommand(descMap)
        } 
        else {
            if (logEnable==true)  log.warn "${device.displayName} Unprocesed unknown command: cluster=${descMap.clusterId} command=${descMap.command} attrId=${descMap.attrId} value=${descMap.value} data=${descMap.data}"
        }
        return null //result
    } // descMap
}


def parseOnOffAttributes( it ) {
    if (logEnable) {log.debug "${device.displayName} OnOff attribute ${it.attrId} cluster ${it.cluster } reported: value=${it.value}" }
    def mode
    def attrName
    if (it.value == null) {
        //if (logEnable) log.trace "${device.displayName} OnOff attribute ${it.attrId} cluster ${it.cluster } skipping NULL value status=${it.status}"
        return
    }
    def value = it.value as int
    switch (it.attrId) {
        case "8000" :    // command "childLock", [[name:"Child Lock", type: "ENUM", description: "Select Child Lock mode", constraints: ["off", "on"]]]
            attrName = "Child Lock"
            mode = value == 0 ? "off" : "on"
            break
        case "8001" :    // command "ledMode", [[name:"LED mode", type: "ENUM", description: "Select LED mode", constraints: ["Disabled", "Lit when On", "Lit when Off", "Always Green", "Red when On; Green when Off", "Green when On; Red when Off", "Always Red" ]]]
            attrName = "LED mode"
            if (isCircuitBreaker()) {
                mode = value == 0 ? "Always Green" : value == 1 ? "Red when On; Green when Off" : value == 2 ? "Green when On; Red when Off" : value == 3 ? "Always Red" : null
            }
            else {
                mode = value == 0 ? "Disabled"  : value == 1 ? "Lit when On" : value == 2 ? "Lit when Off" : value == 3 ? "Freeze": null
            }
            break
        case "8002" :    // command "powerOnState", [[name:"Power On State", type: "ENUM", description: "Select Power On State", constraints: ["off","on", "Last state"]]]
            attrName = "Power On State"
            mode = value == 0 ? "off" : value == 1 ? "on" : value == 2 ?  "Last state" : null
            break
        case "8003" : //  Over current alarm
            attrName = "Over current alarm"
            mode = value == 0 ? "Over Current OK" : value == 1 ? "Over Current Alarm" : null
            break
        default :
            if (logEnable) log.warn "${device.displayName} Unprocessed Tuya OnOff attribute ${it.attrId} cluster ${it.cluster } reported: value=${it.value}"
            return
    }
    if (txtEnable) log.info "${device.displayName} ${attrName} is ${mode}"
}

def switchEvent( value ) {
    def map = [:] 
    boolean bWasChange = false
    if (state.switchDebouncing==true && value==state.lastSwitchState) {    // some plugs send only catchall events, some only readattr reports, but some will fire both...
        if (logEnable) {log.debug "${device.displayName} Ignored duplicated switch event for model ${state.model}"} 
        runInMillis( debouncingTimer, switchDebouncingClear, [overwrite: true])
        return null
    }
    map.type = state.isDigital == true ? "digital" : "physical"
    if (state.lastSwitchState != value ) {
        bWasChange = true
        if (logEnable) {log.debug "${device.displayName} Switch state changed from <b>${state.lastSwitchState}</b> to <b>${value}</b>"}
        runInMillis(6000, pollPower, [overwrite: true])    // version 1.6.0 - poll the power attributes after switching on/off even if polling is disabled!
        /*  commented out 9/19/2022
        if (autoPollingEnabled == true) {
            runIn( pollingInterval, autoPoll, [overwrite: true]) // restart polling interval timer
        }
        */
        state.switchDebouncing = true
        state.lastSwitchState = value
        runInMillis( debouncingTimer, switchDebouncingClear, [overwrite: true])
    }
    map.name = "switch"
    map.value = value
    if (state.isRefreshRequest == true || state.model == "TS0601") {
        map.descriptionText = "${device.displayName} switch is ${value}"
    }
    else {
        map.descriptionText = "${device.displayName} was turned ${value} [${map.type}]"
    }
    if (optimizations==false || bWasChange==true ) 
    {
        if (txtEnable) {log.info "${device.displayName} ${map.descriptionText}"}
        sendEvent(map)
        runIn( 1, formatAttrib, [overwrite: true])    
    }
    clearIsDigital()
}

def voltageEvent( voltage, isDigital=false ) {
    def map = [:] 
    map.name = "voltage"
    map.value = voltage
    map.unit = "V"
    map.type = isDigital == true ? "digital" : "physical"
    map.descriptionText = "${map.name} is ${map.value} ${map.unit}"
    if (state.lastVoltage != voltage || optimizations == false || state.isRefreshRequest == true ) {
        if (Math.abs((voltage as int) - (state.lastVoltage as int)) >= (voltageTreshold as int)) {
            state.lastVoltage = voltage
            if (settings?.reportVoltage == true) {
                if (txtEnable) {log.info "${device.displayName} ${map.descriptionText}"}
                sendEvent(map)
                runIn( 1, formatAttrib, [overwrite: true])    
            }
        }
        else {
            if (logEnable) {log.debug "${device.displayName} IGNORED ${map.name} ${map.value} ${map.unit} (change from ${state.lastVoltage} is less than ${voltageTreshold} V)"}
        }
    }
}

def powerEvent( power, isDigital=false ) {
    def map = [:] 
    map.name = "power"
    map.value = power
    map.unit = "W"
    map.type = isDigital == true ? "digital" : "physical"
    map.descriptionText = "${map.name} is ${map.value} ${map.unit}"
    if (state.lastPower != power || optimizations == false || state.isRefreshRequest == true ) {
        if (Math.abs((power as int) - (state.lastPower as int)) >= (powerTreshold as int)) {
            state.lastPower = power    
            if (settings?.reportPower == true) {
                if (txtEnable) {log.info "${device.displayName} ${map.descriptionText}"}
                sendEvent(map)
                runIn( 1, formatAttrib, [overwrite: true])    
            }
        }
        else {
            if (logEnable) {log.debug "${device.displayName} IGNORED ${map.name} ${map.value} ${map.unit} (change from ${state.lastPower} is less than ${powerTreshold} W)"}
        }
        
    }
}

def amperageEvent( amperage, isDigital=false ) {
    def map = [:] 
    map.name = "amperage"
    map.value = amperage
    map.unit = "A"
    map.type = isDigital == true ? "digital" : "physical"
    map.descriptionText = "${map.name} is ${map.value} ${map.unit}"
    if (state.lastAmperage != amperage || optimizations == false || state.isRefreshRequest == true  ) {
        if (Math.abs((amperage*1000 as int) - (state.lastAmperage*1000 as int)) >= (amperageTreshold as int)) {
            state.lastAmperage = amperage    
            if (settings?.reportAmperage == true) {
                if (txtEnable) {log.info "${device.displayName} ${map.descriptionText}"}
                sendEvent(map)
                runIn( 1, formatAttrib, [overwrite: true])    
            }
        }
        else {
            if (logEnable) {log.debug "${device.displayName} IGNORED ${map.name} ${map.value} ${map.unit} (change from ${state.lastAmperage} is less than ${amperageTreshold} mA)"}
        }
    }
}

def energyEvent( energy_total, isDigital=false ) {
    def map = [:] 
    def energy = energy_total
    energy = (energy_total - safeToDouble(state.lastResetEnergy)).round(3)
    if (energy < 0.0) {
        log.warn "negative energy ${energy}, correcting it to 0!"
        energy = 0.0
    }
    if (logEnable) {log.trace "energy_total=${energy_total}, state.lastResetEnergy=${safeToDouble(state.lastResetEnergy)}"}
    map.name = "energy"
    map.value = energy
    map.unit = "kWh"
    map.type = isDigital == true ? "digital" : "physical"
    map.descriptionText = "${map.name} is ${map.value} ${map.unit}"
    if (state.lastEnergy != energy || optimizations==false || state.isRefreshRequest == true ) {
        if (reportEnergy == true) {        // energy is reported once per hour without being polled!
            def newTotalCost = updateEnergyCost(state.lastEnergy, energy )
            energyCostEvent(newTotalCost, isDigital)
            state.lastEnergy = energy
            sendEvent(map)
            def duration = calculateEnergyDuration()
            energyDurationtEvent( duration )
            runIn( 1, formatAttrib, [overwrite: true])    
            if (txtEnable) {log.info "${device.displayName} ${map.descriptionText}, energyCost=\$${newTotalCost.round(2)} (rate=\$${energyPrice.round(5)}), duration=${duration}"}
        }
        else {
            if (logEnable) {log.debug "${device.displayName} IGNORED ${map.name} ${map.value} ${map.unit} (energy reporting is disabled!"}
        }
    }
    else {
        if (logEnable) {log.debug "${device.displayName} ${map.name} is ${map.value} ${map.unit} (no change)"}
    }
}

def scheduleHourlyAndDailyEnergy() {
// http://www.quartz-scheduler.org/documentation/     
// https://freeformatter.com/cron-expression-generator-quartz.html 
/*    
Seconds	Minutes	Hours	Day Of Month	Month	Day Of Week	Year
0    	0	    *	    ?	            *	    *	        *            // 0 0 * ? * * *  -> every hour
0	    0	    0	    ?	            *	    *	        *            // 0 0 0 ? * * *  -> every day
// 0 * 0 ? * * * -> every minute
*/

    /*
    try
    {
        unschedule()
    }
    catch (e)
    {
        if (txtEnable==true) log.erroro "${device.displayName} exception caught on unschedule()..."
    }
    */
   // "${Math.round(Math.random() * 60)} ${Calendar.instance.get(Calendar.MINUTE)} * ? * * *"
    //schedule("* * * ? * *", hourlyEnergyEvent)     // test every second
    //schedule("0 * * ? * *", hourlyEnergyEvent)    // test every 1 minute
    schedule("0 0 * ? * * * ", hourlyEnergyEvent)


}

def calculateHourlyEnergy() {
    def energy = safeToDouble(device.currentValue("energy", true)) - safeToDouble(state.lastHourlyEnergy)
    if (energy < 0.0) {
        log.warn "calculateHourlyEnergy: negative energy ${energy}, correcting it to 0!"
        if (logEnable) {log.trace "device.currentValue=${safeToDouble(device.currentValue("energy", true))}, state.lastHourlyEnergy=${safeToDouble(state.lastHourlyEnergy)}"}
        energy = 0.0
    }
    return energy as double
}

def hourlyEnergyEvent( hourlyEnergy=null, isDigital=false ) {
    //log.trace "hourlyEnergyEvent hourlyEnergy=${hourlyEnergy}"
    def map = [:] 
    double energy
    map.name = "hourlyEnergy"
    if (hourlyEnergy != null) {
        map.value = hourlyEnergy    // as set 
    }
    else {    // CRON
        energy = calculateHourlyEnergy().round(3)
        map.value = energy
        //log.trace "energy=${energy}"
        state.lastHourlyEnergy = device.currentValue("energy", true)
    }
    map.unit = "kWh"
    map.type = isDigital == true ? "digital" : "physical"
    map.isStateChange = true
    map.descriptionText = "${map.name} is ${map.value} ${map.unit}"
    if (txtEnable) {log.info "${device.displayName} ${map.descriptionText}"}     // sent in the energy event
    sendEvent(map)
}


def updateEnergyCost( previousE, newE) {
    def previousEnergy = safeToDouble(previousE)
    def newEnergy = safeToDouble(newE)
    //log.trace "updateEnergyCost: previousEnergy=${previousEnergy} newEnergy=${newEnergy}"
    def deltaPrice = (newEnergy - previousEnergy) * safeToDouble( energyPrice )
    if (deltaPrice < 0.0) {
        deltaPrice = 0.0
    }
    //log.trace "updateEnergyCost: deltaPrice = ${deltaPrice} oldPrice=${state.lastEnergyCost?:0}"
    def newTotalCost = (state.lastEnergyCost?:0 as double) + (deltaPrice as double)
    state.lastEnergyCost = newTotalCost
    //log.trace "updateEnergyCost: newTotalCost = ${newTotalCost}"
    return newTotalCost
}

def energyCostEvent( cost, isDigital=false ) {
    def map = [:] 
    map.name = "energyCost"
    map.value = safeToDouble(cost).round(2)
    map.unit = "\$"
    map.type = isDigital == true ? "digital" : "physical"
    map.descriptionText = "${map.name} is ${map.unit}${map.value} "
    if (true) {
        if (true) {
            if (settings?.reportEnergy == true) {
                //if (txtEnable) {log.info "${device.displayName} ${map.descriptionText}"} // already logged in Energy event
                sendEvent(map)
                runIn( 1, formatAttrib, [overwrite: true])    
            }
        }
        else {
            if (logEnable) {log.debug "${device.displayName} IGNORED ${map.name} ${map.value} ${map.unit}"}
        }
    }
    
}

def energyDurationtEvent( duration, isDigital=false ) {
    def map = [:] 
    map.name = "energyDuration"
    map.value = duration
    map.unit = ""
    map.type = isDigital == true ? "digital" : "physical"
    map.descriptionText = "${map.name} is ${map.unit}${map.value} "
    //if (txtEnable) {log.info "${device.displayName} ${map.descriptionText}"}     // sent in the energy event
    sendEvent(map)
}


def parseZDOcommand( Map descMap ) {
    switch (descMap.clusterId) {
        case "0006" :
            if (logEnable) log.info "${device.displayName} Received match descriptor request, data=${descMap.data} (Sequence Number:${descMap.data[0]}, Input cluster count:${descMap.data[5]} Input cluster: 0x${descMap.data[7]+descMap.data[6]})"
            break
        case "0013" : // device announcement
            if (logEnable) log.info "${device.displayName} Received device announcement, data=${descMap.data} (Sequence Number:${descMap.data[0]}, Device network ID: ${descMap.data[2]+descMap.data[1]}, Capability Information: ${descMap.data[11]})"
            break
        case "8004" : // simple descriptor response
            if (logEnable) log.info "${device.displayName} Received simple descriptor response, data=${descMap.data} (Sequence Number:${descMap.data[0]}, status:${descMap.data[1]}, lenght:${hubitat.helper.HexUtils.hexStringToInt(descMap.data[4])}"
            parseSimpleDescriptorResponse( descMap )
            break
        case "8005" : // endpoint response
            if (logEnable) log.info "${device.displayName} Received endpoint response: cluster: ${descMap.clusterId} (endpoint response) endpointCount = ${ descMap.data[4]}  endpointList = ${descMap.data[5]}"
            break
        case "8021" : // bind response
            if (logEnable) log.info "${device.displayName} Received bind response, data=${descMap.data} (Sequence Number:${descMap.data[0]}, Status: ${descMap.data[1]=="00" ? 'Success' : '<b>Failure</b>'})"
            break
        case "8038" : // Management Network Update Notify
            if (logEnable) log.info "${device.displayName} Received Management Network Update Notify, data=${descMap.data}"
            break
        default :
            if (logEnable) log.warn "${device.displayName} Unprocessed ZDO command: cluster=${descMap.clusterId} command=${descMap.command} attrId=${descMap.attrId} value=${descMap.value} data=${descMap.data}"
            break    // 2022/09/16
    }
}

def activeEndpoints() {
    List<String> cmds = []
    
    cmds += ["he raw ${device.deviceNetworkId} 0 0 0x0005 {00 ${zigbee.swapOctets(device.deviceNetworkId)}} {0x0000}"] //get all the endpoints...
    String endpointIdTemp = endpointId == null ? "01" : endpointId
    cmds += ["he raw ${device.deviceNetworkId} 0 0 0x0004 {00 ${zigbee.swapOctets(device.deviceNetworkId)} $endpointIdTemp} {0x0000}"]
    
    sendZigbeeCommands(cmds) 
}

def parseSimpleDescriptorResponse(Map descMap) {
    //log.info "${device.displayName} Received simple descriptor response, data=${descMap.data} (Sequence Number:${descMap.data[0]}, status:${descMap.data[1]}, lenght:${hubitat.helper.HexUtils.hexStringToInt(descMap.data[4])}"
    if (logEnable==true) log.info "${device.displayName} Endpoint: ${descMap.data[5]} Application Device:${descMap.data[9]}${descMap.data[8]}, Application Version:${descMap.data[10]}"
    def inputClusterCount = hubitat.helper.HexUtils.hexStringToInt(descMap.data[11])
    def inputClusterList = ""
    for (int i in 1..inputClusterCount) {
        inputClusterList += descMap.data[13+(i-1)*2] + descMap.data[12+(i-1)*2] + ","
    }
    inputClusterList = inputClusterList.substring(0, inputClusterList.length() - 1)
    if (logEnable==true) log.info "${device.displayName} Input Cluster Count: ${inputClusterCount} Input Cluster List : ${inputClusterList}"
    if (getDataValue("inClusters") != inputClusterList)  {
        if (logEnable==true) log.warn "${device.displayName} inClusters=${getDataValue('inClusters')} differs from inputClusterList:${inputClusterList} - will be updated!"
        updateDataValue("inClusters", inputClusterList)
    }
    
    def outputClusterCount = hubitat.helper.HexUtils.hexStringToInt(descMap.data[12+inputClusterCount*2])
    def outputClusterList = ""
    for (int i in 1..outputClusterCount) {
        outputClusterList += descMap.data[14+inputClusterCount*2+(i-1)*2] + descMap.data[13+inputClusterCount*2+(i-1)*2] + ","
    }
    outputClusterList = outputClusterList.substring(0, outputClusterList.length() - 1)
    if (logEnable==true) log.info "${device.displayName} Output Cluster Count: ${outputClusterCount} Output Cluster List : ${outputClusterList}"
    if (getDataValue("outClusters") != outputClusterList)  {
        if (logEnable==true) log.warn "${device.displayName} outClusters=${getDataValue('outClusters')} differs from outputClusterList:${outputClusterList} -  will be updated!"
        updateDataValue("outClusters", outputClusterList)
    }
}

def disableUnsupportedAttribute(String clusterId, String attrId) {
    switch (clusterId) {
        case "0006" :    // Switch
            if (logEnable==true) log.warn "${device.displayName} Switch polling is not supported -> Switch polling will be disabled."
            state.switchPollingSupported = false
            break
        case "0B04" : // Electrical Measurement attribute is not supported!
            switch (attrId) {
                case "0505" :    // Voltage
                    if (logEnable==true) log.warn "${device.displayName} Voltage polling is not supported -> Voltage polling will be disabled."
                    state.voltagePollingSupported = false
                    break
                case "0508" :     // Current
                    if (logEnable==true) log.warn "${device.displayName} Current polling is not supported -> Current polling will be disabled."
                    state.currentPollingSupported = false
                    break
                case "050B" :     // Power
                    if (logEnable==true) log.warn "${device.displayName} Power polling is not supported! -> Power polling will be disabled."
                    state.powerPollingSupported = false
                    break
                default :
                    if (logEnable==true) log.warn "${device.displayName} Read attribute response: unsupported Attributte ${attrId} for Electrical Measurement cluster ${clusterId}"
                    break
            }
            break
        case "0702" : // Simple Metering Cluster
            if (logEnable==true) log.warn "${device.displayName} Energy measurement is not supported! -> Energy polling will be disabled."
            state.energyPollingSupported = false
            break
        default :
            if (logEnable==true) log.warn "${device.displayName} Read attribute response: unsupported Attributte ${attrId} cluster ${clusterId}"
            break
    }
}

def parseZHAcommand( Map descMap) {
    switch (descMap.command) {
        case "01" : //read attribute response. If there was no error, the successful attribute reading would be processed in the main parse() method.
            def status = descMap.data[2]
            def attrId = descMap.data[1] + descMap.data[0] 
            if (status == "86") {
                disableUnsupportedAttribute(descMap.clusterId, attrId)
                if (logEnable==true) log.trace "${device.displayName} descMap = ${descMap}"
            }
            else {
                switch (descMap.clusterId) {
                    case "EF00" :
                        //if (logEnable==true) log.warn "${device.displayName} Tuya cluster read attribute response: code ${status} Attributte ${attrId} cluster ${descMap.clusterId} data ${descMap.data}"
                        def attribute = getAttribute(descMap.data)
                        def value = getAttributeValue(descMap.data)
                        //if (logEnable==true) log.trace "${device.displayName} attribute=${attribute} value=${value}"
                        def map = [:]
                        def cmd = descMap.data[2]
                        switch (cmd) { // code : descMap.data[2]    ; attrId = descMap.data[1] + descMap.data[0] 
                            case "01" : // switch
                                switchEvent(value==0 ? "off" : "on")
                                break
                            case "11" : // Energy
                                energyEvent(value/100)
                                break
                            case "12" : // Amperage
                                amperageEvent(value/1000)
                                break
                            case "13" : // Power
                                powerEvent(value/10)
                                break
                            case "14" : // Voltage
                                voltageEvent(value/10)
                                break
                            case "1D" : // hochChildLock: 29
                                if (txtEnable==true) log.info "${device.displayName} Child Lock = ${value==0 ? 'off' : 'on'}"
                                break
                            case "65" : // Voltage HOCH
                                voltageEvent((zigbee.convertHexToInt(descMap.data[7]) | zigbee.convertHexToInt(descMap.data[6]) << 8) / 10)
                                break
                            case "66" : // Amperage HOCH
                                amperageEvent((zigbee.convertHexToInt(descMap.data[8]) | zigbee.convertHexToInt(descMap.data[7]) << 8) / 1000)
                                break
                            case "67" : // hochActivePower: 103
                                powerEvent((zigbee.convertHexToInt(descMap.data[8]) | zigbee.convertHexToInt(descMap.data[7]) << 8) / 10)
                                break
                            case "69" : // hochTemperature: 105
                                log.info "${device.displayName} temperature is ${(zigbee.convertHexToInt(descMap.data[9]))}"
                                break
                            case "09" : // hochCountdownTimer: 9
                            case "1A" : // hochFaultCode: 26
                            case "1B" : // hochRelayStatus: 27 (power recovery behaviour)
                            case "68" : // hochLeakageCurrent: 104
                            case "6A" : // hochRemainingEnergy: 106
                            case "6B" : // "recharge energy" : 107
                            case "6C" : // hochCostParameters: 108 (non-zero)
                            case "6D" : // hochLeakageParameters: 109 (non-zero)
                            case "6E" : // hochVoltageThreshold: 110 (non-zero)
                            case "6F" : // hochCurrentThreshold: 111 (non-zero)
                            case "70" : // hochTemperatureThreshold: 112 (non-zero)
                            case "71" : // hochTotalActivePower: 113
                            case "72" : // hochEquipmentNumberType: 114
                            case "73" : //: "clear energy",115
                            case "74" : // hochLocking: 116  (test button pressed)
                            case "75" : // hochTotalReverseActivePower: 117
                            case "76" : // hochHistoricalVoltage: 118
                            case "77" : // hochHistoricalCurrent: 119
                                log.trace "${device.displayName} cmd = ${cmd}  value = ${(zigbee.convertHexToInt(descMap.data[7]) | zigbee.convertHexToInt(descMap.data[6]) << 8)}"
                                break
                            default :
                                if (logEnable==true) log.warn "${device.displayName} Tuya unknown attribute: ${descMap.data[0]}${descMap.data[1]}=${descMap.data[2]}=${descMap.data[3]}${descMap.data[4]} data.size() = ${descMap.data.size()} value: ${value}}"
                                if (logEnable==true) log.warn "${device.displayName} map= ${descMap}"
                                break
                        }
                        break
                    default :
                        if (logEnable==true) log.warn "${device.displayName} Read attribute response: unknown status code ${status} Attributte ${attrId} cluster ${descMap.clusterId}"
                        break
                } // switch (descMap.clusterId)
            }  //command is read attribute response
            break
        case "04" : //write attribute response
            if (logEnable==true) log.info "${device.displayName} Received Write Attribute Response for cluster:${descMap.clusterId} , data=${descMap.data} (Status: ${descMap.data[0]=="00" ? 'Success' : '<b>Failure</b>'})"
            break
        case "07" : // Configure Reporting Response
            if (logEnable==true) log.info "${device.displayName} Received Configure Reporting Response for cluster:${descMap.clusterId} , data=${descMap.data} (Status: ${descMap.data[0]=="00" ? 'Success' : '<b>Failure</b>'})"
            // Status: Unreportable Attribute (0x8c)
            break
        case "09" : // Command: Read Reporting Configuration Response (0x09)
            // TS0121 Received Read Reporting Configuration Response (0x09) for cluster:0006 , data=[00, 00, 00, 00, 10, 00, 00, 58, 02] (Status: Success) min=0 max=600
            // TS0121 Received Read Reporting Configuration Response (0x09) for cluster:0702 , data=[00, 00, 00, 00, 25, 3C, 00, 10, 0E, 00, 00, 00, 00, 00, 00] (Status: Success) min=60 max=3600
            def status = zigbee.convertHexToInt(descMap.data[0])    // Status: Success (0x00)
            def attr = zigbee.convertHexToInt(descMap.data[3])*256 + zigbee.convertHexToInt(descMap.data[2])    // Attribute: OnOff (0x0000)
            if (status == 0) {
                def dataType = zigbee.convertHexToInt(descMap.data[4])    // Data Type: Boolean (0x10)
                def min = zigbee.convertHexToInt(descMap.data[6])*256 + zigbee.convertHexToInt(descMap.data[5])
                def max = zigbee.convertHexToInt(descMap.data[8]+descMap.data[7])
                def delta = 0
                if (descMap.data.size()>=10) { 
                    delta = zigbee.convertHexToInt(descMap.data[10]+descMap.data[9])
                }
                else {
                    if (logEnable==true) log.debug "${device.displayName} descMap.data.size = ${descMap.data.size()}"
                }
                if (logEnable==true) log.info "${device.displayName} Received Read Reporting Configuration Response (0x09) for cluster:${descMap.clusterId} attribite:${descMap.data[3]+descMap.data[2]}, data=${descMap.data} (Status: ${descMap.data[0]=="00" ? 'Success' : '<b>Failure</b>'}) min=${min} max=${max} delta=${delta}"
            }
            else {
                if (logEnable==true) log.info "${device.displayName} <b>Not Found (0x8b)</b> Read Reporting Configuration Response for cluster:${descMap.clusterId} attribite:${descMap.data[3]+descMap.data[2]}, data=${descMap.data} (Status: ${descMap.data[0]=="00" ? 'Success' : '<b>Failure</b>'})"
            }
            break
        case "0B" : // ZCL Default Response
            def status = descMap.data[1]
            if (status != "00") {
                switch (descMap.clusterId) {
                    case "0003" : // Identify response
                        if (txtEnable==true) log.warn "${device.displayName} Identify command is not supported by ${device.getDataValue('manufacturer')}"
                        break
                    case "0006" : // Switch state
                        if (logEnable==true) log.warn "${device.displayName} Switch state is not supported -> Switch polling will be disabled."
                        state.switchPollingSupported = false
                        break    // fixed in ver. 1.5.0
                    case "0B04" : // Electrical Measurement
                        if (logEnable==true) log.warn "${device.displayName} Electrical measurement is not supported -> Power, Voltage and Amperage polling will be disabled."
                        state.powerPollingSupported = false
                        state.voltagePollingSupported = false
                        state.currentPollingSupported = false
                        break
                    case "0702" : // Energy
                        if (logEnable==true) log.warn "${device.displayName} Energy measurement is not supported -> Energy polling will be disabled."
                        state.energyPollingSupported = false
                        break
                    default :
                        if (logEnable==true) log.info "${device.displayName} Received ZCL Default Response to Command ${descMap.data[0]} for cluster:${descMap.clusterId} , data=${descMap.data} (Status: ${descMap.data[1]=="00" ? 'Success' : '<b>Failure</b>'})"
                        break
                }
            }
            break
        case "24" :    // Tuya time sync
            if (settings?.logEnable) log.trace "${device.displayName} Tuya time sync"
            if (descMap?.clusterInt==0xEF00 && descMap?.command == "24") {        //getSETTIME
                if (settings?.logEnable) log.debug "${device.displayName} time synchronization request from device, descMap = ${descMap}"
                def offset = 0
                try {
                    offset = location.getTimeZone().getOffset(new Date().getTime())
                }
                catch(e) {
                    if (settings?.logEnable) log.error "${device.displayName} cannot resolve current location. please set location in Hubitat location setting. Setting timezone offset to zero"
                }
                def cmds = zigbee.command(0xEF00, 0x24, "0008" +zigbee.convertToHexString((int)(now()/1000),8) +  zigbee.convertToHexString((int)((now()+offset)/1000), 8))
                if (settings?.logEnable) log.trace "${device.displayName} now is: ${now()}"  // KK TODO - convert to Date/Time string!        
                if (settings?.logEnable) log.debug "${device.displayName} sending time data : ${cmds}"
                cmds.each{ sendHubCommand(new hubitat.device.HubAction(it, hubitat.device.Protocol.ZIGBEE)) }
                if (state.txCounter != null) state.txCounter = state.txCounter + 1
                return
            }
            break
        default :
            if (logEnable==true) log.warn "${device.displayName} Unprocessed global command: cluster=${descMap.clusterId} command=${descMap.command} attrId=${descMap.attrId} value=${descMap.value} data=${descMap.data}"
            break    // 9/16/2022
    }
}

private String getAttribute(ArrayList _data) {
    String retValue = ""
    if (_data.size() >= 5) {
        if (_data[2] == "01" && _data[3] == "01" && _data[4] == "00") {
            retValue = "switch"
        }
        else if (_data[2] == "02" && _data[3] == "02" && _data[4] == "00") {
            retValue = "level"
        }
    }
    return retValue
}

private int getAttributeValue(ArrayList _data) {
    int retValue = 0
    try {    
    if (_data.size() >= 6) {
        int dataLength = zigbee.convertHexToInt(_data[5]) as Integer
        int power = 1;
        for (i in dataLength..1) {
            retValue = retValue + power * zigbee.convertHexToInt(_data[i+5])
            power = power * 256
        }
    }
}
    catch ( e ) {
        log.error "${device.displayName} Exception caught : data = ${_data}"
    }
    return retValue
}

def off() {
    if (alwaysOn == true) {
        if (logEnable==true) log.warn "${device.displayName} AlwaysOn option for ${device.displayName} is enabled , the command to switch it OFF is ignored!"
    }
    else {
        state.isDigital = true
        if (logEnable) {log.debug "${device.displayName} Switching ${device.displayName} Off"}
        def cmds = zigbee.off()
        if (state.model == "TS0601") {
            cmds = zigbee.command(0xEF00, 0x0, "00010101000100")
        }
        runInMillis( digitalTimer, clearIsDigital, [overwrite: true])
        if (state.txCounter != null) state.txCounter = state.txCounter + 1
        if (logEnable==true) log.trace "${device.displayName} off() sending ${cmds}"
        return cmds
    }
}

def on() {
    state.isDigital = true
    if (logEnable) {log.debug "${device.displayName} Switching ${device.displayName} On"}
    def cmds = zigbee.on()
    if (state.model == "TS0601") {
        cmds = zigbee.command(0xEF00, 0x0, "00010101000101")
    }
    runInMillis( digitalTimer, clearIsDigital, [overwrite: true])
    if (state.txCounter != null) state.txCounter = state.txCounter + 1
    if (logEnable==true) log.trace "${device.displayName} on() sending ${cmds}"
    return cmds
}

def clearIsDigital() { state.isDigital = false }

def isRefreshRequestClear() { state.isRefreshRequest = false }

def switchDebouncingClear() { state.switchDebouncing = false }

def pollPower() {
    if (logEnable) {log.debug "${device.displayName} pollPower().."}
    List<String> cmds = []
    if (state.powerPollingSupported & state.voltagePollingSupported & state.currentPollingSupported == true) {
        if (settings?.reportPower == true || settings?.reportVoltage == true || settings?.reportAmperage == true) {
            cmds += zigbee.readAttribute(0x0B04, [0x050B, 0x0505, 0x0508], dummy, delay=200)    // Power, Voltage and Amperage at once!
        }
    }
    else {
        cmds += zigbee.electricMeasurementPowerRefresh()    // just power
    }
    state.isRefreshRequest = true
    runInMillis( refreshTimer, isRefreshRequestClear, [overwrite: true])       // 3 seconds
    if (state.txCounter != null) state.txCounter = state.txCounter + 1
    return cmds
}


// Sends refresh / readAttribute commands to the plug
//
def poll( refreshAll = false ) {
    if (logEnable) {log.trace "${device.displayName} polling.. refreshAll is ${refreshAll}"}
    checkDriverVersion()
    List<String> cmds = []
    if (state.switchPollingSupported == true && refreshAll == true ) {
        cmds = zigbee.onOffRefresh()                            // switch - polled only on full Refresh
    }
    if (state.powerPollingSupported & state.voltagePollingSupported & state.currentPollingSupported == true) {
        if (settings?.reportPower == true || settings?.reportVoltage == true || settings?.reportAmperage == true) {
            if (logEnable) {log.trace "${device.displayName} polling all"}
            cmds += zigbee.readAttribute(0x0B04, [0x050B, 0x0505, 0x0508], dummy, delay=200)    // Power, Voltage and Amperage at once!
        }
    }
    else {
        if (state.powerPollingSupported == true && settings?.reportPower == true) 
            cmds += zigbee.electricMeasurementPowerRefresh()    // Power ( cluster 0B04, attr. 050B )
        if (state.voltagePollingSupported == true && settings?.reportVoltage == true)
            cmds += zigbee.readAttribute(0x0B04, 0x0505)        // voltage
        if (state.currentPollingSupported == true  && settings?.reportAmperage == true)
            cmds += zigbee.readAttribute(0x0B04, 0x0508)        // current
    }    
    if (state.energyPollingSupported == true && refreshAll == true )
        cmds += zigbee.readAttribute(0x0702, 0x0000)            // energy - polled only on full Refresh
    state.isRefreshRequest = true
    runInMillis( refreshTimer, isRefreshRequestClear, [overwrite: true])           // 3 seconds
    if (state.txCounter != null) state.txCounter = state.txCounter + 1
    return cmds
}


def refresh() {
    if (txtEnable) {log.info "${device.displayName} refresh()..."}
    poll( true )
}

def autoPoll() {
    if (logEnable) {log.debug "${device.displayName} autoPoll()"}
    checkIfNotPresent()
    /* commented out 09/19/2022
    if (autoPollingEnabled?.value == true) {
        if ( pollingInterval != null ) 
            runIn( pollingInterval, autoPoll, [overwrite: true])
        else
            runIn( defaultPollingInterval, autoPoll, [overwrite: true])
    }
    */
    if (optimizations == true) 
        poll( refreshAll = false )
    else 
        poll( refreshAll = true )
}

def tuyaBlackMagic() {
    if (state.txCounter != null) state.txCounter = state.txCounter + 1
    return zigbee.readAttribute(0x0000, [0x0004, 0x000, 0x0001, 0x0005, 0x0007, 0xfffe], [:], delay=200)    // Cluster: Basic, attributes: Man.name, ZLC ver, App ver, Model Id, Power Source, attributeReportingStatus
}

/*
    configure() method is called: 
       *  unconditionally during the initial pairing, immediately after Installed() method
       *  when Initialize button is pressed
       *  from updated() when preferencies are saved
*/
def configure() {
    if (txtEnable==true) log.info "${device.displayName} configure().."

    scheduleHourlyAndDailyEnergy()
        
    List<String> cmds = []
    cmds += tuyaBlackMagic()
    cmds += refresh()
    cmds += zigbee.onOffConfig()

    // reportEnergy reportPower reportVoltage reportAmperage     energyMinReportingTime   energyMaxReportingTime    energyTreshold
    // energyTreshold powerTreshold amperageTreshold voltageTreshold
    
    if (reportEnergy == false) {
        device.deleteCurrentState("energy")
    }
    if (reportPower == false) {
        device.deleteCurrentState("power")
    }
    if (reportVoltage == false) {
        device.deleteCurrentState("voltage")
    }
    if (reportAmperage == false) {
        device.deleteCurrentState("amperage")
    }

    if (autoReportingEnabled == true ) {
        if (reportEnergy == true) {
            cmds += configureReporting("Write", ENERGY,  energyMinReportingTime.toString(), energyMaxReportingTime.toString(), energyTreshold.toString(), sendNow=false)
        }
        if (reportPower == true) {
            cmds += configureReporting("Write", POWER,  energyMinReportingTime.toString(), energyMaxReportingTime.toString(), powerTreshold.toString(), sendNow=false)
        }
        if (reportVoltage == true) {
            cmds += configureReporting("Write", VOLTAGE,  energyMinReportingTime.toString(), energyMaxReportingTime.toString(), voltageTreshold.toString(), sendNow=false)
        }
        if (reportAmperage == true) {
            cmds += configureReporting("Write", AMPERAGE,  energyMinReportingTime.toString(), energyMaxReportingTime.toString(), amperageTreshold.toString(), sendNow=false)
        }
    }
    else {
        if (logEnable==true) log.info "${device.displayName} Automatic reporting is disabled!"
    }
    sendZigbeeCommands(cmds)
}

def autoCron( timeInSeconds ) {
    if (timeInSeconds < 60) {
        // */12 * * * * ? *
        //schedule("*/$timeInSeconds * * ? * * *", autoPoll)
        schedule("*/$timeInSeconds * * * * ? *", autoPoll)
        return timeInSeconds.toString() + " seconds"
    }
    else {
        def minutes = (timeInSeconds / 60 ) as int
        if (minutes < 60) {
            schedule("0 */$minutes * ? * *", autoPoll)    
            return minutes.toString() + " minutes"
        }
        else {
            def hours = (minutes / 60 ) as int
            if (hours > 23) hours = 23
            schedule("0 0 */$hours ? * *", autoPoll)                    
            return hours.toString() + " hours"
        }
    }
}



// This method is called when the preferences of a device are updated.
def updated(){
    if (txtEnable==true) log.info "${device.displayName} Updating ${device.getLabel()} (${device.getName()}) model ${state.model} presence: ${device.currentValue("presence", true)} AlwaysOn is <b>${alwaysOn}</b> "
    if (txtEnable==true) log.info "${device.displayName} Debug logging is <b>${logEnable}</b> Description text logging is  <b>${txtEnable}</b>"
    if (logEnable==true) {
        runIn(86400, logsOff, [overwrite: true])    // turn off debug logging after 24 hours
        if (txtEnable==true) log.info "${device.displayName} Debug logging will be automatically switched off after 24 hours"
    }
    else {
        unschedule(logsOff)
    }
    def autoPollTime
    if (autoPollingEnabled?.value==true) {
        if ( pollingInterval != null ) {
            autoPollTime = autoCron( pollingInterval )
        }
        else {
            autoPollTime = autoCron( defaultPollingInterval )
        }
        if (txtEnable==true) log.info "${device.displayName} Auto polling is <b>enabled</b>, polling interval is ${autoPollTime} "
    }
    else {
        unschedule(autoPoll)
        log.info "${device.displayName} Auto polling is <b>disabled</b>"
    }
    if (txtEnable==true) log.info "${device.displayName} configuring the switch and energy reporting.."
    
    if (attribEnable == true ) {
        runIn( 1, formatAttrib, [overwrite: true])    
    }
    else {
        sendEvent(name: "html", value: "<table></table>", isChanged: true)
    }
    configure()
}



void initializeVars( boolean fullInit = true ) {
    
    def preservedResetEnergy = state.lastResetEnergy?:0            // preserve state.lastResetEnergy even on full reset!
    def preservedlastHourlyEnergy = state.lastHourlyEnergy?:0  
    if (logEnable==true) log.info "${device.displayName} InitializeVars()... fullInit = ${fullInit}"
    if (fullInit == true ) {
        if (logEnable==true) log.warn "${device.displayName} clearing states and preferences ..."
        if (logEnable==true) log.warn "${device.displayName} preservedResetEnergy = ${preservedResetEnergy}"
        state.clear()
        state.driverVersion = driverVersionAndTimeStamp()
    }
    state.rxCounter = 0
    state.txCounter = 0
    if (fullInit == true || state.lastPower == null) state.lastPower = 0.0
    if (fullInit == true || state.lastVoltage == null) state.lastVoltage = 0.0
    if (fullInit == true || state.lastAmperage == null) state.lastAmperage = 0.0
    if (state.lastEnergy == null) state.lastEnergy = 0.0
    if (state.lastEnergyCost == null) state.lastEnergyCost = 0.0
    if (state.lastSwitchState == null) state.lastSwitchState = "unknown"
    if (state.lastPresenceState == null) state.lastPresenceState = "unknown"
    if (fullInit == true || state.notPresentCounter == null) state.notPresentCounter = 0
    if (fullInit == true || state.switchPollingSupported == null) state.switchPollingSupported = true
    if (fullInit == true || state.voltagePollingSupported == null) state.voltagePollingSupported = true
    if (fullInit == true || state.currentPollingSupported == null) state.currentPollingSupported = true
    if (fullInit == true || state.powerPollingSupported == null) state.powerPollingSupported = true
    if (fullInit == true || state.energyPollingSupported == null) state.energyPollingSupported = true
    if (fullInit == true || state.isDigital == null) state.isDigital = true
    if (fullInit == true || state.isRefreshRequest == null) state.isRefreshRequest = true
    if (fullInit == true || state.switchDebouncing == null) state.switchDebouncing = false
    if (state.lastResetEnergy == null) {
        log.warn "state.lastResetEnergy = ${state.lastResetEnergy}, resetting it back to ${preservedResetEnergy}!"
        state.lastResetEnergy = preservedResetEnergy                               // do not reset on Initialize!
    }
    if (state.lastHourlyEnergy == null) {
        state.lastHourlyEnergy = preservedlastHourlyEnergy
    }
    if (state.lastResetDate == null) state.lastResetDate = FormattedDateTimeFromUnix( now() )    // do not reset on Initialize!
    if (debug == false) { if (fullInit == true || settings?.logEnable == null) device.updateSetting("logEnable", false) }
    else                { if (fullInit == true || settings?.logEnable == null) device.updateSetting("logEnable", true) }
    if (fullInit == true || settings?.txtEnable == null) device.updateSetting("txtEnable", true)
    if (fullInit == true || settings?.autoPollingEnabled == null) device.updateSetting("autoPollingEnabled", true)
    if (fullInit == true || settings?.autoReportingEnabled == null) device.updateSetting("autoReportingEnabled", false)
    if (fullInit == true || settings?.optimizations == null) device.updateSetting("optimizations", true)
    if (fullInit == true || settings?.reportEnergy == null) device.updateSetting("reportEnergy", true)
    if (fullInit == true || settings?.reportPower == null) device.updateSetting("reportPower", true)
    if (fullInit == true || settings?.reportVoltage == null) device.updateSetting("reportVoltage", true)
    if (fullInit == true || settings?.reportAmperage == null) device.updateSetting("reportAmperage", true)
    if (fullInit == true || settings?.energyMinReportingTime == null) device.updateSetting("energyMinReportingTime", [value:30, type:"number"])
    if (fullInit == true || settings?.energyMaxReportingTime == null) device.updateSetting("energyMaxReportingTime", [value:900, type:"number"])
    if (fullInit == true || settings?.energyTreshold == null) device.updateSetting("energyTreshold", [value:1, type:"number"])
    if (fullInit == true || settings?.energyPrice == null) device.updateSetting("energyPrice", [value:0.12, type:"decimal"])
    if (fullInit == true || settings?.powerTreshold == null) device.updateSetting("powerTreshold", [value:1, type:"number"])
    if (fullInit == true || settings?.amperageTreshold == null) device.updateSetting("amperageTreshold",[value:25, type:"number"])
    if (fullInit == true || settings?.voltageTreshold == null) device.updateSetting("voltageTreshold", 1)
    if (fullInit == true || settings?.attribEnable == null) device.updateSetting("attribEnable", false)

    if (fullInit == true || settings?.pollingInterval == null) device.updateSetting("pollingInterval", defaultPollingInterval)
    if (settings?.alwaysOn == null)  device.updateSetting("alwaysOn", false)       // do not change the "alwaysOn" setting if already set!

    def mm = device.getDataValue("model")
    if ( mm != null) {
        state.model = mm
        if (logEnable==true) log.trace "${device.displayName} model = ${state.model}"
    }
    else {
        if (txtEnable==true) log.warn "${device.displayName} Model not found, please re-pair the device!"
        state.model = UNKNOWN
    }
    def ep = device.getEndpointId()
    if ( ep  != null && ep != 0xF2) {
        state.destinationEP = ep
        if (logEnable==true) log.trace "${device.displayName} destinationEP = ${state.destinationEP}"
    }
    else {
        if (txtEnable==true) log.warn "${device.displayName} Destination End Point not found, please re-pair the device!"
        state.destinationEP = "01"    // fallback EP
    }    
}

def driverVersionAndTimeStamp() {version()+' '+timeStamp()}

def checkDriverVersion() {
    if (state.driverVersion != null && driverVersionAndTimeStamp() == state.driverVersion) {
        //log.trace "${device.displayName} driverVersion is the same ${driverVersionAndTimeStamp()}"
    }
    else {
        if (txtEnable==true) log.info "${device.displayName} updating the settings from driver version ${state.driverVersion} to ${driverVersionAndTimeStamp()}"
        initializeVars( fullInit = false ) 
        state.driverVersion = driverVersionAndTimeStamp()
    }
}

def logInitializeRezults() {
    if (logEnable==true) log.info "${device.displayName} switchPollingSupported  = ${state.switchPollingSupported}"
    if (logEnable==true) log.info "${device.displayName} voltagePollingSupported = ${state.voltagePollingSupported}"
    if (logEnable==true) log.info "${device.displayName} currentPollingSupported = ${state.currentPollingSupported}"
    if (logEnable==true) log.info "${device.displayName} powerPollingSupported   = ${state.powerPollingSupported}"
    if (logEnable==true) log.info "${device.displayName} energyPollingSupported  = ${state.energyPollingSupported}"
    if (logEnable==true) log.info "${device.displayName} Initialization finished"
}

def initialize() {
    if (txtEnable==true) log.warn "${device.displayName} Initialize()..."
    unschedule()
    initializeVars()
    runIn( 1, resetEnergy, [overwrite: true])      // 09/18/2022
    runIn( 2, refresh, [overwrite: true])      // 09/18/2022
    runIn( 11, updated, [overwrite: true])          // calls also configure()
    runIn( 12, logInitializeRezults, [overwrite: true])
    scheduleHourlyAndDailyEnergy()
}

// This method is called when the device is first created.
def installed() {
    if (txtEnable==true) log.info "${device.displayName} Installed()..."
    initializeVars(fullInit = true)
    runIn( 5, initialize, [overwrite: true])
    if (logEnable==true) log.debug "${device.displayName} calling initialize() after 5 seconds..."
    // HE will autoomaticall call configure() method here
}

void uninstalled() {
    if (logEnable==true) log.info "${device.displayName} Uninstalled()..."
    unschedule()     //Unschedule any existing schedules
}

// not used !
def powerRefresh() {
    def cmds = zigbee.electricMeasurementPowerRefresh()
    cmds.each{
        sendHubCommand(new hubitat.device.HubMultiAction(delayBetween(cmds,200), hubitat.device.Protocol.ZIGBEE))
    }
    if (state.txCounter != null) state.txCounter = state.txCounter + 1
}

// called when any event was received from the Zigbee device in parse() method..
def setPresent() {
    if (state.lastPresenceState != "present") {
    	sendEvent(name: "presence", value: "present") 
        state.lastPresenceState = "present"
    }
    state.notPresentCounter = 0
}

// called from autoPoll()
def checkIfNotPresent() {
    if (state.notPresentCounter != null) {
        state.notPresentCounter = state.notPresentCounter + 1
        if (state.notPresentCounter > presenceCountTreshold) {
            if (state.lastPresenceState != "not present") {
    	        sendEvent(name: "presence", value: "not present")
                state.lastPresenceState = "not present"
                if (logEnable==true) log.warn "${device.displayName} not present!"
                runIn( 1, formatAttrib, [overwrite: true])    
            }
        }
    }
}

void sendZigbeeCommands(List<String> cmds) {
    if (logEnable) {log.trace "${device.displayName} sendZigbeeCommands received : ${cmds}"}
	sendHubCommand(new hubitat.device.HubMultiAction(cmds, hubitat.device.Protocol.ZIGBEE))
    if (state.txCounter != null) state.txCounter = state.txCounter + 1
    // TODO - multiple commands ???
}

def logsOff(){
    log.warn "${device.displayName} debug logging disabled..."
    device.updateSetting("logEnable", [value:"false",type:"bool"])
}

boolean isTuyaE00xCluster( String description )
{
    if(description.indexOf('cluster: E000') >= 0 || description.indexOf('cluster: E001') >= 0) {
        if (logEnable) log.debug "${device.displayName} Tuya cluster: E000 or E001 - don't know how to handle it, skipping it for now..."
        return true
    }
    else
        return false
}



// return true if further processing in the main parse method should be cancelled !
boolean otherTuyaOddities( String description ) {
  
    if (description.indexOf('cluster: 0000') >= 0 && description.indexOf('attrId: 0004') >= 0) {
        if (logEnable) log.debug "${device.displayName} skipping Tuya parse of  cluster 0 attrId 4"             // parseDescriptionAsMap throws exception when processing Tuya cluster 0 attrId 4 
        return true
    }
    def descMap = [:]
    try {
        descMap = zigbee.parseDescriptionAsMap(description)
    }
    catch ( e ) {
        if (logEnable) log.warn "${device.displayName} exception caught while parsing <b>otherTuyaOddities</b> descMap:  ${descMap}"
        return true
    }
    //if (logEnable) {log.trace "${device.displayName} Checking Tuya Oddities Desc Map: $descMap"}        
    if (descMap.attrId == null ) {
        //if (logEnable) log.trace "${device.displayName} otherTuyaOddities - Cluster ${descMap.clusterId} NO ATTRIBUTE, skipping"
        return false
    }
    boolean bWasAtLeastOneAttributeProcessed = false
    // attribute report received
    List attrData = [[cluster: descMap.cluster ,attrId: descMap.attrId, value: descMap.value, status: descMap.status]]
    descMap.additionalAttrs.each {
        attrData << [cluster: descMap.cluster, attrId: it.attrId, value: it.value, status: it.status]
        //log.trace "tyua oddity: filling in attrData ${attrData}"
    }
    attrData.each {
        //log.trace "each it=${it}"
        def map = [:]
        if (it.status == "86") {
            if (settings?.logEnable) log.info "${device.displayName} Tuya Cluster ${descMap.cluster} <b>unsupported attrId ${it.attrId}</b>"
            // TODO - skip parsing?
        }
        switch (it.cluster) {
            case "0000" :
                if (it.attrId in ["0001"]) {
                    if (settings?.logEnable) log.debug "${device.displayName} Tuya check-in Cluster 0 attrId 1 (application version is ${it.value})"
                    bWasAtLeastOneAttributeProcessed = true
                }
                else if (it.attrId in ["FFE0", "FFE1", "FFE2", "FFE4"]) {
                    if (settings?.logEnable) log.debug "${device.displayName} Tuya Cluster ${descMap.cluster} attrId ${it.attrId} value ${it.value})"
                    bWasAtLeastOneAttributeProcessed = true
                }
                else if (it.attrId in ["FFFE", "FFDF"]) {
                    if (settings?.logEnable) log.debug "${device.displayName} Tuya Cluster ${descMap.cluster} attrId ${it.attrId} value ${it.value})"
                    bWasAtLeastOneAttributeProcessed = true
                }
                else {
                    if (logEnable) log.debug "${device.displayName} otherTuyaOddities - Cluster ${descMap.cluster} attrId ${it.attrId} value ${it.value}) N/A, skipping"
                }
                break
            case "0006" :
                if (it.attrId in ["8000", "8001", "8002", "8003"]) {
                    parseOnOffAttributes(it)
                    bWasAtLeastOneAttributeProcessed = true
                }
                if (it.attrId in ["4001", "4002"]) {
                    if (settings?.logEnable) log.info "${device.displayName} Tuya Cluster ${it.cluster} attrId ${it.attrId} value ${it.value}"
                    bWasAtLeastOneAttributeProcessed = true
                }
                break
            default :
                //if (logEnable) log.trace "${device.displayName} otherTuyaOddities - Cluster ${it.cluster} N/A, skipping"
                break
        } // switch
    } // for each attribute
    return bWasAtLeastOneAttributeProcessed
}



def childLock( mode ) {
    ArrayList<String> cmds = []
    if (state.model == "TS0601") {
        def dp = "1D" // hochChildLock: 29
        def value = mode == "off" ? "00" : "01"
        cmds += sendTuyaCommand(dp, DP_TYPE_BOOL, value)
    }
    else {
        // doesn't work for TS0121 _TZ3000_g5xawfcq :( 
        def value = mode == "off" ? "00" : mode == "on" ? "01" : null
        if (value != null) {
            cmds += zigbee.writeAttribute(zigbee.ON_OFF_CLUSTER, 0x8000, DataType.BOOLEAN, value.toInteger())
            if (settings?.logEnable) log.trace "${device.displayName} sending child lock mode : ${mode}"
            sendZigbeeCommands( cmds )    
        }
        else {
            if (settings?.logEnable) log.warn "${device.displayName} please select a Child Lock option"
        }
    }
}

def ledMode( mode ) {
    ArrayList<String> cmds = []
    String value = null
    if (state.model == "TS0601") {
        if (settings?.logEnable) log.warn "${device.displayName} LED mode not implemented for TS0601: ${mode}"
        // continue anyway ..
    }
    if (isCircuitBreaker()) {
        value = mode == "Always Green" ? "00" : mode == "Red when On; Green when Off" ? "01" : mode == "Green when On; Red when Off" ? "02" : mode == "Always Red" ? "03" : null
    }
    else {
        value = mode == "Disabled" ? "00" : mode == "Lit when On" ? "01" : mode == "Lit when Off" ? "02" : mode == "Freeze" ? "03" : null
    }
    if (value != null) {
        cmds += zigbee.writeAttribute(zigbee.ON_OFF_CLUSTER, 0x8001, DataType.ENUM8, value.toInteger())
        if (settings?.logEnable) log.trace "${device.displayName} sending LED mode : ${mode}"
        sendZigbeeCommands( cmds )    
    }
    else {
        if (mode.contains("---")) {
            if (settings?.logEnable) log.warn "${device.displayName} please select a LED mode option"
        }
        else {
            if (settings?.logEnable) log.warn "${device.displayName} LED mode ${mode} is not supported for your model:${device.getDataValue('model') } manufacturer:${device.getDataValue('manufacturer')}"
        }
    }
}

def powerOnState( mode ) {
    ArrayList<String> cmds = []
    String value = null
    if (state.model == "TS0601") {
        if (settings?.logEnable) log.warn "${device.displayName} Power On State not implemented for TS0601: ${mode}"
        // continue anyway ..
    }
    value = mode == "off" ? "00" : mode == "on" ? "01" : mode == "Last state" ? "02" : null
    if (value != null) {
        cmds += zigbee.writeAttribute(zigbee.ON_OFF_CLUSTER, 0x8002, DataType.ENUM8, value.toInteger())
        if (settings?.logEnable) log.trace "${device.displayName} sending LED mode : ${mode}"
        sendZigbeeCommands( cmds )    
    }
    else {
        if (settings?.logEnable) log.warn "${device.displayName} please select a Power On State option"
    }
}

private getIDENTIFY_CMD_IDENTIFY() { 0x00 }
private getIDENTIFY_CMD_QUERY() { 0x01 }
private getIDENTIFY_CMD_TRIGGER() { 0x40 }

def intTo16bitUnsignedHex(value) {
	def hexStr = zigbee.convertToHexString(value.toInteger(),4)
	return new String(hexStr.substring(2, 4) + hexStr.substring(0, 2))
}

def intTo8bitUnsignedHex(value) {
	return zigbee.convertToHexString(value.toInteger(), 2)
}

Integer safeToInt(val, Integer defaultVal=0) {
	return "${val}"?.isInteger() ? "${val}".toInteger() : defaultVal
}

Double safeToDouble(val, Double defaultVal=0.0) {
	return "${val}"?.isDouble() ? "${val}".toDouble() : defaultVal
}

def identify() {
	List<String> cmds = []
	cmds += "he cmd 0x${device.deviceNetworkId} 0x${device.endpointId} 0x0003 ${IDENTIFY_CMD_IDENTIFY} { 0x${intTo16bitUnsignedHex(30)} }"    // Identify for 30 seconds
	//cmds += "he cmd 0x${device.deviceNetworkId} 0x${device.endpointId} 0x0003 ${IDENTIFY_CMD_TRIGGER} { 0x${intTo8bitUnsignedHex(EFFECT_BREATHE)} 0x${intTo8bitUnsignedHex(0)} }"    // Trigger Effect
    if (txtEnable==true) log.info "${device.displayName} sending Identify to ${device.getDataValue('manufacturer')}"
    //cmds += zigbee.command(0x0003, 0x00, "0500")        // 5 seconds?
    if (state.txCounter != null) state.txCounter = state.txCounter + 1
	return cmds;
}

def configureReporting(String operation, String measurement,  String minTime, String maxTime, String delta, Boolean sendNow=true ) {
    int intMinTime = safeToInt(minTime)
    int intMaxTime = safeToInt(maxTime)
    int intDelta = safeToInt(delta)
    
    if (settings?.logEnable) log.trace "${device.displayName} configureReporting operation=${operation}, measurement=${measurement}  minTime=${intMinTime}, maxTime=${intMaxTime}, delta=${intDelta} )"

    List<String> cmds = []      
    
    switch (measurement) {
        case ONOFF :
            if (operation == "Write") {
                cmds += zigbee.onOffConfig(intMinTime, intMaxTime)  // Configure On/Off 
            }
            cmds +=  zigbee.reportingConfiguration(0x0006, 0x0000, [:], 250)    // read it back
            break
        case ENERGY :
            if (operation == "Write") {
                cmds += zigbee.configureReporting(0x0702, 0x0000,  DataType.UINT48, intMinTime, intMaxTime, intDelta)
            }
            cmds += zigbee.reportingConfiguration(0x0702, 0x0000, [:], 250)
            break
        case POWER :
            if (operation == "Write") {
                cmds += zigbee.configureReporting(0x0B04, 0x050B,  DataType.INT16, intMinTime, intMaxTime, intDelta)    // bug fixes in ver  1.6.0 - thanks @guyee
            }
            cmds += zigbee.reportingConfiguration(0x0B04, 0x050B, [:], 250)    // default delta = 1
            break
        case VOLTAGE :
            if (operation == "Write") {
                cmds += zigbee.configureReporting(0x0B04, 0x0505,  DataType.UINT16, intMinTime, intMaxTime, intDelta)    // bug fixes in ver 1.6.0 - thanks @guyee
            }
            cmds += zigbee.reportingConfiguration(0x0B04, 0x0505, [:], 250)    // default delta = 1
            break
        case AMPERAGE :
            if (operation == "Write") {
                cmds += zigbee.configureReporting(0x0B04, 0x0508,  DataType.UINT16, intMinTime, intMaxTime, intDelta)    // bug fixes in ver 1.6.0 - thanks @guyee
            }
            cmds += zigbee.reportingConfiguration(0x0B04, 0x0508, [:], 250)    // default delta = 100
            break
        default :
            break
    }
    if (cmds != null) {
        if (sendNow == true) {
            sendZigbeeCommands(cmds)
        }
        else {
            return cmds
        }
    }
}

def setEnergyPrice( price )
{
    if (price != null) {
        def priceDouble = safeToDouble( price ).round(6)
        if (priceDouble >= 0.01) {
            device.updateSetting("energyPrice", [value:priceDouble, type:"decimal"])
            if (settings?.txtEnable) log.info "${device.displayName} energy price was set to ${priceDouble} on ${FormattedDateTimeFromUnix(now())}"
        }
        else {
            if (settings?.txtEnable) log.warn "${device.displayName} please enter energy price between \$0.01 and \$99.99"
        }
    }
}

def resetEnergy() {
    def totalEnergy = safeToDouble(device.latestValue("energy"))    // last corrected energy value
    def now = FormattedDateTimeFromUnix( now() )
    def lastResetEnergy = state.lastResetEnergy + totalEnergy    // add the last corrected value to the previos lastResetEnergy
    state.lastResetEnergy = lastResetEnergy
    state.lastHourlyEnergy = lastResetEnergy
    state.lastResetDate = now
    state.lastEnergyCost = 0.0
    updateEnergyCost( state.lastEnergyCost , 0 )
    energyEvent( 0, isDigital=true )
    hourlyEnergyEvent( 0, isDigital=true )
    energyCostEvent( 0, isDigital=true ) 
    energyDurationtEvent( 0, isDigital=true  )
    if (settings?.txtEnable) log.info "${device.displayName} Energy (total:${totalEnergy} kWh) was reset on ${now}"
}

def calculateEnergyDuration() {
	def energyTimeMS = unixFromFormattedDateTime( state.lastResetDate )
	if (!energyTimeMS) {
		return "Unknown"
	}
    def duration = roundTwoPlaces((new Date().time - energyTimeMS) / 60000)
		
		if (duration >= (24 * 60)) {
			return getFormattedDuration(duration, (24 * 60), "Day")
		}
		else if (duration >= 60) {
			return getFormattedDuration(duration, 60, "Hour")
		}
		else {
			return getFormattedDuration(duration, 0, "Min")    // was "Minute"
		}
}

def getFormattedDuration(duration, divisor, name) {
	if (divisor) {
		duration = roundTwoPlaces(duration / divisor)
	}	
	return "${duration} ${name}${duration == 1 ? '' : 's'}"
}

def roundTwoPlaces(val) {
	return Math.round(safeToDouble(val) * 100) / 100
}

 
@Field static final String dateFormat = 'yyyy-MM-dd HH:mm:ss.SSS'

def unixFromFormattedDateTime( formattedDateTime ) {
    def unixDateTime = Date.parse(dateFormat, formattedDateTime).time
    //log.trace "unixDateTime=${unixDateTime}"
    return unixDateTime
}

def FormattedDateTimeFromUnix( unixDateTime ) {
    def formattedDateTime = new Date(unixDateTime).format(dateFormat, location.timeZone) 
    //log.trace "formattedDateTime=${formattedDateTime}"
    return formattedDateTime
}

void formatAttrib() {
    if (attribEnable == false) {
        sendEvent(name: "html", value: "<table></table>", isChanged: false)        
        return
    }
    if (settings?.logEnable) log.debug "formatAttrib"
    String attrStr = "<style>td{text-align:left;}</style><table id='hubInfoTable'>"
    
    attrStr += addToAttr("Presence", "presence")
    attrStr += addToAttr("Switch","switch")
    if (reportPower == true) {
        attrStr += addToAttr("Power", "power", convert ="int")
    }
    if (reportVoltage == true) {
        attrStr += addToAttr("Voltage","voltage")
    }
    if (reportAmperage == true) {
        attrStr += addToAttr("Amperage","amperage", convert = "double")
    }
    if (reportEnergy == true) {
        attrStr += addToAttr("Energy","energy")
        attrStr += addToAttr("Cost","energyCost")
        attrStr += addToAttr("Duration","energyDuration")
    }

    attrStr += "</table>"

    //if (settings?.logEnable) log.debug "after calls attr string = $attrStr"
    updateAttr("html", attrStr)
    if (attrStr.length() > 1024) { updateAttr("html", "Max Attribute Size Exceeded: ${attrStr.length()}") }
}

String combineAttr(String name, List<String> keys) {
    //if (settings?.logEnable) log.debug "adding $name, $keys.length"

    String retResult = '<tr><td align="left">'
    retResult += name + '</td><td align="left">'
    
    String keyResult = ""
    for (i = 0;i < keys.size(); i++) {
        keyResult += device.currentValue(keys[i],true)
        String attrUnit = getUnitFromState(keys[i])
        if (attrUnit != null) keyResult += " " + attrUnit
        if (i < keys.size() - 1) keyResult += " / "
    }
            
    retResult += keyResult + '</td></tr>'
    return retResult
}

String addToAttr(String name, String key, String convert = "none") {
    //if (settings?.logEnable) log.debug "adding $name, $key"
    String retResult = '<tr><td>'
    retResult += name + '</td><td>'

    String attrUnit = getUnitFromState(key)
    if (attrUnit == null) attrUnit = ""

    def curVal = device.currentValue(key,true)
    if (curVal != null) {
        if (convert == "int") {
              retResult += safeToInt(curVal).toString() + " " + attrUnit
        } 
        else if (convert == "double") {
            retResult += safeToDouble(curVal).toString() + " " + attrUnit
        } 
        else 
            retResult += curVal.toString() + " " + attrUnit
    }
    retResult += '</td></tr>'
    return retResult
}

String getUnitFromState(String attrName){
   	return device.currentState(attrName)?.unit
}

void updateAttr(String aKey, aValue, String aUnit = "") {
    sendEvent(name:aKey, value:aValue, unit:aUnit)
}

def deviceNotification(text) {
    if (settings?.logEnable) log.debug "deviceNotification: ${text}"
}

def test(String description)
{
    List<String> cmds = []
    cmds += "zdo bind 0x${device.deviceNetworkId} 0x01 0x01 0x0006 {${device.zigbeeId}} {}"
    cmds += "zdo bind 0x${device.deviceNetworkId} 0x01 0x01 0x0702 {${device.zigbeeId}} {}"
    cmds += "zdo bind 0x${device.deviceNetworkId} 0x01 0x01 0x0B04 {${device.zigbeeId}} {}"
    cmds += "he cmd 0x${device.deviceNetworkId} 0x01 6 2 {}, delay 200"
    log.trace "sending test: ${cmds}"
    sendZigbeeCommands(cmds)
}

