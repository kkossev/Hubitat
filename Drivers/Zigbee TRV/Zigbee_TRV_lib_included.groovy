/**
 *  Zigbee TRV - Device Driver for Hubitat Elevation
 *
 *  https://community.hubitat.com/t/dynamic-capabilities-commands-and-attributes-for-drivers/98342
 *
 *     Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *     in compliance with the License. You may obtain a copy of the License at:
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *     Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *     on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *     for the specific language governing permissions and limitations under the License.
 *
 *
 * ver. 3.0.0  2023-11-16 kkossev  - (dev. branch) Refactored version 2.x.x drivers and libraries; adding MOES BRT-100 support - setHeatingSettpoint OK; off OK; level OK; workingState OK
 *
 *                                   TODO: Auto 
 *                                   TODO: Cool
 *                                   TODO: Heat
 *                                   TODO: Emergency Heat
 *                                   TODO: setThermostatMode
 *                                   TODO: Fan Auto, Circlulate, On; setThermostatFanMode
 *                                   TODO: 
 *                                   TODO: remove (raw:) when debug is off
 *                                   TODO: add 'force manual mode' preference
 *                                   TODO: move debug and info logging preferences from the common library to the driver, so that they are the first preferences in the list
 *                                   TODO: add Info dummy preference to the driver with a hyperlink 
 *                                   TODO: change deviceProfilesV2 to deviceProfilesV3 in the lib
 *                                   TODO: add test command to list the fingerprints generated by the deviceProfileLib
 *                                   TODO: add _DEBUG command (for temporary switching the debug logs on/off)
 *                                   TODO: make a driver template for new drivers
 *                                   TODO: Versions of the main module + included libraries 
 *                                   TODO: HomeKit - min and max temperature limits?
 *                                   TODO: add receiveCheck() methods for heatingSetpint and mode (option)
 */

static String version() { "3.0.0" }
static String timeStamp() {"2023/11/18 11:27 PM"}

@Field static final Boolean _DEBUG = false

import groovy.transform.Field
import hubitat.device.HubMultiAction
import hubitat.device.Protocol
import hubitat.helper.HexUtils
import hubitat.zigbee.zcl.DataType
import java.util.concurrent.ConcurrentHashMap
import groovy.json.JsonOutput


deviceType = "Thermostat"
@Field static final String DEVICE_TYPE = "Thermostat"





metadata {
    definition (
        name: 'Zigbee TRV',
        importUrl: 'https://raw.githubusercontent.com/kkossev/Hubitat/development/Drivers/Zigbee_TRV/Zigbee_TRV_lib_included.groovy',
        namespace: 'kkossev', author: 'Krassimir Kossev', singleThreaded: true 
    ) {    
        
    capability "Actuator"
    capability "Refresh"
    capability "Sensor"
    capability "Temperature Measurement"
    capability "Thermostat"                 // needed for HomeKit
    
    /*
        capability "ThermostatHeatingSetpoint"
        capability "ThermostatCoolingSetpoint"
        capability "ThermostatOperatingState"
        capability "ThermostatSetpoint"
        capability "ThermostatMode"    
    */

    // Aqara E1 thermostat attributes
    // TODO - add all other models attributes possible values
    // BRT-100 attributes
    attribute 'trvMode', "enum",  ["auto", "manual", "TempHold", "holidays"]
    attribute 'emergencyHeating', "enum", ["off", "on"]
    attribute 'emergencyHeatingTime', "number"
    attribute 'workingState', "enum", ["open", "closed"]
    attribute 'windowOpenDetection', "enum", ["off", "on"]      // BRT-100 and Aqara E1
    attribute 'windowsState', "enum", ["open", "closed"]        // BRT-100 and Aqara E1
    attribute 'childLock', "enum", ["off", "on"]                // BRT-100 and Aqara E1
    attribute 'battery', "number"
    attribute 'weeklyProgram', "number"
    attribute 'boostTime', "number"
    attribute 'level', "number"
    attribute 'calibrationTemp', "number"
    attribute 'ecoMode', "enum", ["off", "on"]
    attribute 'ecoTemp', "number"
    attribute 'minHeatingSetpoint', "number"
    attribute 'maxTemp', "number"

    // Aqaura E1 attributes
    attribute "systemMode", 'enum', SystemModeOpts.options.values() as List<String>            // 'off','heat'
    attribute "preset", 'enum', PresetOpts.options.values() as List<String>                     // 'manual','auto','away'
    attribute "valveDetection", 'enum', ValveDetectionOpts.options.values() as List<String>     // 'off','on'
    attribute "valveAlarm", 'enum', ValveAlarmOpts.options.values() as List<String>             // 'false','true'
    attribute "awayPresetTemperature", 'number'
    attribute "calibrated", 'enum', CalibratedOpts.options.values() as List<String>
    attribute "sensor", 'enum', SensorOpts.options.values() as List<String>
    attribute "battery", 'number'

    //command "preset", [[name:"select preset option", type: "ENUM",   constraints: ["--- select ---"]+PresetOpts.options.values() as List<String>]]

    if (_DEBUG) { command "testT", [[name: "testT", type: "STRING", description: "testT", defaultValue : ""]]  }

    // TODO - add Sonoff TRVZB fingerprint

    //fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0001,0003,FCC0,000A,0201", outClusters:"0003,FCC0,0201", model:"lumi.airrtc.agl001", manufacturer:"LUMI", deviceJoinName: "Aqara E1 Thermostat"     // model: 'SRTS-A01'
    // fingerprints are inputed from the deviceProfile maps

    // https://github.com/Koenkk/zigbee-herdsman-converters/blob/6339b6034de34f8a633e4f753dc6e506ac9b001c/src/devices/xiaomi.ts#L3197
    // https://github.com/Smanar/deconz-rest-plugin/blob/6efd103c1a43eb300a19bf3bf3745742239e9fee/devices/xiaomi/xiaomi_lumi.airrtc.agl001.json 
    // https://github.com/dresden-elektronik/deconz-rest-plugin/issues/6351
    }
    
    preferences {
        if (advancedOptions == true) {
            input name: 'temperaturePollingInterval', type: 'enum', title: '<b>Temperature polling interval</b>', options: TemperaturePollingIntervalOpts.options, defaultValue: TemperaturePollingIntervalOpts.defaultValue, required: true, description: '<i>Changes how often the hub will poll the TRV for faster temperature reading updates.</i>'
        }
    }
    
}

def isAqaraTRV()                     { return getDeviceGroup().contains("AQARA_E1_TRV") }
def isBRT100TRV()                    { return getDeviceGroup().contains("MOES_BRT-100") }

@Field static final Map TemperaturePollingIntervalOpts = [
    defaultValue: 600,
    options     : [0: 'Disabled', 60: 'Every minute (not recommended)', 120: 'Every 2 minutes', 300: 'Every 5 minutes', 600: 'Every 10 minutes', 900: 'Every 15 minutes', 1800: 'Every 30 minutes', 3600: 'Every 1 hour']
]

@Field static final Map SystemModeOpts = [        //system_mode
    defaultValue: 1,
    options     : [0: 'off', 1: 'heat']
]
@Field static final Map PresetOpts = [            // preset
    defaultValue: 1,
    options     : [0: 'manual', 1: 'auto', 2: 'away']
]
@Field static final Map WindowDetectionOpts = [   // window_detection
    defaultValue: 1,
    options     : [0: 'off', 1: 'on']
]
@Field static final Map ValveDetectionOpts = [    // valve_detection
    defaultValue: 1,
    options     : [0: 'off', 1: 'on']
]
@Field static final Map ValveAlarmOpts = [    // valve_alarm
    defaultValue: 1,
    options     : [0: false, 1: true]
]
@Field static final Map ChildLockOpts = [    // child_lock
    defaultValue: 1,
    options     : [0: 'unlock', 1: 'lock']
]
@Field static final Map WindowOpenOpts = [    // window_open
    defaultValue: 1,
    options     : [0: false, 1: true]
]
@Field static final Map CalibratedOpts = [    // calibrated
    defaultValue: 1,
    options     : [0: false, 1: true]
]
@Field static final Map SensorOpts = [
    defaultValue: 1,
    options     : [0: 'internal', 1: 'external']
]

@Field static final Map deviceProfilesV2 = [
    // isAqaraTRV()
    "AQARA_E1_TRV"   : [
            description   : "Aqara E1 Thermostat model SRTS-A01",
            models        : ["LUMI"],
            device        : [type: "TRV", powerSource: "battery", isSleepy:false],
            capabilities  : ["ThermostatHeatingSetpoint": true, "ThermostatOperatingState": true, "ThermostatSetpoint":true, "ThermostatMode":true],

            preferences   : ["window_detection":"0xFCC0:0x0273", "valveDetection":"0xFCC0:0x0274",, "childLock":"0xFCC0:0x0277", "awayPresetTemperature":"0xFCC0:0x0279"],
            fingerprints  : [
                [profileId:"0104", endpointId:"01", inClusters:"0000,0001,0003,FCC0,000A,0201", outClusters:"0003,FCC0,0201", model:"lumi.airrtc.agl001", manufacturer:"LUMI", deviceJoinName: "Aqara E1 Thermostat"] 
            ],
            commands      : ["setHeatingSetpoint":"setHeatingSetpoint", "resetStats":"resetStats", 'refresh':'refresh', "initialize":"initialize", "updateAllPreferences": "updateAllPreferences", "resetPreferencesToDefaults":"resetPreferencesToDefaults", "validateAndFixPreferences":"validateAndFixPreferences"],
            tuyaDPs       : [:],
            attributes    : [
                [at:"0xFCC0:0x040A",  name:'battery',                       type:"number",  dt: "0x21",   rw: "ro", min:0,    max:100,  step:1,  scale:1,    unit:"%",  description:'<i>Battery percentage remaining</i>'],
                [at:"0xFCC0:0x0271",  name:'systemMode',                   type:"enum",    dt: "0x20",   mfgCode:"0x115f",  rw: "rw", min:0,    max:1,    step:1,  scale:1,    map:[0: "off", 1: "heat"], unit:"",         title: "<b>System Mode</b>",                   description:'<i>System Mode</i>'],
                [at:"0xFCC0:0x0272",  name:'preset',                        type:"enum",    dt: "0x20",   mfgCode:"0x115f",  rw: "rw", min:0,    max:2,    step:1,  scale:1,    map:[0: "manual", 1: "auto", 2: "away"], unit:"",         title: "<b>Preset</b>",                        description:'<i>Preset</i>'],
                [at:"0xFCC0:0x0273",  name:'windowOpenDetection',           type:"enum",    dt: "0x20",   mfgCode:"0x115f",  rw: "rw", min:0,    max:1,    defaultValue:"0",    step:1,  scale:1,    map:[0: "off", 1: "on"], unit:"",         title: "<b>Window Detection</b>",              description:'<i>Window detection</i>'],
                [at:"0xFCC0:0x0274",  name:'valveDetection',                type:"enum",    dt: "0x20",   mfgCode:"0x115f",  rw: "rw", min:0,    max:1,    defaultValue:"0",    step:1,  scale:1,    map:[0: "off", 1: "on"], unit:"",         title: "<b>Valve Detection</b>",               description:'<i>Valve detection</i>'],
                [at:"0xFCC0:0x0275",  name:'valveAlarm',                    type:"enum",    dt: "0x20",   mfgCode:"0x115f",  rw: "ro", min:0,    max:1,    defaultValue:"0",    step:1,  scale:1,    map:[0: "false", 1: "true"], unit:"",         title: "<b>Valve Alarm</b>",                   description:'<i>Valve alarm</i>'],
                [at:"0xFCC0:0x0277",  name:'childLock',                     type:"enum",    dt: "0x20",   mfgCode:"0x115f",  rw: "rw", min:0,    max:1,    defaultValue:"0",    step:1,  scale:1,    map:[0: "unlock", 1: "lock"], unit:"",         title: "<b>Child Lock</b>",                    description:'<i>Child lock</i>'],
                [at:"0xFCC0:0x0279",  name:'awayPresetTemperature',       type:"decimal", dt: "0x23",   mfgCode:"0x115f",  rw: "rw", min:5.0,  max:35.0, defaultValue:5.0,    step:0.5, scale:100,  unit:"°C", title: "<b>Away Preset Temperature</b>",       description:'<i>Away preset temperature</i>'],
                [at:"0xFCC0:0x027A",  name:'windowsState',                  type:"enum",    dt: "0x20",   mfgCode:"0x115f",  rw: "ro", min:0,    max:1,    defaultValue:"0",    step:1,  scale:1,    map:[0: "open", 1: "closed"], unit:"",         title: "<b>Window Open</b>",                   description:'<i>Window open</i>'],
                [at:"0xFCC0:0x027B",  name:'calibrated',                    type:"enum",    dt: "0x20",   mfgCode:"0x115f",  rw: "ro", min:0,    max:1,    defaultValue:"0",    step:1,  scale:1,    map:[0: "false", 1: "true"], unit:"",         title: "<b>Calibrated</b>",                    description:'<i>Calibrated</i>'],
                [at:"0xFCC0:0x027E",  name:'sensor',                        type:"enum",    dt: "0x20",   mfgCode:"0x115f",  rw: "ro", min:0,    max:1,    defaultValue:"0",    step:1,  scale:1,    map:[0: "internal", 1: "external"], unit:"",         title: "<b>Sensor</b>",                        description:'<i>Sensor</i>'],
                //
                [at:"0x0201:0x0000",  name:'temperature',                   type:"decimal", dt: "0x21",   rw: "ro", min:5.0,  max:35.0, step:0.5, scale:100,  unit:"°C", title: "<b>Temperature</b>",                   description:'<i>Measured temperature</i>'],
                [at:"0x0201:0x0011",  name:'coolingSetpoint',               type:"decimal", dt: "0x21",   rw: "rw", min:5.0,  max:35.0, step:0.5, scale:100,  unit:"°C", title: "<b>Cooling Setpoint</b>",              description:'<i>cooling setpoint</i>'],
                [at:"0x0201:0x0012",  name:'heatingSetpoint',               type:"decimal", dt: "0x21",   rw: "rw", min:5.0,  max:35.0, step:0.5, scale:100,  unit:"°C", title: "<b>Current Heating Setpoint</b>",      description:'<i>Current heating setpoint</i>'],
                [at:"0x0201:0x001C",  name:'mode',                          type:"enum",    dt: "0x20",   rw: "rw", min:0,    max:1,    step:1,  scale:1,    map:[0: "off", 1: "heat"], unit:"",         title: "<b> Mode</b>",                   description:'<i>System Mode ?</i>'],
                //                      ^^^^ TODO - check if this is the same as system_mode    
                [at:"0x0201:0x001E",  name:'thermostatRunMode',             type:"enum",    dt: "0x20",   rw: "rw", min:0,    max:1,    step:1,  scale:1,    map:[0: "off", 1: "heat"], unit:"",         title: "<b>thermostatRunMode</b>",                   description:'<i>thermostatRunMode</i>'],
                //                          ^^ TODO  
                [at:"0x0201:0x0020",  name:'battery2',                      type:"number",  dt: "0x20",   rw: "ro", min:0,    max:100,  step:1,  scale:1,    unit:"%",  description:'<i>Battery percentage remaining</i>'],
                //                          ^^ TODO  
                [at:"0x0201:0x0023",  name:'thermostatHoldMode',            type:"enum",    dt: "0x20",   rw: "rw", min:0,    max:1,    step:1,  scale:1,    map:[0: "off", 1: "heat"], unit:"",         title: "<b>thermostatHoldMode</b>",                   description:'<i>thermostatHoldMode</i>'],
                //                          ^^ TODO  
                [at:"0x0201:0x0029",  name:'thermostatOperatingState',      type:"enum",    dt: "0x20",   rw: "rw", min:0,    max:1,    step:1,  scale:1,    map:[0: "off", 1: "heat"], unit:"",         title: "<b>thermostatOperatingState</b>",                   description:'<i>thermostatOperatingState</i>'],
                //                          ^^ TODO  
                [at:"0x0201:0xFFF2",  name:'unknown',                       type:"number",  dt: "0x21",   rw: "ro", min:0,    max:100,  step:1,  scale:1,    unit:"%",  description:'<i>Battery percentage remaining</i>'],
            ],
            deviceJoinName: "Aqara E1 Thermostat",
            configuration : [:]
    ],

// BRT-100-B0
// fingerprint 
    "MOES_BRT-100"   : [
            description   : "MOES BRT-100 TRV",
            models        : ["TS0601"],
            device        : [type: "TRV", powerSource: "battery", isSleepy:false],
            capabilities  : ["ThermostatHeatingSetpoint": true, "ThermostatOperatingState": true, "ThermostatSetpoint":true, "ThermostatMode":true],
            preferences   : ["windowOpenDetection":"8", "childLock":"13", "boostTime":"103", "calibrationTemp":"105", "ecoMode":"106", "ecoTemp":"107", "minHeatingSetpoint":"109", "maxTemp":"108"/**/],
            fingerprints  : [
                [profileId:"0104", endpointId:"01", inClusters:"0000,0004,0005,EF00", outClusters:"0019,000A", model:"TS0601", manufacturer:"_TZE200_b6wax7g0", deviceJoinName: "MOES BRT-100 TRV"] 
            ],
            commands      : ["setHeatingSetpoint":"setHeatingSetpoint", "resetStats":"resetStats", 'refresh':'refresh', "initialize":"initialize", "updateAllPreferences": "updateAllPreferences", "resetPreferencesToDefaults":"resetPreferencesToDefaults", "validateAndFixPreferences":"validateAndFixPreferences"],
            tuyaDPs       : [
                [dp:1,   name:'trvMode',            type:"enum",            rw: "rw", min:0,     max:3,    defaultValue:"1",  step:1,   scale:1,  map:[0: "auto", 1: "manual", 2: "TempHold", 3: "holidays"] ,   unit:"", title:"<b>Thermostat Mode</b>",  description:'<i>Thermostat mode</i>'], 
                [dp:2,   name:'heatingSetpoint',    type:"decimal",         rw: "rw", min:5.0,   max:45.0, defaultValue:20.0, step:1.0, scale:1,  unit:"°C",  title: "<b>Current Heating Setpoint</b>",      description:'<i>Current heating setpoint</i>'],
                [dp:3,   name:'temperature',        type:"decimal",         rw: "ro", min:-10.0, max:50.0, defaultValue:20.0, step:0.5, scale:10, unit:"°C",  description:'<i>Temperature</i>'],
                [dp:4,   name:'emergencyHeating',   type:"enum",  dt: "01", rw: "rw", min:0,     max:1 ,   defaultValue:"0",  step:1,   scale:1,  map:[0:"off", 1:"on"] ,   unit:"", title:"<b>Emergency Heating</b>",  description:'<i>Emergency heating</i>'], 
                [dp:5,   name:'emergencyHeatingTime',   type:"number",      rw: "rw", min:0,     max:720 , defaultValue:15,   step:15,  scale:1,  unit:"minutes", title:"<b>Emergency Heating Timer</b>",  description:'<i>Emergency heating timer</i>'], 
                [dp:7,   name:'workingState',       type:"enum",            rw: "rw", min:0,     max:1 ,   defaultValue:"0",  step:1,   scale:1,  map:[0:"open", 1:"closed"] ,   unit:"", title:"<bWorking State</b>",  description:'<i>working state</i>'], 
                [dp:8,   name:'windowOpenDetection', type:"enum", dt: "01", rw: "rw", min:0,     max:1 ,   defaultValue:"0",  step:1,   scale:1,  map:[0:"off", 1:"on"] ,   unit:"", title:"<b>Window Detection</b>",  description:'<i>Window detection</i>'], 
                [dp:9,   name:'windowsState',       type:"enum",            rw: "rw", min:0,     max:1 ,   defaultValue:"0",  step:1,   scale:1,  map:[0:"open", 1:"closed"] ,   unit:"", title:"<bWindow State</b>",  description:'<i>Window state</i>'], 
                [dp:13,  name:'childLock',          type:"enum",  dt: "01", rw: "rw", min:0,     max:1 ,   defaultValue:"0",  step:1,   scale:1,  map:[0:"off", 1:"on"] ,   unit:"", title:"<b>Child Lock</b>",  description:'<i>Child lock</i>'], 
                [dp:14,  name:'battery',            type:"number",          rw: "ro", min:0,     max:100,  defaultValue:100,  step:1,   scale:1,  unit:"%",          description:'<i>Battery level</i>'],
                [dp:101, name:'weeklyProgram',      type:"number",          rw: "ro", min:0,     max:9999, defaultValue:0,    step:1,   scale:1,  unit:"",          description:'<i>Weekly program</i>'],
                [dp:103, name:'boostTime',          type:"number",          rw: "rw", min:100,   max:900 , defaultValue:100,  step:1,   scale:1,  unit:"seconds", title:"<b>Boost Timer</b>",  description:'<i>Boost timer</i>'], 
                [dp:104, name:'level',              type:"number",          rw: "ro", min:0,     max:100,  defaultValue:100,  step:1,   scale:1,  unit:"%",          description:'<i>Valve level</i>'],
                [dp:105, name:'calibrationTemp',    type:"decimal",         rw: "rw", min:-9.0,  max:9.0,  defaultValue:00.0, step:1,   scale:1,  unit:"°C",  title:"<b>Calibration Temperature</b>", description:'<i>Calibration Temperature</i>'],
                [dp:106, name:'ecoMode',            type:"enum",  dt: "01", rw: "rw", min:0,     max:1 ,   defaultValue:"0",  step:1,   scale:1,  map:[0:"off", 1:"on"] ,   unit:"", title:"<b>Eco mode</b>",  description:'<i>Eco mode</i>'], 
                [dp:107, name:'ecoTemp',            type:"decimal",         rw: "rw", min:5.0,   max:35.0, defaultValue:20.0, step:1.0, scale:1,  unit:"°C",  title: "<b>Eco Temperature</b>",      description:'<i>Eco temperature</i>'],
                [dp:108, name:'maxTemp',            type:"decimal",         rw: "rw", min:15.0,  max:45.0, defaultValue:35.0, step:1.0, scale:1,  unit:"°C",  title: "<b>Maximum Temperature</b>",      description:'<i>Maximum temperature</i>'],
                [dp:109, name:'minHeatingSetpoint',            type:"decimal",         rw: "rw", min:5.0,   max:15.0, defaultValue:10.0, step:1.0, scale:1,  unit:"°C",  title: "<b>Minimum Temperature</b>",      description:'<i>Minimum temperature</i>'],

            ],
            deviceJoinName: "MOES MRT-100 TRV",
            configuration : [:]
    ],


    "UNKNOWN"   : [
            description   : "GENERIC TRV",
            models        : ["*"],
            device        : [type: "TRV", powerSource: "battery", isSleepy:false],
            capabilities  : ["ThermostatHeatingSetpoint": true, "ThermostatOperatingState": true, "ThermostatSetpoint":true, "ThermostatMode":true],

            preferences   : [],
            fingerprints  : [],
            commands      : ["resetStats":"resetStats", 'refresh':'refresh', "initialize":"initialize", "updateAllPreferences": "updateAllPreferences", "resetPreferencesToDefaults":"resetPreferencesToDefaults", "validateAndFixPreferences":"validateAndFixPreferences"],
            tuyaDPs       : [:],
            attributes    : [
                [at:"0x0201:0x0000",  name:'temperature',                   type:"decimal", dt: "UINT16", rw: "ro", min:5.0,  max:35.0, step:0.5, scale:100,  unit:"°C", title: "<b>Temperature</b>",                   description:'<i>Measured temperature</i>'],
                [at:"0x0201:0x0011",  name:'coolingSetpoint',               type:"decimal", dt: "UINT16", rw: "rw", min:5.0,  max:35.0, step:0.5, scale:100,  unit:"°C", title: "<b>Cooling Setpoint</b>",              description:'<i>cooling setpoint</i>'],
                [at:"0x0201:0x0012",  name:'heatingSetpoint',               type:"decimal", dt: "UINT16", rw: "rw", min:5.0,  max:35.0, step:0.5, scale:100,  unit:"°C", title: "<b>Current Heating Setpoint</b>",      description:'<i>Current heating setpoint</i>'],
                [at:"0x0201:0x001C",  name:'mode',                          type:"enum",    dt: "UINT8",  rw: "rw", min:0,    max:1,    step:1,  scale:1,    map:[0: "off", 1: "heat"], unit:"",         title: "<b> Mode</b>",                   description:'<i>System Mode ?</i>'],
                [at:"0x0201:0x001E",  name:'thermostatRunMode',             type:"enum",    dt: "UINT8",  rw: "rw", min:0,    max:1,    step:1,  scale:1,    map:[0: "off", 1: "heat"], unit:"",         title: "<b>thermostatRunMode</b>",                   description:'<i>thermostatRunMode</i>'],
                [at:"0x0201:0x0020",  name:'battery2',                     type:"number",  dt: "UINT16", rw: "ro", min:0,    max:100,  step:1,  scale:1,    unit:"%",  description:'<i>Battery percentage remaining</i>'],
                [at:"0x0201:0x0023",  name:'thermostatHoldMode',           type:"enum",    dt: "UINT8",  rw: "rw", min:0,    max:1,    step:1,  scale:1,    map:[0: "off", 1: "heat"], unit:"",         title: "<b>thermostatHoldMode</b>",                   description:'<i>thermostatHoldMode</i>'],
                [at:"0x0201:0x0029",  name:'thermostatOperatingState',      type:"enum",    dt: "UINT8",  rw: "rw", min:0,    max:1,    step:1,  scale:1,    map:[0: "off", 1: "heat"], unit:"",         title: "<b>thermostatOperatingState</b>",                   description:'<i>thermostatOperatingState</i>'],
            ],
            deviceJoinName: "UNKWNOWN TRV",
            configuration : [:]
    ]

]



void thermostatEvent(eventName, value, raw) {
    sendEvent(name: eventName, value: value, type: "physical")
    logInfo "${eventName} is ${value} (raw ${raw})"
}

// called from parseXiaomiClusterLib in xiaomiLib.groovy (xiaomi cluster 0xFCC0 )
//
void parseXiaomiClusterThermostatLib(final Map descMap) {
    //logWarn "parseXiaomiClusterThermostatLib: received xiaomi cluster attribute 0x${descMap.attrId} (value ${descMap.value})"
    final Integer raw
    final String  value
    switch (descMap.attrInt as Integer) {
        case 0x040a:    // E1 battery - read only
            raw = hexStrToUnsignedInt(descMap.value)
            thermostatEvent("battery", raw, raw)
            break
        case 0x00F7 :   // XIAOMI_SPECIAL_REPORT_ID:  0x00F7 sent every 55 minutes
            final Map<Integer, Integer> tags = decodeXiaomiTags(descMap.value)
            parseXiaomiClusterThermostatTags(tags)
            break
        case 0x0271:    // result['system_mode'] = {1: 'heat', 0: 'off'}[value]; (heating state) - rw
            raw = hexStrToUnsignedInt(descMap.value)
            value = SystemModeOpts.options[raw as int]
            thermostatEvent("systemMode", value, raw)
            break;
        case 0x0272:    // result['preset'] = {2: 'away', 1: 'auto', 0: 'manual'}[value]; - rw  ['manual', 'auto', 'holiday']
            raw = hexStrToUnsignedInt(descMap.value)
            value = PresetOpts.options[raw as int]
            thermostatEvent("preset", value, raw)
            break;
        case 0x0273:    // result['window_detection'] = {1: 'ON', 0: 'OFF'}[value]; - rw
            raw = hexStrToUnsignedInt(descMap.value)
            value = WindowDetectionOpts.options[raw as int]
            thermostatEvent("windowOpenDetection", value, raw)
            break;
        case 0x0274:    // result['valve_detection'] = {1: 'ON', 0: 'OFF'}[value]; -rw 
            raw = hexStrToUnsignedInt(descMap.value)
            value = ValveDetectionOpts.options[raw as int]
            thermostatEvent("valveDetection", value, raw)
            break;
        case 0x0275:    // result['valve_alarm'] = {1: true, 0: false}[value]; - read only!
            raw = hexStrToUnsignedInt(descMap.value)
            value = ValveAlarmOpts.options[raw as int]
            thermostatEvent("valveAlarm", value, raw)
            break;
        case 0x0277:    // result['child_lock'] = {1: 'LOCK', 0: 'UNLOCK'}[value]; - rw
            raw = hexStrToUnsignedInt(descMap.value)
            value = ChildLockOpts.options[raw as int]
            thermostatEvent("childLock", value, raw)
            break;
        case 0x0279:    // result['away_preset_temperature'] = (value / 100).toFixed(1); - rw
            raw = hexStrToUnsignedInt(descMap.value)
            value = raw / 100
            thermostatEvent("awayPresetTemperature", value, raw)
            break;
        case 0x027a:    // result['window_open'] = {1: true, 0: false}[value]; - read only
            raw = hexStrToUnsignedInt(descMap.value)
            value = WindowOpenOpts.options[raw as int]
            thermostatEvent("windowsState", value, raw)
            break;
        case 0x027b:    // result['calibrated'] = {1: true, 0: false}[value]; - read only
            raw = hexStrToUnsignedInt(descMap.value)
            value = CalibratedOpts.options[raw as int]
            thermostatEvent("calibrated", value, raw)
            break;
        case 0x0276:    // unknown
        case 0x027c:    // unknown
        case 0x027d:    // unknown
        case 0x0280:    // unknown
        case 0xfff2:    // unknown
        case 0x00ff:    // unknown
        case 0x00f7:    // unknown
        case 0xfff2:    // unknown
        case 0x00FF:
            try {
                raw = hexStrToUnsignedInt(descMap.value)
                logDebug "Aqara E1 TRV unknown attribute ${descMap.attrInt} value raw = ${raw}"
            }
            catch (e) {
                logWarn "exception caught while processing Aqara E1 TRV unknown attribute ${descMap.attrInt} descMap.value = ${descMap.value}"
            }
            break;
        case 0x027e:    // result['sensor'] = {1: 'external', 0: 'internal'}[value]; - read only?
            raw = hexStrToUnsignedInt(descMap.value)
            value = SensorOpts.options[raw as int]
            thermostatEvent("sensor", value, raw)
            break;
        default:
            logWarn "parseXiaomiClusterThermostatLib: received unknown xiaomi cluster 0xFCC0 attribute 0x${descMap.attrId} (value ${descMap.value})"
            break
    }
}

// called from parseXiaomiClusterThermostatLib 
void parseXiaomiClusterThermostatTags(final Map<Integer, Object> tags) {
    tags.each { final Integer tag, final Object value ->
        switch (tag) {
            case 0x01:    // battery voltage
                logDebug "xiaomi decode tag: 0x${intToHexStr(tag, 1)} battery voltage is ${value/1000}V (raw=${value})"
                break
            case 0x03:
                logDebug "xiaomi decode tag: 0x${intToHexStr(tag, 1)} device internal chip temperature is ${value}&deg; (ignore it!)"
                break
            case 0x05:
                logDebug "xiaomi decode tag: 0x${intToHexStr(tag, 1)} RSSI is ${value}"
                break
            case 0x06:
                logDebug "xiaomi decode tag: 0x${intToHexStr(tag, 1)} LQI is ${value}"
                break
            case 0x08:            // SWBUILD_TAG_ID:
                final String swBuild = '0.0.0_' + (value & 0xFF).toString().padLeft(4, '0')
                logDebug "xiaomi decode tag: 0x${intToHexStr(tag, 1)} swBuild is ${swBuild} (raw ${value})"
                device.updateDataValue("aqaraVersion", swBuild)
                break
            case 0x0a:
                String nwk = intToHexStr(value as Integer,2)
                if (state.health == null) { state.health = [:] }
                String oldNWK = state.health['parentNWK'] ?: 'n/a'
                logDebug "xiaomi decode tag: 0x${intToHexStr(tag, 1)} <b>Parent NWK is ${nwk}</b>"
                if (oldNWK != nwk ) {
                    logWarn "parentNWK changed from ${oldNWK} to ${nwk}"
                    state.health['parentNWK']  = nwk
                    state.health['nwkCtr'] = (state.health['nwkCtr'] ?: 0) + 1
                }
                break
            case 0x0d:
                logDebug "xiaomi decode E1 thermostat unknown tag: 0x${intToHexStr(tag, 1)}=${value}"
                break            
            case 0x11:
                logDebug "xiaomi decode E1 thermostat unknown tag: 0x${intToHexStr(tag, 1)}=${value}"
                break            
            case 0x64:
                logDebug "xiaomi decode tag: 0x${intToHexStr(tag, 1)} temperature is ${value/100} (raw ${value})"    // Aqara TVOC
                break
            case 0x65:
                logDebug "xiaomi decode E1 thermostat unknown tag: 0x${intToHexStr(tag, 1)}=${value}"
                break
            case 0x66:
                logDebug "xiaomi decode E1 thermostat temperature tag: 0x${intToHexStr(tag, 1)}=${value}"
                handleTemperatureEvent(value/100.0)
                break
            case 0x67:
                logDebug "xiaomi decode E1 thermostat heatingSetpoint tag: 0x${intToHexStr(tag, 1)}=${value}"
                break
            case 0x68:
                logDebug "xiaomi decode E1 thermostat unknown tag: 0x${intToHexStr(tag, 1)}=${value}"
                break
            case 0x69:
                logDebug "xiaomi decode E1 thermostat battery tag: 0x${intToHexStr(tag, 1)}=${value}"
                break
            case 0x6a:
                logDebug "xiaomi decode E1 thermostat unknown tag: 0x${intToHexStr(tag, 1)}=${value}"
                break
            default:
                logDebug "xiaomi decode unknown tag: 0x${intToHexStr(tag, 1)}=${value}"
        }
    }
}


/*
 * -----------------------------------------------------------------------------
 * thermostat cluster 0x0201
 * called from parseThermostatCluster() in the main code ...
 * -----------------------------------------------------------------------------
*/

void parseThermostatClusterThermostat(final Map descMap) {
    final Integer value = safeToInt(hexStrToUnsignedInt(descMap.value))
    if (settings.logEnable) {
        log.trace "zigbee received Thermostat cluster (0x0201) attribute 0x${descMap.attrId} value ${value} (raw ${descMap.value})"
    }

    switch (descMap.attrInt as Integer) {
        case 0x000:                      // temperature
            logDebug "temperature = ${value/100.0} (raw ${value})"
            handleTemperatureEvent(value/100.0)
            break
        case 0x0011:                      // cooling setpoint
            logInfo "cooling setpoint = ${value/100.0} (raw ${value})"
            break
        case 0x0012:                      // heating setpoint
            logInfo "heating setpoint = ${value/100.0} (raw ${value})"
            sendHeatingSetpointEvent(value/100.0)
            break
        case 0x001c:                      // mode
            logInfo "mode = ${value} (raw ${value})"
            break
        case 0x001e:                      // thermostatRunMode
            logInfo "thermostatRunMode = ${value} (raw ${value})"
            break
        case 0x0020:                      // battery
            logInfo "battery = ${value} (raw ${value})"
            break
        case 0x0023:                      // thermostatHoldMode
            logInfo "thermostatHoldMode = ${value} (raw ${value})"
            break
        case 0x0029:                      // thermostatOperatingState
            logInfo "thermostatOperatingState = ${value} (raw ${value})"
            break
        case 0xfff2:    // unknown
            logDebug "Aqara E1 TRV unknown attribute ${descMap.attrInt} value raw = ${value}"
            break;
        default:
            log.warn "zigbee received unknown Thermostat cluster (0x0201) attribute 0x${descMap.attrId} (value ${descMap.value})"
            break
    }
}

//  setHeatingSetpoint thermostat capability standard command
//  1°C steps. (0.5°C setting on the TRV itself, rounded for zigbee interface)
def setHeatingSetpoint( temperature ) {
    logTrace "setHeatingSetpoint(${temperature}) called!"
    def previousSetpoint = device.currentState('heatingSetpoint')?.value ?: 0
    double tempDouble
    //logDebug "setHeatingSetpoint temperature = ${temperature}  as int = ${temperature as int} (previousSetpointt = ${previousSetpoint})"
    if (true) {
        //logDebug "0.5 C correction of the heating setpoint${temperature}"
        tempDouble = safeToDouble(temperature)
        tempDouble = Math.round(tempDouble * 2) / 2.0
    }
    else {
        if (temperature != (temperature as int)) {
            if ((temperature as double) > (previousSetpoint as double)) {
                temperature = (temperature + 0.5 ) as int
            }
            else {
                temperature = temperature as int
            }
        logDebug "corrected heating setpoint ${temperature}"
        }
        tempDouble = temperature
    }
    def maxTemp = settings?.maxHeatingSetpoint ?: 50
    def minTemp = settings?.minHeatingSetpoint ?: 5
    if (tempDouble > maxTemp ) tempDouble = maxTemp
    if (tempDouble < minTemp) tempDouble = minTemp
    tempDouble = tempDouble.round(1)
    // 
    if (isAqaraTRV()) {
        zigbee.writeAttribute(0x0201, 0x12, 0x29, (tempDouble * 100) as int)        // raw:F6690102010A1200299808, dni:F669, endpoint:01, cluster:0201, size:0A, attrId:0012, encoding:29, command:0A, value:0898, clusterInt:513, attrInt:18
    }
    else {
        log.warn "calling sendAttribute heatingSetpoint ${tempDouble}"
        sendAttribute("heatingSetpoint", tempDouble)    // TODO - check if this will create a preference !!
    }
}

private void sendHeatingSetpointEvent(temperature) {
    tempDouble = safeToDouble(temperature)
    Map eventMap = [name: "heatingSetpoint",  value: tempDouble, unit: "\u00B0"+"C"]
    eventMap.descriptionText = "heatingSetpoint is ${tempDouble}"
    sendEvent(eventMap)
    if (eventMap.descriptionText != null) { logInfo "${eventMap.descriptionText}" }

    eventMap = [name: "thermostatSetpoint", value: tempDouble, unit: "\u00B0"+"C"]
    eventMap.descriptionText = null
    sendEvent(eventMap)
    updateDataValue("lastRunningMode", "heat")
}

// thermostat capability standard command
// do nothing in TRV - just send an event
def setCoolingSetpoint(temperature){
    logTrace "setCoolingSetpoint(${temperature}) called!"
    if (temperature != (temperature as int)) {
        temperature = (temperature + 0.5 ) as int
        logDebug "corrected temperature: ${temperature}"
    }
    sendEvent(name: "coolingSetpoint", value: temperature, unit: "\u00B0"+"C")
}



/*
// TODO - refactor!
void processTuyaDpThermostat(descMap, dp, dp_id, fncmd) {

    switch (dp) {
        case 0x01 : // on/off
            sendSwitchEvent(fncmd)
            break
        default :
            logWarn "<b>NOT PROCESSED</b> Tuya cmd: dp=${dp} value=${fncmd} descMap.data = ${descMap?.data}" 
            break            
    }
}
*/

// TODO - refactor!
def preset( preset ) {
    logTrace "preset(${preset}) called!"
    if (preset == "auto") {
        setPresetMode("auto")               // hand symbol NOT shown
    }
    else if (preset == "manual") {
        setPresetMode("manual")             // hand symbol is shown on the LCD
    }
    else if (preset == "away") {
        setPresetMode("away")               // 5 degreees 
    }
    else {
        logWarn "preset: unknown preset ${preset}"
    }
}

// TODO - refactor!
def setPresetMode(mode) {
    List<String> cmds = []
    logDebug "sending setPresetMode(${mode})"    
    if (isAqaraTRV()) {
        // {'manual': 0, 'auto': 1, 'away': 2}), type: 0x20}
        if (mode == "auto") {
            cmds = zigbee.writeAttribute(0xFCC0, 0x0272, 0x20, 0x01, [mfgCode: 0x115F], delay=200)
        }
        else if (mode == "manual") {
            cmds = zigbee.writeAttribute(0xFCC0, 0x0272, 0x20, 0x00, [mfgCode: 0x115F], delay=200)
        }
        else if (mode == "away") {
            cmds = zigbee.writeAttribute(0xFCC0, 0x0272, 0x20, 0x02, [mfgCode: 0x115F], delay=200)
        }
        else {
            logWarn "setPresetMode: Aqara TRV unknown preset ${mode}"
        }
    }
    else {
        // TODO - set generic thermostat mode
        log.warn "setPresetMode NOT IMPLEMENTED"
        return
    }
    if (cmds == []) { cmds = ["delay 299"] }
    sendZigbeeCommands(cmds)

}

def setThermostatMode( mode ) {
    List<String> cmds = []
    logDebug "setThermostatMode: sending setThermostatMode(${mode})"

    //state.mode = mode
    if (isAqaraTRV()) {
        // TODO - set Aqara E1 thermostat mode
        switch(mode) {
            case "heat":
            case "auto":
                cmds = zigbee.writeAttribute(0xFCC0, 0x0271, 0x20, 0x01, [mfgCode: 0x115F], delay=200)        // 'off': 0, 'heat': 1
                break
            case "off":
                cmds = zigbee.writeAttribute(0xFCC0, 0x0271, 0x20, 0x00, [mfgCode: 0x115F], delay=200)        // 'off': 0, 'heat': 1
                break
            default:
                logWarn "setThermostatMode: unknown AqaraTRV mode ${mode}"
                break
        }
    }
    else {
        // TODO - set generic thermostat mode
        switch(mode) {
            case "heat":
            case "auto":
                if (device.currentValue('ecoMode') != 'off') {
                    logInfo "setThermostatMode: switching the eco mode off"
                    sendAttribute("ecoMode", 0)
                }
                if (device.currentValue('emergencyHeating') != 'off') {
                    logInfo "setThermostatMode: switching the emergencyHeating mode off"
                    sendAttribute("emergencyHeating", 0)
                }
                logInfo "setThermostatMode: setting manual mode on (${device.currentValue('heatingSetpoint')} &degC)"
                sendAttribute("trvMode", 1)
                break
            case "off":
            case "cool":
                // BRT-100 does not have an explicit off command, so we use the  mode (16 degrees)      // TODO - check how to switch BRT-100 low temp protection mode (5 degrees) ?
                logInfo "setThermostatMode: setting eco mode on (${settings.ecoTemp} &degC)"
                sendAttribute("ecoMode", 1)
                break
            case "emergency heat":
                logInfo "setThermostatMode: setting emergency heat mode on (${settings.emergencyHeatingTime} minutes)"
                sendAttribute("emergencyHeating", 1)
                break
            default:
                logWarn "setThermostatMode: unknown mode ${mode}"
                break
        }
    }
    if (cmds == []) { cmds = ["delay 299"] }
    sendZigbeeCommands(cmds)
}

def thermostatOff() { setThermostatMode("off") }    // invoked from the common library
def thermostatOn()  { setThermostatMode("heat") }   // invoked from the common library

def heat() { setThermostatMode("heat") }
def auto() { setThermostatMode("auto") }
def cool() { setThermostatMode("cool") }
def emergencyHeat() { setThermostatMode("emergency heat") }




def setThermostatFanMode(fanMode) { sendEvent(name: "thermostatFanMode", value: "${fanMode}", descriptionText: getDescriptionText("thermostatFanMode is ${fanMode}")) }
def fanAuto() { setThermostatFanMode("auto") }
def fanCirculate() { setThermostatFanMode("circulate") }
def fanOn() { setThermostatFanMode("on") }

def sendThermostatOperatingStateEvent( st ) {
    sendEvent(name: "thermostatOperatingState", value: st)
    state.lastThermostatOperatingState = st
}

void sendSupportedThermostatModes() {
    def supportedThermostatModes = []
    supportedThermostatModes = ["off", "heat", "auto", "emergency heat"]
    logInfo "supportedThermostatModes: ${supportedThermostatModes}"
    sendEvent(name: "supportedThermostatModes", value:  JsonOutput.toJson(supportedThermostatModes), isStateChange: true)
}


/**
 * Schedule thermostat polling
 * @param intervalMins interval in seconds
 */
private void scheduleThermostatPolling(final int intervalSecs) {
    String cron = getCron( intervalSecs )
    logDebug "cron = ${cron}"
    schedule(cron, 'autoPollThermostat')
}

private void unScheduleThermostatPolling() {
    unschedule('autoPollThermostat')
}

/**
 * Scheduled job for polling device specific attribute(s)
 */
void autoPollThermostat() {
    logDebug "autoPollThermostat()..."
    checkDriverVersion()
    List<String> cmds = []
    if (state.states == null) state.states = [:]
    //state.states["isRefresh"] = true
    if (isAqaraTRV()) {
        cmds += zigbee.readAttribute(0x0201, 0x0000, [:], delay=3500)      // 0x0000=local temperature, 0x0011=cooling setpoint, 0x0012=heating setpoint, 0x001B=controlledSequenceOfOperation, 0x001C=system mode (enum8 )       
    }
    else {
        logDebug "autoPollThermostat: no polling for device profile ${state.deviceProfile}"
    }
   
    if (cmds != null && cmds != [] ) {
        sendZigbeeCommands(cmds)
    }    
}

//
// called from updated() in the main code ...
void updatedThermostat() {
    ArrayList<String> cmds = []
    logDebug "updatedThermostat: ..."
    //
    if (settings?.forcedProfile != null) {
        //logDebug "current state.deviceProfile=${state.deviceProfile}, settings.forcedProfile=${settings?.forcedProfile}, getProfileKey()=${getProfileKey(settings?.forcedProfile)}"
        if (getProfileKey(settings?.forcedProfile) != state.deviceProfile) {
            logWarn "changing the device profile from ${state.deviceProfile} to ${getProfileKey(settings?.forcedProfile)}"
            state.deviceProfile = getProfileKey(settings?.forcedProfile)
            //initializeVars(fullInit = false) 
            initVarsThermostat(fullInit = false)
            resetPreferencesToDefaults(debug=true)
            logInfo "press F5 to refresh the page"
        }
    }
    else {
        logDebug "forcedProfile is not set"
    }    
    final int pollingInterval = (settings.temperaturePollingInterval as Integer) ?: 0
    if (pollingInterval > 0) {
        logInfo "updatedThermostat: scheduling temperature polling every ${pollingInterval} seconds"
        scheduleThermostatPolling(pollingInterval)
    }
    else {
        unScheduleThermostatPolling()
        logInfo "updatedThermostat: thermostat polling is disabled!"
    }
    // Itterates through all settings
    logDebug "updatedThermostat: updateAllPreferences()..."
    /*cmds =*/ updateAllPreferences()     
    //
    /*
    if (cmds != null && cmds != [] ) {
        sendZigbeeCommands(cmds)
    }    
    */
}

def refreshThermostat() {
    List<String> cmds = []
    if (isAqaraTRV()) {
        //cmds += zigbee.readAttribute(0x0001, 0x0020, [:], delay=200)                                         // battery voltage (E1 does not send percentage)
        cmds += zigbee.readAttribute(0x0201, [0x0000, 0x0011, 0x0012, 0x001B, 0x001C], [:], delay=3500)       // 0x0000=local temperature, 0x0011=cooling setpoint, 0x0012=heating setpoint, 0x001B=controlledSequenceOfOperation, 0x001C=system mode (enum8 )       
        cmds += zigbee.readAttribute(0xFCC0, [0x0271, 0x0272, 0x0273, 0x0274, 0x0275, 0x0277, 0x0279, 0x027A, 0x027B, 0x027E], [mfgCode: 0x115F], delay=3500)       
        cmds += zigbee.readAttribute(0xFCC0, 0x040a, [mfgCode: 0x115F], delay=500)       
        // stock Generic Zigbee Thermostat Refresh answer:
        // raw:F669010201441C0030011E008600000029640A2900861B0000300412000029540B110000299808, dni:F669, endpoint:01, cluster:0201, size:44, attrId:001C, encoding:30, command:01, value:01, clusterInt:513, attrInt:28, additionalAttrs:[[status:86, attrId:001E, attrInt:30], [value:0A64, encoding:29, attrId:0000, consumedBytes:5, attrInt:0], [status:86, attrId:0029, attrInt:41], [value:04, encoding:30, attrId:001B, consumedBytes:4, attrInt:27], [value:0B54, encoding:29, attrId:0012, consumedBytes:5, attrInt:18], [value:0898, encoding:29, attrId:0011, consumedBytes:5, attrInt:17]]
        // conclusion : binding and reporting configuration for this Aqara E1 thermostat does nothing... We need polling mechanism for faster updates of the internal temperature readings.
    }
    else if (isBRT100TRV()) {
        //logDebug "no refresh commands for MOES_BRT-100"
        // TODO - research how to get the temperature updates from the BRT-100 !!
        cmds += zigbee.readAttribute(0x0000, [0x0004, 0x000, 0x0001, 0x0005, 0x0007, 0xfffe], [:], delay=200)

    }
    else if (DEVICE_PROFILE == "UNKNOWN") {
        logDebug "no refresh commands for UNKNOWN"
    }
    else {
        logWarn "refreshThermostat: unknown device profile ${DEVICE}"
    }
    
    if (cmds == []) { cmds = ["delay 299"] }
    logDebug "refreshThermostat: ${cmds} "
    return cmds
}

def configureThermostat() {
    List<String> cmds = []
    // TODO !!
    logDebug "configureThermostat() : ${cmds}"
    if (cmds == []) { cmds = ["delay 299"] }    // no , 
    return cmds    
}

def initializeThermostat()
{
    List<String> cmds = []
    int intMinTime = 300
    int intMaxTime = 600    // report temperature every 10 minutes !

    logDebug "configuring cluster 0x0201 ..."
    cmds += ["zdo bind 0x${device.deviceNetworkId} 0x01 0x01 0x0201 {${device.zigbeeId}} {}", "delay 251", ]
    //cmds += zigbee.configureReporting(0x0201, 0x0012, 0x29, intMinTime as int, intMaxTime as int, 0x01, [:], delay=541)
    //cmds += zigbee.configureReporting(0x0201, 0x0000, 0x29, 20, 120, 0x01, [:], delay=542)

    cmds += ["he cr 0x${device.deviceNetworkId} 0x01 0x0201 0x0012 0x29 1 600 {}", "delay 551", ]
    cmds += ["he cr 0x${device.deviceNetworkId} 0x01 0x0201 0x0000 0x29 20 300 {}", "delay 551", ]
    cmds += ["he cr 0x${device.deviceNetworkId} 0x01 0x0201 0x001C 0x30 1 600 {}", "delay 551", ]
    
    cmds +=  zigbee.reportingConfiguration(0x0201, 0x0012, [:], 551)    // read it back - doesn't work
    cmds +=  zigbee.reportingConfiguration(0x0201, 0x0000, [:], 552)    // read it back - doesn't wor
    cmds +=  zigbee.reportingConfiguration(0x0201, 0x001C, [:], 552)    // read it back - doesn't wor


    logDebug "initializeThermostat() : ${cmds}"
    if (cmds == []) { cmds = ["delay 299",] }
    return cmds        
}


void initVarsThermostat(boolean fullInit=false) {
    logDebug "initVarsThermostat(${fullInit})"
    if (state.deviceProfile == null) {
        setDeviceNameAndProfile()               // in deviceProfileiLib.groovy
    }

    if (fullInit == true || state.lastThermostatMode == null) state.lastThermostatMode = "unknown"
    if (fullInit == true || state.lastThermostatOperatingState == null) state.lastThermostatOperatingState = "unknown"
    if (fullInit || settings?.temperaturePollingInterval == null) device.updateSetting('temperaturePollingInterval', [value: TemperaturePollingIntervalOpts.defaultValue.toString(), type: 'enum'])

    if (fullInit == true) {
        resetPreferencesToDefaults()
    }
    //    
    
}


void initEventsThermostat(boolean fullInit=false) {
    sendSupportedThermostatModes()
    sendEvent(name: "supportedThermostatFanModes", value: JsonOutput.toJson(["on", "auto"]), isStateChange: true)    
    sendEvent(name: "thermostatMode", value: "heat", isStateChange: true, description: "inital attribute setting")
    sendEvent(name: "thermostatFanMode", value: "auto", isStateChange: true, description: "inital attribute setting")
    state.lastThermostatMode = "heat"
    sendThermostatOperatingStateEvent( "idle" )
    sendEvent(name: "thermostatOperatingState", value: "idle", isStateChange: true, description: "inital attribute setting")
    sendEvent(name: "thermostatSetpoint", value:  12.3, unit: "\u00B0"+"C", isStateChange: true, description: "inital attribute setting")        // Google Home compatibility
    sendEvent(name: "heatingSetpoint", value: 12.3, unit: "\u00B0"+"C", isStateChange: true, description: "inital attribute setting")
    sendEvent(name: "coolingSetpoint", value: 34.5, unit: "\u00B0"+"C", isStateChange: true, description: "inital attribute setting")
    sendEvent(name: "temperature", value: 23.4, unit: "\u00B0"+"C", isStateChange: true, description: "inital attribute setting")    
    updateDataValue("lastRunningMode", "heat")    
    
}

private getDescriptionText(msg) {
    def descriptionText = "${device.displayName} ${msg}"
    if (settings?.txtEnable) log.info "${descriptionText}"
    return descriptionText
}

// called from processTuyaDPfromDeviceProfile in deviceProfileLib 
def processDeviceEventThermostat(name, valueScaled, unitText, descText) {
    logTrace "processTuyaDpThermostat(${name}, ${valueScaled}) called!"
    Map eventMap = [name: name, value: valueScaled, unit: unitText, descriptionText: descText, type: "physical", isStateChange: true]
    switch (name) {
        case "temperature" :
            handleTemperatureEvent(valueScaled as Float)
            break
        case "humidity" :
            handleHumidityEvent(valueScaled)
            break
        case "ecoMode" :    // BRT-100 - simulate OFF mode
            sendEvent(eventMap)
            logInfo "${descText}"
            if (valueScaled == "on") {  // ecoMode is on
                sendEvent(name: "thermostatMode", value: "off", isStateChange: true, description: "BRT-100 ecoMode is on")
                sendEvent(name: "thermostatOperatingState", value: "idle", isStateChange: true, description: "BRT-100 ecoMode is on")
            }
            else {
                sendEvent(name: "thermostatMode", value: "heat", isStateChange: true, description: "BRT-100 ecoMode is off")
            }
            break
        case "emergencyHeating" :   // BRT-100
            sendEvent(eventMap)
            logInfo "${descText}"
            if (valueScaled == "on") {  // the valve shoud be completely open, however the level and the working states are NOT updated! :( 
                sendEvent(name: "thermostatMode", value: "emergency heat", isStateChange: true, description: "BRT-100 emergencyHeating is on")
                sendEvent(name: "thermostatOperatingState", value: "heating", isStateChange: true, description: "BRT-100 emergencyHeating is on")
            }
            else {
                sendEvent(name: "thermostatMode", value: "heat", isStateChange: true, description: "BRT-100 emergencyHeating is off")
            }
            break
        case "level" :      // BRT-100
            sendEvent(eventMap)
            logInfo "${descText}"
            if (valueScaled == 0) {  // the valve is closed
                sendEvent(name: "thermostatOperatingState", value: "idle", isStateChange: true, description: "BRT-100 valve is closed")
            }
            else {
                sendEvent(name: "thermostatOperatingState", value: "heating", isStateChange: true, description: "BRT-100 valve is open %{valueScaled} %")
            }
            break
        case "workingState" :      // BRT-100
            sendEvent(eventMap)
            logInfo "${descText}"
            if (valueScaled == "closed") {  // the valve is closed
                sendEvent(name: "thermostatOperatingState", value: "idle", isStateChange: true, description: "BRT-100 workingState is closed")
            }
            else {
                sendEvent(name: "thermostatOperatingState", value: "heating", isStateChange: true, description: "BRT-100 workingState is open")
            }
            break
        default :
            sendEvent(name : name, value : valueScaled, unit:unitText, descriptionText: descText, type: "physical", isStateChange: true)    // attribute value is changed - send an event !
            //if (!doNotTrace) {
                logDebug "event ${name} sent w/ value ${valueScaled}"
                logInfo "${descText}"                                 // send an Info log also (because value changed )  // TODO - check whether Info log will be sent also for spammy DPs ?                               
            //}
            break
    }
}

def testT(par) {
    logWarn "testT(${par})"
}


// ~~~~~ start include (144) kkossev.commonLib ~~~~~
library ( // library marker kkossev.commonLib, line 1
    base: "driver", // library marker kkossev.commonLib, line 2
    author: "Krassimir Kossev", // library marker kkossev.commonLib, line 3
    category: "zigbee", // library marker kkossev.commonLib, line 4
    description: "Common ZCL Library", // library marker kkossev.commonLib, line 5
    name: "commonLib", // library marker kkossev.commonLib, line 6
    namespace: "kkossev", // library marker kkossev.commonLib, line 7
    importUrl: "https://raw.githubusercontent.com/kkossev/hubitat/development/libraries/commonLib.groovy", // library marker kkossev.commonLib, line 8
    version: "3.0.0", // library marker kkossev.commonLib, line 9
    documentationLink: "" // library marker kkossev.commonLib, line 10
) // library marker kkossev.commonLib, line 11
/* // library marker kkossev.commonLib, line 12
  *  Common ZCL Library // library marker kkossev.commonLib, line 13
  * // library marker kkossev.commonLib, line 14
  *  Licensed Virtual the Apache License, Version 2.0 (the "License"); you may not use this file except // library marker kkossev.commonLib, line 15
  *  in compliance with the License. You may obtain a copy of the License at: // library marker kkossev.commonLib, line 16
  * // library marker kkossev.commonLib, line 17
  *      http://www.apache.org/licenses/LICENSE-2.0 // library marker kkossev.commonLib, line 18
  * // library marker kkossev.commonLib, line 19
  *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed // library marker kkossev.commonLib, line 20
  *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License // library marker kkossev.commonLib, line 21
  *  for the specific language governing permissions and limitations under the License. // library marker kkossev.commonLib, line 22
  * // library marker kkossev.commonLib, line 23
  * This library is inspired by @w35l3y work on Tuya device driver (Edge project). // library marker kkossev.commonLib, line 24
  * For a big portions of code all credits go to Jonathan Bradshaw. // library marker kkossev.commonLib, line 25
  * // library marker kkossev.commonLib, line 26
  * // library marker kkossev.commonLib, line 27
  * ver. 1.0.0  2022-06-18 kkossev  - first beta version // library marker kkossev.commonLib, line 28
  * ver. 2.0.0  2023-05-08 kkossev  - first published version 2.x.x // library marker kkossev.commonLib, line 29
  * ver. 2.1.6  2023-11-06 kkossev  - last update on version 2.x.x // library marker kkossev.commonLib, line 30
  * ver. 3.0.0  2023-11-16 kkossev  - (dev.branch) first version 3.x.x // library marker kkossev.commonLib, line 31
  * // library marker kkossev.commonLib, line 32
  *                                   TODO: move zigbeeGroups : {} to dedicated lib // library marker kkossev.commonLib, line 33
  *                                   TODO: disableDefaultResponse for Tuya commands // library marker kkossev.commonLib, line 34
 * // library marker kkossev.commonLib, line 35
*/ // library marker kkossev.commonLib, line 36

def commonLibVersion()   {"3.0.0"} // library marker kkossev.commonLib, line 38
def thermostatLibStamp() {"2023/11/18 11:22 AM"} // library marker kkossev.commonLib, line 39

//@Field static final Boolean _DEBUG = false // library marker kkossev.commonLib, line 41

import groovy.transform.Field // library marker kkossev.commonLib, line 43
import hubitat.device.HubMultiAction // library marker kkossev.commonLib, line 44
import hubitat.device.Protocol // library marker kkossev.commonLib, line 45
import hubitat.helper.HexUtils // library marker kkossev.commonLib, line 46
import hubitat.zigbee.zcl.DataType // library marker kkossev.commonLib, line 47
import java.util.concurrent.ConcurrentHashMap // library marker kkossev.commonLib, line 48
import groovy.json.JsonOutput // library marker kkossev.commonLib, line 49


@Field static final Boolean _THREE_STATE = true // library marker kkossev.commonLib, line 52

metadata { // library marker kkossev.commonLib, line 54

        if (_DEBUG) { // library marker kkossev.commonLib, line 56
            command 'test', [[name: "test", type: "STRING", description: "test", defaultValue : ""]]  // library marker kkossev.commonLib, line 57
            command 'parseTest', [[name: "parseTest", type: "STRING", description: "parseTest", defaultValue : ""]] // library marker kkossev.commonLib, line 58
            command "tuyaTest", [ // library marker kkossev.commonLib, line 59
                [name:"dpCommand", type: "STRING", description: "Tuya DP Command", constraints: ["STRING"]], // library marker kkossev.commonLib, line 60
                [name:"dpValue",   type: "STRING", description: "Tuya DP value", constraints: ["STRING"]], // library marker kkossev.commonLib, line 61
                [name:"dpType",    type: "ENUM",   constraints: ["DP_TYPE_VALUE", "DP_TYPE_BOOL", "DP_TYPE_ENUM"], description: "DP data type"] // library marker kkossev.commonLib, line 62
            ] // library marker kkossev.commonLib, line 63
        } // library marker kkossev.commonLib, line 64


        // common capabilities for all device types // library marker kkossev.commonLib, line 67
        capability 'Configuration' // library marker kkossev.commonLib, line 68
        capability 'Refresh' // library marker kkossev.commonLib, line 69
        capability 'Health Check' // library marker kkossev.commonLib, line 70

        // common attributes for all device types // library marker kkossev.commonLib, line 72
        attribute 'healthStatus', 'enum', ['unknown', 'offline', 'online'] // library marker kkossev.commonLib, line 73
        attribute "rtt", "number"  // library marker kkossev.commonLib, line 74
        attribute "Info", "string" // library marker kkossev.commonLib, line 75

        // common commands for all device types // library marker kkossev.commonLib, line 77
        // removed from version 2.0.6    //command "initialize", [[name: "Manually initialize the device after switching drivers.  \n\r     ***** Will load device default values! *****"]]    // do NOT declare Initialize capability! // library marker kkossev.commonLib, line 78
        command "configure", [[name:"normally it is not needed to configure anything", type: "ENUM",   constraints: ["--- select ---"]+ConfigureOpts.keySet() as List<String>]] // library marker kkossev.commonLib, line 79

        // deviceType specific capabilities, commands and attributes          // library marker kkossev.commonLib, line 81
        if (deviceType in ["Device"]) { // library marker kkossev.commonLib, line 82
            if (_DEBUG) { // library marker kkossev.commonLib, line 83
                command "getAllProperties",       [[name: "Get All Properties"]] // library marker kkossev.commonLib, line 84
            } // library marker kkossev.commonLib, line 85
        } // library marker kkossev.commonLib, line 86
        if (_DEBUG || (deviceType in ["Dimmer", "ButtonDimmer", "Switch", "Valve"])) { // library marker kkossev.commonLib, line 87
            command "zigbeeGroups", [ // library marker kkossev.commonLib, line 88
                [name:"command", type: "ENUM",   constraints: ZigbeeGroupsOpts.options.values() as List<String>], // library marker kkossev.commonLib, line 89
                [name:"value",   type: "STRING", description: "Group number", constraints: ["STRING"]] // library marker kkossev.commonLib, line 90
            ] // library marker kkossev.commonLib, line 91
        }         // library marker kkossev.commonLib, line 92
        if (deviceType in  ["Device", "THSensor", "MotionSensor", "LightSensor", "AirQuality", "Thermostat", "AqaraCube", "Radar"]) { // library marker kkossev.commonLib, line 93
            capability "Sensor" // library marker kkossev.commonLib, line 94
        } // library marker kkossev.commonLib, line 95
        if (deviceType in  ["Device", "MotionSensor", "Radar"]) { // library marker kkossev.commonLib, line 96
            capability "MotionSensor" // library marker kkossev.commonLib, line 97
        } // library marker kkossev.commonLib, line 98
        if (deviceType in  ["Device", "Switch", "Relay", "Plug", "Outlet", "Thermostat", "Fingerbot", "Dimmer", "Bulb", "IRBlaster"]) { // library marker kkossev.commonLib, line 99
            capability "Actuator" // library marker kkossev.commonLib, line 100
        } // library marker kkossev.commonLib, line 101
        if (deviceType in  ["Device", "THSensor", "LightSensor", "MotionSensor", "Thermostat", "Fingerbot", "ButtonDimmer", "AqaraCube", "IRBlaster"]) { // library marker kkossev.commonLib, line 102
            capability "Battery" // library marker kkossev.commonLib, line 103
            attribute "batteryVoltage", "number" // library marker kkossev.commonLib, line 104
        } // library marker kkossev.commonLib, line 105
        if (deviceType in  ["Thermostat"]) { // library marker kkossev.commonLib, line 106
            capability "Thermostat" // library marker kkossev.commonLib, line 107
        } // library marker kkossev.commonLib, line 108
        if (deviceType in  ["Plug", "Outlet"]) { // library marker kkossev.commonLib, line 109
            capability "Outlet" // library marker kkossev.commonLib, line 110
        }         // library marker kkossev.commonLib, line 111
        if (deviceType in  ["Device", "Switch", "Plug", "Outlet", "Dimmer", "Fingerbot", "Bulb"]) { // library marker kkossev.commonLib, line 112
            capability "Switch" // library marker kkossev.commonLib, line 113
            if (_THREE_STATE == true) { // library marker kkossev.commonLib, line 114
                attribute "switch", "enum", SwitchThreeStateOpts.options.values() as List<String> // library marker kkossev.commonLib, line 115
            } // library marker kkossev.commonLib, line 116
        }         // library marker kkossev.commonLib, line 117
        if (deviceType in ["Dimmer", "ButtonDimmer", "Bulb"]) { // library marker kkossev.commonLib, line 118
            capability "SwitchLevel" // library marker kkossev.commonLib, line 119
        } // library marker kkossev.commonLib, line 120
        if (deviceType in  ["Button", "ButtonDimmer", "AqaraCube"]) { // library marker kkossev.commonLib, line 121
            capability "PushableButton" // library marker kkossev.commonLib, line 122
            capability "DoubleTapableButton" // library marker kkossev.commonLib, line 123
            capability "HoldableButton" // library marker kkossev.commonLib, line 124
            capability "ReleasableButton" // library marker kkossev.commonLib, line 125
        } // library marker kkossev.commonLib, line 126
        if (deviceType in  ["Device", "Fingerbot"]) { // library marker kkossev.commonLib, line 127
            capability "Momentary" // library marker kkossev.commonLib, line 128
        } // library marker kkossev.commonLib, line 129
        if (deviceType in  ["Device", "THSensor", "AirQuality", "Thermostat"]) { // library marker kkossev.commonLib, line 130
            capability "TemperatureMeasurement" // library marker kkossev.commonLib, line 131
        } // library marker kkossev.commonLib, line 132
        if (deviceType in  ["Device", "THSensor", "AirQuality"]) { // library marker kkossev.commonLib, line 133
            capability "RelativeHumidityMeasurement"             // library marker kkossev.commonLib, line 134
        } // library marker kkossev.commonLib, line 135
        if (deviceType in  ["Device", "LightSensor", "Radar"]) { // library marker kkossev.commonLib, line 136
            capability "IlluminanceMeasurement" // library marker kkossev.commonLib, line 137
        } // library marker kkossev.commonLib, line 138
        if (deviceType in  ["AirQuality"]) { // library marker kkossev.commonLib, line 139
            capability "AirQuality"            // Attributes: airQualityIndex - NUMBER, range:0..500 // library marker kkossev.commonLib, line 140
        } // library marker kkossev.commonLib, line 141

        // trap for Hubitat F2 bug // library marker kkossev.commonLib, line 143
        fingerprint profileId:"0104", endpointId:"F2", inClusters:"", outClusters:"", model:"unknown", manufacturer:"unknown", deviceJoinName: "Zigbee device affected by Hubitat F2 bug"  // library marker kkossev.commonLib, line 144

    preferences { // library marker kkossev.commonLib, line 146
        input name: 'txtEnable', type: 'bool', title: '<b>Enable descriptionText logging</b>', defaultValue: true, description: '<i>Enables command logging.</i>' // library marker kkossev.commonLib, line 147
        input name: 'logEnable', type: 'bool', title: '<b>Enable debug logging</b>', defaultValue: true, description: '<i>Turns on debug logging for 24 hours.</i>' // library marker kkossev.commonLib, line 148
        if (advancedOptions == true || advancedOptions == false) { // groovy ... // library marker kkossev.commonLib, line 149
            if (device.hasCapability("TemperatureMeasurement") || device.hasCapability("RelativeHumidityMeasurement") || device.hasCapability("IlluminanceMeasurement")) { // library marker kkossev.commonLib, line 150
                input name: "minReportingTime", type: "number", title: "<b>Minimum time between reports</b>", description: "<i>Minimum reporting interval, seconds (1..300)</i>", range: "1..300", defaultValue: DEFAULT_MIN_REPORTING_TIME // library marker kkossev.commonLib, line 151
                input name: "maxReportingTime", type: "number", title: "<b>Maximum time between reports</b>", description: "<i>Maximum reporting interval, seconds (120..10000)</i>", range: "120..10000", defaultValue: DEFAULT_MAX_REPORTING_TIME // library marker kkossev.commonLib, line 152
            } // library marker kkossev.commonLib, line 153
            if (device.hasCapability("IlluminanceMeasurement")) { // library marker kkossev.commonLib, line 154
                input name: "illuminanceThreshold", type: "number", title: "<b>Illuminance Reporting Threshold</b>", description: "<i>Illuminance reporting threshold, range (1..255)<br>Bigger values will result in less frequent reporting</i>", range: "1..255", defaultValue: DEFAULT_ILLUMINANCE_THRESHOLD // library marker kkossev.commonLib, line 155
                input name: "illuminanceCoeff", type: "decimal", title: "<b>Illuminance Correction Coefficient</b>", description: "<i>Illuminance correction coefficient, range (0.10..10.00)</i>", range: "0.10..10.00", defaultValue: 1.00 // library marker kkossev.commonLib, line 156

            } // library marker kkossev.commonLib, line 158
        } // library marker kkossev.commonLib, line 159

        input name: 'advancedOptions', type: 'bool', title: '<b>Advanced Options</b>', description: "<i>These advanced options should be already automatically set in an optimal way for your device...</i>", defaultValue: false // library marker kkossev.commonLib, line 161
        if (advancedOptions == true || advancedOptions == true) { // library marker kkossev.commonLib, line 162
            input name: 'healthCheckMethod', type: 'enum', title: '<b>Healthcheck Method</b>', options: HealthcheckMethodOpts.options, defaultValue: HealthcheckMethodOpts.defaultValue, required: true, description: '<i>Method to check device online/offline status.</i>' // library marker kkossev.commonLib, line 163
            //if (healthCheckMethod != null && safeToInt(healthCheckMethod.value) != 0) { // library marker kkossev.commonLib, line 164
                input name: 'healthCheckInterval', type: 'enum', title: '<b>Healthcheck Interval</b>', options: HealthcheckIntervalOpts.options, defaultValue: HealthcheckIntervalOpts.defaultValue, required: true, description: '<i>How often the hub will check the device health.<br>3 consecutive failures will result in status "offline"</i>' // library marker kkossev.commonLib, line 165
            //} // library marker kkossev.commonLib, line 166
            if (device.hasCapability("Battery")) { // library marker kkossev.commonLib, line 167
                input name: 'voltageToPercent', type: 'bool', title: '<b>Battery Voltage to Percentage</b>', defaultValue: false, description: '<i>Convert battery voltage to battery Percentage remaining.</i>' // library marker kkossev.commonLib, line 168

            } // library marker kkossev.commonLib, line 170
            if ((deviceType in  ["Switch", "Plug", "Dimmer"]) && _THREE_STATE == true) { // library marker kkossev.commonLib, line 171
                input name: 'threeStateEnable', type: 'bool', title: '<b>Enable three-states events</b>', description: '<i>What\'s wrong with the three-state concept?</i>', defaultValue: false // library marker kkossev.commonLib, line 172
            } // library marker kkossev.commonLib, line 173
            input name: 'traceEnable', type: 'bool', title: '<b>Enable trace logging</b>', defaultValue: false, description: '<i>Turns on detailed extra trace logging for 30 minutes.</i>' // library marker kkossev.commonLib, line 174
        } // library marker kkossev.commonLib, line 175
    } // library marker kkossev.commonLib, line 176

} // library marker kkossev.commonLib, line 178


@Field static final Integer DIGITAL_TIMER = 1000             // command was sent by this driver // library marker kkossev.commonLib, line 181
@Field static final Integer REFRESH_TIMER = 5000             // refresh time in miliseconds // library marker kkossev.commonLib, line 182
@Field static final Integer DEBOUNCING_TIMER = 300           // ignore switch events  // library marker kkossev.commonLib, line 183
@Field static final Integer COMMAND_TIMEOUT = 10             // timeout time in seconds // library marker kkossev.commonLib, line 184
@Field static final Integer MAX_PING_MILISECONDS = 10000     // rtt more than 10 seconds will be ignored // library marker kkossev.commonLib, line 185
@Field static final String  UNKNOWN = "UNKNOWN" // library marker kkossev.commonLib, line 186
@Field static final Integer DEFAULT_MIN_REPORTING_TIME = 10  // send the report event no more often than 10 seconds by default // library marker kkossev.commonLib, line 187
@Field static final Integer DEFAULT_MAX_REPORTING_TIME = 3600 // library marker kkossev.commonLib, line 188
@Field static final Integer PRESENCE_COUNT_THRESHOLD = 3     // missing 3 checks will set the device healthStatus to offline // library marker kkossev.commonLib, line 189
@Field static final int DELAY_MS = 200                       // Delay in between zigbee commands // library marker kkossev.commonLib, line 190
@Field static final Integer DEFAULT_ILLUMINANCE_THRESHOLD = 5 // library marker kkossev.commonLib, line 191
@Field static final Integer INFO_AUTO_CLEAR_PERIOD = 30      // automatically clear the Info attribute after 30 seconds // library marker kkossev.commonLib, line 192

@Field static final Map HealthcheckMethodOpts = [            // used by healthCheckMethod // library marker kkossev.commonLib, line 194
    defaultValue: 1, // library marker kkossev.commonLib, line 195
    options     : [0: 'Disabled', 1: 'Activity check', 2: 'Periodic polling'] // library marker kkossev.commonLib, line 196
] // library marker kkossev.commonLib, line 197
@Field static final Map HealthcheckIntervalOpts = [          // used by healthCheckInterval // library marker kkossev.commonLib, line 198
    defaultValue: 240, // library marker kkossev.commonLib, line 199
    options     : [10: 'Every 10 Mins', 30: 'Every 30 Mins', 60: 'Every 1 Hour', 240: 'Every 4 Hours', 720: 'Every 12 Hours'] // library marker kkossev.commonLib, line 200
] // library marker kkossev.commonLib, line 201
@Field static final Map SwitchThreeStateOpts = [ // library marker kkossev.commonLib, line 202
    defaultValue: 0, // library marker kkossev.commonLib, line 203
    options     : [0: 'off', 1: 'on', 2: 'switching_off', 3: 'switching_on', 4: 'switch_failure'] // library marker kkossev.commonLib, line 204
] // library marker kkossev.commonLib, line 205

@Field static final Map ZigbeeGroupsOptsDebug = [ // library marker kkossev.commonLib, line 207
    defaultValue: 0, // library marker kkossev.commonLib, line 208
    options     : [99: '--- select ---', 0: 'Add group', 1: 'View group', 2: 'Get group membership', 3: 'Remove group', 4: 'Remove all groups', 5: 'Add group if identifying'] // library marker kkossev.commonLib, line 209
] // library marker kkossev.commonLib, line 210
@Field static final Map ZigbeeGroupsOpts = [ // library marker kkossev.commonLib, line 211
    defaultValue: 0, // library marker kkossev.commonLib, line 212
    options     : [99: '--- select ---', 0: 'Add group', 2: 'Get group membership', 3: 'Remove group', 4: 'Remove all groups'] // library marker kkossev.commonLib, line 213
] // library marker kkossev.commonLib, line 214

@Field static final Map ConfigureOpts = [ // library marker kkossev.commonLib, line 216
    "Configure the device only"  : [key:2, function: 'configure'], // library marker kkossev.commonLib, line 217
    "Reset Statistics"           : [key:9, function: 'resetStatistics'], // library marker kkossev.commonLib, line 218
    "           --            "  : [key:3, function: 'configureHelp'], // library marker kkossev.commonLib, line 219
    "Delete All Preferences"     : [key:4, function: 'deleteAllSettings'], // library marker kkossev.commonLib, line 220
    "Delete All Current States"  : [key:5, function: 'deleteAllCurrentStates'], // library marker kkossev.commonLib, line 221
    "Delete All Scheduled Jobs"  : [key:6, function: 'deleteAllScheduledJobs'], // library marker kkossev.commonLib, line 222
    "Delete All State Variables" : [key:7, function: 'deleteAllStates'], // library marker kkossev.commonLib, line 223
    "Delete All Child Devices"   : [key:8, function: 'deleteAllChildDevices'], // library marker kkossev.commonLib, line 224
    "           -             "  : [key:1, function: 'configureHelp'], // library marker kkossev.commonLib, line 225
    "*** LOAD ALL DEFAULTS ***"  : [key:0, function: 'loadAllDefaults'] // library marker kkossev.commonLib, line 226
] // library marker kkossev.commonLib, line 227


def isChattyDeviceReport(description)  {return false /*(description?.contains("cluster: FC7E")) */} // library marker kkossev.commonLib, line 230
def isVINDSTYRKA() { (device?.getDataValue('model') ?: 'n/a') in ['VINDSTYRKA'] } // library marker kkossev.commonLib, line 231
def isAqaraTVOC()  { (device?.getDataValue('model') ?: 'n/a') in ['lumi.airmonitor.acn01'] } // library marker kkossev.commonLib, line 232
def isAqaraTRV_OLD()   { (device?.getDataValue('model') ?: 'n/a') in ['lumi.airrtc.agl001'] } // library marker kkossev.commonLib, line 233
def isAqaraFP1()   { (device?.getDataValue('model') ?: 'n/a') in ['lumi.motion.ac01'] } // library marker kkossev.commonLib, line 234
def isFingerbot()  { (device?.getDataValue('manufacturer') ?: 'n/a') in ['_TZ3210_dse8ogfy'] } // library marker kkossev.commonLib, line 235
def isAqaraCube()  { (device?.getDataValue('model') ?: 'n/a') in ['lumi.remote.cagl02'] } // library marker kkossev.commonLib, line 236

/** // library marker kkossev.commonLib, line 238
 * Parse Zigbee message // library marker kkossev.commonLib, line 239
 * @param description Zigbee message in hex format // library marker kkossev.commonLib, line 240
 */ // library marker kkossev.commonLib, line 241
void parse(final String description) { // library marker kkossev.commonLib, line 242
    checkDriverVersion() // library marker kkossev.commonLib, line 243
    if (!isChattyDeviceReport(description)) { logDebug "parse: ${description}" } // library marker kkossev.commonLib, line 244
    if (state.stats != null) state.stats['rxCtr'] = (state.stats['rxCtr'] ?: 0) + 1 else state.stats=[:] // library marker kkossev.commonLib, line 245
    unschedule('deviceCommandTimeout') // library marker kkossev.commonLib, line 246
    setHealthStatusOnline() // library marker kkossev.commonLib, line 247

    if (description?.startsWith('zone status')  || description?.startsWith('zone report')) {     // library marker kkossev.commonLib, line 249
        logDebug "parse: zone status: $description" // library marker kkossev.commonLib, line 250
        if (true /*isHL0SS9OAradar() && _IGNORE_ZCL_REPORTS == true*/) {    // TODO! // library marker kkossev.commonLib, line 251
            logDebug "ignored IAS zone status" // library marker kkossev.commonLib, line 252
            return // library marker kkossev.commonLib, line 253
        } // library marker kkossev.commonLib, line 254
        else { // library marker kkossev.commonLib, line 255
            parseIasMessage(description)    // TODO! // library marker kkossev.commonLib, line 256
        } // library marker kkossev.commonLib, line 257
    } // library marker kkossev.commonLib, line 258
    else if (description?.startsWith('enroll request')) { // library marker kkossev.commonLib, line 259
        logDebug "parse: enroll request: $description" // library marker kkossev.commonLib, line 260
        /* The Zone Enroll Request command is generated when a device embodying the Zone server cluster wishes to be  enrolled as an active  alarm device. It  must do this immediately it has joined the network  (during commissioning). */ // library marker kkossev.commonLib, line 261
        if (settings?.logEnable) logInfo "Sending IAS enroll response..." // library marker kkossev.commonLib, line 262
        ArrayList<String> cmds = zigbee.enrollResponse() + zigbee.readAttribute(0x0500, 0x0000) // library marker kkossev.commonLib, line 263
        logDebug "enroll response: ${cmds}" // library marker kkossev.commonLib, line 264
        sendZigbeeCommands( cmds )   // library marker kkossev.commonLib, line 265
    }  // library marker kkossev.commonLib, line 266
    if (isTuyaE00xCluster(description) == true || otherTuyaOddities(description) == true) { // library marker kkossev.commonLib, line 267
        return // library marker kkossev.commonLib, line 268
    }         // library marker kkossev.commonLib, line 269
    final Map descMap = myParseDescriptionAsMap(description) // library marker kkossev.commonLib, line 270

    if (descMap.profileId == '0000') { // library marker kkossev.commonLib, line 272
        parseZdoClusters(descMap) // library marker kkossev.commonLib, line 273
        return // library marker kkossev.commonLib, line 274
    } // library marker kkossev.commonLib, line 275
    if (descMap.isClusterSpecific == false) { // library marker kkossev.commonLib, line 276
        parseGeneralCommandResponse(descMap) // library marker kkossev.commonLib, line 277
        return // library marker kkossev.commonLib, line 278
    } // library marker kkossev.commonLib, line 279
    if (!isChattyDeviceReport(description)) {logDebug "parse: descMap = ${descMap} description=${description}"} // library marker kkossev.commonLib, line 280
    // // library marker kkossev.commonLib, line 281
    final String clusterName = clusterLookup(descMap.clusterInt) // library marker kkossev.commonLib, line 282
    final String attribute = descMap.attrId ? " attribute 0x${descMap.attrId} (value ${descMap.value})" : '' // library marker kkossev.commonLib, line 283
    //if (settings.logEnable) { log.trace "zigbee received ${clusterName} message" + attribute } // library marker kkossev.commonLib, line 284

    switch (descMap.clusterInt as Integer) { // library marker kkossev.commonLib, line 286
        case zigbee.BASIC_CLUSTER:                          // 0x0000 // library marker kkossev.commonLib, line 287
            parseBasicCluster(descMap) // library marker kkossev.commonLib, line 288
            descMap.remove('additionalAttrs')?.each { final Map map -> parseBasicCluster(descMap + map) } // library marker kkossev.commonLib, line 289
            break // library marker kkossev.commonLib, line 290
        case zigbee.POWER_CONFIGURATION_CLUSTER:            // 0x0001 // library marker kkossev.commonLib, line 291
            parsePowerCluster(descMap) // library marker kkossev.commonLib, line 292
            descMap.remove('additionalAttrs')?.each { final Map map -> parsePowerCluster(descMap + map) } // library marker kkossev.commonLib, line 293
            break // library marker kkossev.commonLib, line 294
        case zigbee.IDENTIFY_CLUSTER:                      // 0x0003 // library marker kkossev.commonLib, line 295
            parseIdentityCluster(descMap) // library marker kkossev.commonLib, line 296
            descMap.remove('additionalAttrs')?.each { final Map map -> parseIdentityCluster(descMap + map) } // library marker kkossev.commonLib, line 297
            break // library marker kkossev.commonLib, line 298
        case zigbee.GROUPS_CLUSTER:                        // 0x0004 // library marker kkossev.commonLib, line 299
            parseGroupsCluster(descMap) // library marker kkossev.commonLib, line 300
            descMap.remove('additionalAttrs')?.each {final Map map -> parseGroupsCluster(descMap + map) } // library marker kkossev.commonLib, line 301
            break // library marker kkossev.commonLib, line 302
        case zigbee.SCENES_CLUSTER:                         // 0x0005 // library marker kkossev.commonLib, line 303
            parseScenesCluster(descMap) // library marker kkossev.commonLib, line 304
            descMap.remove('additionalAttrs')?.each {final Map map -> parseScenesCluster(descMap + map) } // library marker kkossev.commonLib, line 305
            break // library marker kkossev.commonLib, line 306
        case zigbee.ON_OFF_CLUSTER:                         // 0x0006 // library marker kkossev.commonLib, line 307
            parseOnOffCluster(descMap) // library marker kkossev.commonLib, line 308
            descMap.remove('additionalAttrs')?.each { final Map map -> parseOnOffCluster(descMap + map) } // library marker kkossev.commonLib, line 309
            break // library marker kkossev.commonLib, line 310
        case zigbee.LEVEL_CONTROL_CLUSTER:                  // 0x0008 // library marker kkossev.commonLib, line 311
            parseLevelControlCluster(descMap) // library marker kkossev.commonLib, line 312
            descMap.remove('additionalAttrs')?.each { final Map map -> parseLevelControlCluster(descMap + map) } // library marker kkossev.commonLib, line 313
            break // library marker kkossev.commonLib, line 314
        case 0x000C :                                       // Aqara TVOC Air Monitor; Aqara Cube T1 Pro // library marker kkossev.commonLib, line 315
            parseAnalogInputCluster(descMap) // library marker kkossev.commonLib, line 316
            descMap.remove('additionalAttrs')?.each { final Map map -> parseAnalogInputCluster(descMap + map) } // library marker kkossev.commonLib, line 317
            break // library marker kkossev.commonLib, line 318
        case 0x0012 :                                       // Aqara Cube - Multistate Input // library marker kkossev.commonLib, line 319
            parseMultistateInputCluster(descMap) // library marker kkossev.commonLib, line 320
            break // library marker kkossev.commonLib, line 321
         case 0x0102 :                                      // window covering  // library marker kkossev.commonLib, line 322
            parseWindowCoveringCluster(descMap) // library marker kkossev.commonLib, line 323
            break        // library marker kkossev.commonLib, line 324
        case 0x0201 :                                       // Aqara E1 TRV  // library marker kkossev.commonLib, line 325
            parseThermostatCluster(descMap) // library marker kkossev.commonLib, line 326
            descMap.remove('additionalAttrs')?.each { final Map map -> parseThermostatCluster(descMap + map) } // library marker kkossev.commonLib, line 327
            break // library marker kkossev.commonLib, line 328
        case 0x0300 :                                       // Aqara LED Strip T1 // library marker kkossev.commonLib, line 329
            parseColorControlCluster(descMap, description) // library marker kkossev.commonLib, line 330
            descMap.remove('additionalAttrs')?.each { final Map map -> parseColorControlCluster(descMap + map, description) } // library marker kkossev.commonLib, line 331
            break // library marker kkossev.commonLib, line 332
        case zigbee.ILLUMINANCE_MEASUREMENT_CLUSTER :       //0x0400 // library marker kkossev.commonLib, line 333
            parseIlluminanceCluster(descMap) // library marker kkossev.commonLib, line 334
            descMap.remove('additionalAttrs')?.each { final Map map -> parseIlluminanceCluster(descMap + map) } // library marker kkossev.commonLib, line 335
            break // library marker kkossev.commonLib, line 336
        case zigbee.TEMPERATURE_MEASUREMENT_CLUSTER :       //0x0402 // library marker kkossev.commonLib, line 337
            parseTemperatureCluster(descMap) // library marker kkossev.commonLib, line 338
            break // library marker kkossev.commonLib, line 339
        case zigbee.RELATIVE_HUMIDITY_MEASUREMENT_CLUSTER : //0x0405 // library marker kkossev.commonLib, line 340
            parseHumidityCluster(descMap) // library marker kkossev.commonLib, line 341
            break // library marker kkossev.commonLib, line 342
        case 0x042A :                                       // pm2.5 // library marker kkossev.commonLib, line 343
            parsePm25Cluster(descMap) // library marker kkossev.commonLib, line 344
            break // library marker kkossev.commonLib, line 345
        case zigbee.ELECTRICAL_MEASUREMENT_CLUSTER: // library marker kkossev.commonLib, line 346
            parseElectricalMeasureCluster(descMap) // library marker kkossev.commonLib, line 347
            descMap.remove('additionalAttrs')?.each { final Map map -> parseElectricalMeasureCluster(descMap + map) } // library marker kkossev.commonLib, line 348
            break // library marker kkossev.commonLib, line 349
        case zigbee.METERING_CLUSTER: // library marker kkossev.commonLib, line 350
            parseMeteringCluster(descMap) // library marker kkossev.commonLib, line 351
            descMap.remove('additionalAttrs')?.each { final Map map -> parseMeteringCluster(descMap + map) } // library marker kkossev.commonLib, line 352
            break // library marker kkossev.commonLib, line 353
        case 0xE002 : // library marker kkossev.commonLib, line 354
            parseE002Cluster(descMap) // library marker kkossev.commonLib, line 355
            descMap.remove('additionalAttrs')?.each { final Map map -> parseE002Cluster(descMap + map) } // library marker kkossev.commonLib, line 356
            break // library marker kkossev.commonLib, line 357
        case 0xEF00 :                                       // Tuya famous cluster // library marker kkossev.commonLib, line 358
            parseTuyaCluster(descMap) // library marker kkossev.commonLib, line 359
            descMap.remove('additionalAttrs')?.each { final Map map -> parseTuyaCluster(descMap + map) } // library marker kkossev.commonLib, line 360
            break // library marker kkossev.commonLib, line 361
        case 0xfc7e :                                       // tVOC 'Sensirion VOC index' https://sensirion.com/media/documents/02232963/6294E043/Info_Note_VOC_Index.pdf // library marker kkossev.commonLib, line 362
            parseAirQualityIndexCluster(descMap) // library marker kkossev.commonLib, line 363
            break // library marker kkossev.commonLib, line 364
        case 0xFCC0 :                                       // XIAOMI_CLUSTER_ID Xiaomi cluster // library marker kkossev.commonLib, line 365
            parseXiaomiCluster(descMap) // library marker kkossev.commonLib, line 366
            descMap.remove('additionalAttrs')?.each { final Map m -> parseXiaomiCluster(descMap + m) } // library marker kkossev.commonLib, line 367
            break // library marker kkossev.commonLib, line 368
        default: // library marker kkossev.commonLib, line 369
            if (settings.logEnable) { // library marker kkossev.commonLib, line 370
                logWarn "zigbee received <b>unknown cluster:${descMap.clusterId}</b> message (${descMap})" // library marker kkossev.commonLib, line 371
            } // library marker kkossev.commonLib, line 372
            break // library marker kkossev.commonLib, line 373
    } // library marker kkossev.commonLib, line 374

} // library marker kkossev.commonLib, line 376

/** // library marker kkossev.commonLib, line 378
 * ZDO (Zigbee Data Object) Clusters Parsing // library marker kkossev.commonLib, line 379
 * @param descMap Zigbee message in parsed map format // library marker kkossev.commonLib, line 380
 */ // library marker kkossev.commonLib, line 381
void parseZdoClusters(final Map descMap) { // library marker kkossev.commonLib, line 382
    final Integer clusterId = descMap.clusterInt as Integer // library marker kkossev.commonLib, line 383
    final String clusterName = ZdoClusterEnum[clusterId] ?: "UNKNOWN_CLUSTER (0x${descMap.clusterId})" // library marker kkossev.commonLib, line 384
    final String statusHex = ((List)descMap.data)[1] // library marker kkossev.commonLib, line 385
    final Integer statusCode = hexStrToUnsignedInt(statusHex) // library marker kkossev.commonLib, line 386
    final String statusName = ZigbeeStatusEnum[statusCode] ?: "0x${statusHex}" // library marker kkossev.commonLib, line 387
    if (statusCode > 0x00) { // library marker kkossev.commonLib, line 388
        logWarn "parseZdoClusters: ZDO ${clusterName} error: ${statusName} (statusCode: 0x${statusHex})" // library marker kkossev.commonLib, line 389
    }  // library marker kkossev.commonLib, line 390
    else { // library marker kkossev.commonLib, line 391
        logDebug "parseZdoClusters: ZDO ${clusterName} success: ${descMap.data}" // library marker kkossev.commonLib, line 392
    } // library marker kkossev.commonLib, line 393
} // library marker kkossev.commonLib, line 394

/** // library marker kkossev.commonLib, line 396
 * Zigbee General Command Parsing // library marker kkossev.commonLib, line 397
 * @param descMap Zigbee message in parsed map format // library marker kkossev.commonLib, line 398
 */ // library marker kkossev.commonLib, line 399
void parseGeneralCommandResponse(final Map descMap) { // library marker kkossev.commonLib, line 400
    final int commandId = hexStrToUnsignedInt(descMap.command) // library marker kkossev.commonLib, line 401
    switch (commandId) { // library marker kkossev.commonLib, line 402
        case 0x01: // read attribute response // library marker kkossev.commonLib, line 403
            parseReadAttributeResponse(descMap) // library marker kkossev.commonLib, line 404
            break // library marker kkossev.commonLib, line 405
        case 0x04: // write attribute response // library marker kkossev.commonLib, line 406
            parseWriteAttributeResponse(descMap) // library marker kkossev.commonLib, line 407
            break // library marker kkossev.commonLib, line 408
        case 0x07: // configure reporting response // library marker kkossev.commonLib, line 409
            parseConfigureResponse(descMap) // library marker kkossev.commonLib, line 410
            break // library marker kkossev.commonLib, line 411
        case 0x09: // read reporting configuration response // library marker kkossev.commonLib, line 412
            parseReadReportingConfigResponse(descMap) // library marker kkossev.commonLib, line 413
            break // library marker kkossev.commonLib, line 414
        case 0x0B: // default command response // library marker kkossev.commonLib, line 415
            parseDefaultCommandResponse(descMap) // library marker kkossev.commonLib, line 416
            break // library marker kkossev.commonLib, line 417
        default: // library marker kkossev.commonLib, line 418
            final String commandName = ZigbeeGeneralCommandEnum[commandId] ?: "UNKNOWN_COMMAND (0x${descMap.command})" // library marker kkossev.commonLib, line 419
            final String clusterName = clusterLookup(descMap.clusterInt) // library marker kkossev.commonLib, line 420
            final String status = descMap.data in List ? ((List)descMap.data).last() : descMap.data // library marker kkossev.commonLib, line 421
            final int statusCode = hexStrToUnsignedInt(status) // library marker kkossev.commonLib, line 422
            final String statusName = ZigbeeStatusEnum[statusCode] ?: "0x${status}" // library marker kkossev.commonLib, line 423
            if (statusCode > 0x00) { // library marker kkossev.commonLib, line 424
                log.warn "zigbee ${commandName} ${clusterName} error: ${statusName}" // library marker kkossev.commonLib, line 425
            } else if (settings.logEnable) { // library marker kkossev.commonLib, line 426
                log.trace "zigbee ${commandName} ${clusterName}: ${descMap.data}" // library marker kkossev.commonLib, line 427
            } // library marker kkossev.commonLib, line 428
            break // library marker kkossev.commonLib, line 429
    } // library marker kkossev.commonLib, line 430
} // library marker kkossev.commonLib, line 431

/** // library marker kkossev.commonLib, line 433
 * Zigbee Read Attribute Response Parsing // library marker kkossev.commonLib, line 434
 * @param descMap Zigbee message in parsed map format // library marker kkossev.commonLib, line 435
 */ // library marker kkossev.commonLib, line 436
void parseReadAttributeResponse(final Map descMap) { // library marker kkossev.commonLib, line 437
    final List<String> data = descMap.data as List<String> // library marker kkossev.commonLib, line 438
    final String attribute = data[1] + data[0] // library marker kkossev.commonLib, line 439
    final int statusCode = hexStrToUnsignedInt(data[2]) // library marker kkossev.commonLib, line 440
    final String status = ZigbeeStatusEnum[statusCode] ?: "0x${data}" // library marker kkossev.commonLib, line 441
    if (statusCode > 0x00) { // library marker kkossev.commonLib, line 442
        logWarn "zigbee read ${clusterLookup(descMap.clusterInt)} attribute 0x${attribute} error: ${status}" // library marker kkossev.commonLib, line 443
    } // library marker kkossev.commonLib, line 444
    else { // library marker kkossev.commonLib, line 445
        logDebug "zigbee read ${clusterLookup(descMap.clusterInt)} attribute 0x${attribute} response: ${status} ${data}" // library marker kkossev.commonLib, line 446
    } // library marker kkossev.commonLib, line 447
} // library marker kkossev.commonLib, line 448

/** // library marker kkossev.commonLib, line 450
 * Zigbee Write Attribute Response Parsing // library marker kkossev.commonLib, line 451
 * @param descMap Zigbee message in parsed map format // library marker kkossev.commonLib, line 452
 */ // library marker kkossev.commonLib, line 453
void parseWriteAttributeResponse(final Map descMap) { // library marker kkossev.commonLib, line 454
    final String data = descMap.data in List ? ((List)descMap.data).first() : descMap.data // library marker kkossev.commonLib, line 455
    final int statusCode = hexStrToUnsignedInt(data) // library marker kkossev.commonLib, line 456
    final String statusName = ZigbeeStatusEnum[statusCode] ?: "0x${data}" // library marker kkossev.commonLib, line 457
    if (statusCode > 0x00) { // library marker kkossev.commonLib, line 458
        logWarn "zigbee response write ${clusterLookup(descMap.clusterInt)} attribute error: ${statusName}" // library marker kkossev.commonLib, line 459
    } // library marker kkossev.commonLib, line 460
    else { // library marker kkossev.commonLib, line 461
        logDebug "zigbee response write ${clusterLookup(descMap.clusterInt)} attribute response: ${statusName}" // library marker kkossev.commonLib, line 462
    } // library marker kkossev.commonLib, line 463
} // library marker kkossev.commonLib, line 464

/** // library marker kkossev.commonLib, line 466
 * Zigbee Configure Reporting Response Parsing // library marker kkossev.commonLib, line 467
 * @param descMap Zigbee message in parsed map format // library marker kkossev.commonLib, line 468
 */ // library marker kkossev.commonLib, line 469

void parseConfigureResponse(final Map descMap) { // library marker kkossev.commonLib, line 471
    // TODO - parse the details of the configuration respose - cluster, min, max, delta ... // library marker kkossev.commonLib, line 472
    final String status = ((List)descMap.data).first() // library marker kkossev.commonLib, line 473
    final int statusCode = hexStrToUnsignedInt(status) // library marker kkossev.commonLib, line 474
    if (statusCode == 0x00 && settings.enableReporting != false) { // library marker kkossev.commonLib, line 475
        state.reportingEnabled = true // library marker kkossev.commonLib, line 476
    } // library marker kkossev.commonLib, line 477
    final String statusName = ZigbeeStatusEnum[statusCode] ?: "0x${status}" // library marker kkossev.commonLib, line 478
    if (statusCode > 0x00) { // library marker kkossev.commonLib, line 479
        log.warn "zigbee configure reporting error: ${statusName} ${descMap.data}" // library marker kkossev.commonLib, line 480
    } else { // library marker kkossev.commonLib, line 481
        logDebug "zigbee configure reporting response: ${statusName} ${descMap.data}" // library marker kkossev.commonLib, line 482
    } // library marker kkossev.commonLib, line 483
} // library marker kkossev.commonLib, line 484

/** // library marker kkossev.commonLib, line 486
 * Zigbee Default Command Response Parsing // library marker kkossev.commonLib, line 487
 * @param descMap Zigbee message in parsed map format // library marker kkossev.commonLib, line 488
 */ // library marker kkossev.commonLib, line 489
void parseDefaultCommandResponse(final Map descMap) { // library marker kkossev.commonLib, line 490
    final List<String> data = descMap.data as List<String> // library marker kkossev.commonLib, line 491
    final String commandId = data[0] // library marker kkossev.commonLib, line 492
    final int statusCode = hexStrToUnsignedInt(data[1]) // library marker kkossev.commonLib, line 493
    final String status = ZigbeeStatusEnum[statusCode] ?: "0x${data[1]}" // library marker kkossev.commonLib, line 494
    if (statusCode > 0x00) { // library marker kkossev.commonLib, line 495
        logWarn "zigbee ${clusterLookup(descMap.clusterInt)} command 0x${commandId} error: ${status}" // library marker kkossev.commonLib, line 496
    } else { // library marker kkossev.commonLib, line 497
        logDebug "zigbee ${clusterLookup(descMap.clusterInt)} command 0x${commandId} response: ${status}" // library marker kkossev.commonLib, line 498
    } // library marker kkossev.commonLib, line 499
} // library marker kkossev.commonLib, line 500


// Zigbee Attribute IDs // library marker kkossev.commonLib, line 503
@Field static final int AC_CURRENT_DIVISOR_ID = 0x0603 // library marker kkossev.commonLib, line 504
@Field static final int AC_CURRENT_MULTIPLIER_ID = 0x0602 // library marker kkossev.commonLib, line 505
@Field static final int AC_FREQUENCY_ID = 0x0300 // library marker kkossev.commonLib, line 506
@Field static final int AC_POWER_DIVISOR_ID = 0x0605 // library marker kkossev.commonLib, line 507
@Field static final int AC_POWER_MULTIPLIER_ID = 0x0604 // library marker kkossev.commonLib, line 508
@Field static final int AC_VOLTAGE_DIVISOR_ID = 0x0601 // library marker kkossev.commonLib, line 509
@Field static final int AC_VOLTAGE_MULTIPLIER_ID = 0x0600 // library marker kkossev.commonLib, line 510
@Field static final int ACTIVE_POWER_ID = 0x050B // library marker kkossev.commonLib, line 511
@Field static final int ATTRIBUTE_READING_INFO_SET = 0x0000 // library marker kkossev.commonLib, line 512
@Field static final int FIRMWARE_VERSION_ID = 0x4000 // library marker kkossev.commonLib, line 513
@Field static final int PING_ATTR_ID = 0x01 // library marker kkossev.commonLib, line 514
@Field static final int POWER_ON_OFF_ID = 0x0000 // library marker kkossev.commonLib, line 515
@Field static final int POWER_RESTORE_ID = 0x4003 // library marker kkossev.commonLib, line 516
@Field static final int RMS_CURRENT_ID = 0x0508 // library marker kkossev.commonLib, line 517
@Field static final int RMS_VOLTAGE_ID = 0x0505 // library marker kkossev.commonLib, line 518

@Field static final Map<Integer, String> ZigbeeStatusEnum = [ // library marker kkossev.commonLib, line 520
    0x00: 'Success', // library marker kkossev.commonLib, line 521
    0x01: 'Failure', // library marker kkossev.commonLib, line 522
    0x02: 'Not Authorized', // library marker kkossev.commonLib, line 523
    0x80: 'Malformed Command', // library marker kkossev.commonLib, line 524
    0x81: 'Unsupported COMMAND', // library marker kkossev.commonLib, line 525
    0x85: 'Invalid Field', // library marker kkossev.commonLib, line 526
    0x86: 'Unsupported Attribute', // library marker kkossev.commonLib, line 527
    0x87: 'Invalid Value', // library marker kkossev.commonLib, line 528
    0x88: 'Read Only', // library marker kkossev.commonLib, line 529
    0x89: 'Insufficient Space', // library marker kkossev.commonLib, line 530
    0x8A: 'Duplicate Exists', // library marker kkossev.commonLib, line 531
    0x8B: 'Not Found', // library marker kkossev.commonLib, line 532
    0x8C: 'Unreportable Attribute', // library marker kkossev.commonLib, line 533
    0x8D: 'Invalid Data Type', // library marker kkossev.commonLib, line 534
    0x8E: 'Invalid Selector', // library marker kkossev.commonLib, line 535
    0x94: 'Time out', // library marker kkossev.commonLib, line 536
    0x9A: 'Notification Pending', // library marker kkossev.commonLib, line 537
    0xC3: 'Unsupported Cluster' // library marker kkossev.commonLib, line 538
] // library marker kkossev.commonLib, line 539

@Field static final Map<Integer, String> ZdoClusterEnum = [ // library marker kkossev.commonLib, line 541
    0x0002: 'Node Descriptor Request', // library marker kkossev.commonLib, line 542
    0x0005: 'Active Endpoints Request', // library marker kkossev.commonLib, line 543
    0x0006: 'Match Descriptor Request', // library marker kkossev.commonLib, line 544
    0x0022: 'Unbind Request', // library marker kkossev.commonLib, line 545
    0x0013: 'Device announce', // library marker kkossev.commonLib, line 546
    0x0034: 'Management Leave Request', // library marker kkossev.commonLib, line 547
    0x8002: 'Node Descriptor Response', // library marker kkossev.commonLib, line 548
    0x8004: 'Simple Descriptor Response', // library marker kkossev.commonLib, line 549
    0x8005: 'Active Endpoints Response', // library marker kkossev.commonLib, line 550
    0x801D: 'Extended Simple Descriptor Response', // library marker kkossev.commonLib, line 551
    0x801E: 'Extended Active Endpoint Response', // library marker kkossev.commonLib, line 552
    0x8021: 'Bind Response', // library marker kkossev.commonLib, line 553
    0x8022: 'Unbind Response', // library marker kkossev.commonLib, line 554
    0x8023: 'Bind Register Response', // library marker kkossev.commonLib, line 555
    0x8034: 'Management Leave Response' // library marker kkossev.commonLib, line 556
] // library marker kkossev.commonLib, line 557

@Field static final Map<Integer, String> ZigbeeGeneralCommandEnum = [ // library marker kkossev.commonLib, line 559
    0x00: 'Read Attributes', // library marker kkossev.commonLib, line 560
    0x01: 'Read Attributes Response', // library marker kkossev.commonLib, line 561
    0x02: 'Write Attributes', // library marker kkossev.commonLib, line 562
    0x03: 'Write Attributes Undivided', // library marker kkossev.commonLib, line 563
    0x04: 'Write Attributes Response', // library marker kkossev.commonLib, line 564
    0x05: 'Write Attributes No Response', // library marker kkossev.commonLib, line 565
    0x06: 'Configure Reporting', // library marker kkossev.commonLib, line 566
    0x07: 'Configure Reporting Response', // library marker kkossev.commonLib, line 567
    0x08: 'Read Reporting Configuration', // library marker kkossev.commonLib, line 568
    0x09: 'Read Reporting Configuration Response', // library marker kkossev.commonLib, line 569
    0x0A: 'Report Attributes', // library marker kkossev.commonLib, line 570
    0x0B: 'Default Response', // library marker kkossev.commonLib, line 571
    0x0C: 'Discover Attributes', // library marker kkossev.commonLib, line 572
    0x0D: 'Discover Attributes Response', // library marker kkossev.commonLib, line 573
    0x0E: 'Read Attributes Structured', // library marker kkossev.commonLib, line 574
    0x0F: 'Write Attributes Structured', // library marker kkossev.commonLib, line 575
    0x10: 'Write Attributes Structured Response', // library marker kkossev.commonLib, line 576
    0x11: 'Discover Commands Received', // library marker kkossev.commonLib, line 577
    0x12: 'Discover Commands Received Response', // library marker kkossev.commonLib, line 578
    0x13: 'Discover Commands Generated', // library marker kkossev.commonLib, line 579
    0x14: 'Discover Commands Generated Response', // library marker kkossev.commonLib, line 580
    0x15: 'Discover Attributes Extended', // library marker kkossev.commonLib, line 581
    0x16: 'Discover Attributes Extended Response' // library marker kkossev.commonLib, line 582
] // library marker kkossev.commonLib, line 583


/* // library marker kkossev.commonLib, line 586
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 587
 * Xiaomi cluster 0xFCC0 parser. // library marker kkossev.commonLib, line 588
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 589
 */ // library marker kkossev.commonLib, line 590
void parseXiaomiCluster(final Map descMap) { // library marker kkossev.commonLib, line 591
    if (xiaomiLibVersion() != null) { // library marker kkossev.commonLib, line 592
        parseXiaomiClusterLib(descMap) // library marker kkossev.commonLib, line 593
    }     // library marker kkossev.commonLib, line 594
    else { // library marker kkossev.commonLib, line 595
        logWarn "Xiaomi cluster 0xFCC0" // library marker kkossev.commonLib, line 596
    } // library marker kkossev.commonLib, line 597
} // library marker kkossev.commonLib, line 598


/* // library marker kkossev.commonLib, line 601
@Field static final int XIAOMI_CLUSTER_ID = 0xFCC0 // library marker kkossev.commonLib, line 602

// Zigbee Attributes // library marker kkossev.commonLib, line 604
@Field static final int DIRECTION_MODE_ATTR_ID = 0x0144 // library marker kkossev.commonLib, line 605
@Field static final int MODEL_ATTR_ID = 0x05 // library marker kkossev.commonLib, line 606
@Field static final int PRESENCE_ACTIONS_ATTR_ID = 0x0143 // library marker kkossev.commonLib, line 607
@Field static final int PRESENCE_ATTR_ID = 0x0142 // library marker kkossev.commonLib, line 608
@Field static final int REGION_EVENT_ATTR_ID = 0x0151 // library marker kkossev.commonLib, line 609
@Field static final int RESET_PRESENCE_ATTR_ID = 0x0157 // library marker kkossev.commonLib, line 610
@Field static final int SENSITIVITY_LEVEL_ATTR_ID = 0x010C // library marker kkossev.commonLib, line 611
@Field static final int SET_EDGE_REGION_ATTR_ID = 0x0156 // library marker kkossev.commonLib, line 612
@Field static final int SET_EXIT_REGION_ATTR_ID = 0x0153 // library marker kkossev.commonLib, line 613
@Field static final int SET_INTERFERENCE_ATTR_ID = 0x0154 // library marker kkossev.commonLib, line 614
@Field static final int SET_REGION_ATTR_ID = 0x0150 // library marker kkossev.commonLib, line 615
@Field static final int TRIGGER_DISTANCE_ATTR_ID = 0x0146 // library marker kkossev.commonLib, line 616
@Field static final int XIAOMI_RAW_ATTR_ID = 0xFFF2 // library marker kkossev.commonLib, line 617
@Field static final int XIAOMI_SPECIAL_REPORT_ID = 0x00F7 // library marker kkossev.commonLib, line 618
@Field static final Map MFG_CODE = [ mfgCode: 0x115F ] // library marker kkossev.commonLib, line 619

// Xiaomi Tags // library marker kkossev.commonLib, line 621
@Field static final int DIRECTION_MODE_TAG_ID = 0x67 // library marker kkossev.commonLib, line 622
@Field static final int SENSITIVITY_LEVEL_TAG_ID = 0x66 // library marker kkossev.commonLib, line 623
@Field static final int SWBUILD_TAG_ID = 0x08 // library marker kkossev.commonLib, line 624
@Field static final int TRIGGER_DISTANCE_TAG_ID = 0x69 // library marker kkossev.commonLib, line 625
@Field static final int PRESENCE_ACTIONS_TAG_ID = 0x66 // library marker kkossev.commonLib, line 626
@Field static final int PRESENCE_TAG_ID = 0x65 // library marker kkossev.commonLib, line 627
*/ // library marker kkossev.commonLib, line 628


// TODO - move to xiaomiLib // library marker kkossev.commonLib, line 631
// TODO - move to thermostatLib // library marker kkossev.commonLib, line 632
// TODO - move to aqaraQubeLib // library marker kkossev.commonLib, line 633




@Field static final int ROLLING_AVERAGE_N = 10 // library marker kkossev.commonLib, line 638
double approxRollingAverage (double avg, double new_sample) { // library marker kkossev.commonLib, line 639
    if (avg == null || avg == 0) { avg = new_sample} // library marker kkossev.commonLib, line 640
    avg -= avg / ROLLING_AVERAGE_N // library marker kkossev.commonLib, line 641
    avg += new_sample / ROLLING_AVERAGE_N // library marker kkossev.commonLib, line 642
    // TOSO: try Method II : New average = old average * (n-1)/n + new value /n // library marker kkossev.commonLib, line 643
    return avg // library marker kkossev.commonLib, line 644
} // library marker kkossev.commonLib, line 645

/* // library marker kkossev.commonLib, line 647
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 648
 * Standard clusters reporting handlers // library marker kkossev.commonLib, line 649
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 650
*/ // library marker kkossev.commonLib, line 651
@Field static final Map powerSourceOpts =  [ defaultValue: 0, options: [0: 'unknown', 1: 'mains', 2: 'mains', 3: 'battery', 4: 'dc', 5: 'emergency mains', 6: 'emergency mains']] // library marker kkossev.commonLib, line 652

/** // library marker kkossev.commonLib, line 654
 * Zigbee Basic Cluster Parsing  0x0000 // library marker kkossev.commonLib, line 655
 * @param descMap Zigbee message in parsed map format // library marker kkossev.commonLib, line 656
 */ // library marker kkossev.commonLib, line 657
void parseBasicCluster(final Map descMap) { // library marker kkossev.commonLib, line 658
    def now = new Date().getTime() // library marker kkossev.commonLib, line 659
    if (state.lastRx == null) { state.lastRx = [:] } // library marker kkossev.commonLib, line 660
    if (state.lastTx == null) { state.lastTx = [:] } // library marker kkossev.commonLib, line 661
    if (state.states == null) { state.states = [:] } // library marker kkossev.commonLib, line 662
    if (state.stats == null) { state.stats = [:] } // library marker kkossev.commonLib, line 663
    state.lastRx["checkInTime"] = now // library marker kkossev.commonLib, line 664
    switch (descMap.attrInt as Integer) { // library marker kkossev.commonLib, line 665
        case 0x0000: // library marker kkossev.commonLib, line 666
            logDebug "Basic cluster: ZCLVersion = ${descMap?.value}" // library marker kkossev.commonLib, line 667
            break // library marker kkossev.commonLib, line 668
        case PING_ATTR_ID: // 0x01 - Using 0x01 read as a simple ping/pong mechanism // library marker kkossev.commonLib, line 669
            boolean isPing = state.states["isPing"] ?: false // library marker kkossev.commonLib, line 670
            if (isPing) { // library marker kkossev.commonLib, line 671
                def timeRunning = now.toInteger() - (state.lastTx["pingTime"] ?: '0').toInteger() // library marker kkossev.commonLib, line 672
                if (timeRunning > 0 && timeRunning < MAX_PING_MILISECONDS) { // library marker kkossev.commonLib, line 673
                    state.stats['pingsOK'] = (state.stats['pingsOK'] ?: 0) + 1 // library marker kkossev.commonLib, line 674
                    if (timeRunning < safeToInt((state.stats['pingsMin'] ?: '999'))) { state.stats['pingsMin'] = timeRunning } // library marker kkossev.commonLib, line 675
                    if (timeRunning > safeToInt((state.stats['pingsMax'] ?: '0')))   { state.stats['pingsMax'] = timeRunning } // library marker kkossev.commonLib, line 676
                    state.stats['pingsAvg'] = approxRollingAverage(safeToDouble(state.stats['pingsAvg']),safeToDouble(timeRunning)) as int // library marker kkossev.commonLib, line 677
                    sendRttEvent() // library marker kkossev.commonLib, line 678
                } // library marker kkossev.commonLib, line 679
                else { // library marker kkossev.commonLib, line 680
                    logWarn "unexpected ping timeRunning=${timeRunning} " // library marker kkossev.commonLib, line 681
                } // library marker kkossev.commonLib, line 682
                state.states["isPing"] = false // library marker kkossev.commonLib, line 683
            } // library marker kkossev.commonLib, line 684
            else { // library marker kkossev.commonLib, line 685
                logDebug "Tuya check-in message (attribute ${descMap.attrId} reported: ${descMap.value})" // library marker kkossev.commonLib, line 686
            } // library marker kkossev.commonLib, line 687
            break // library marker kkossev.commonLib, line 688
        case 0x0004: // library marker kkossev.commonLib, line 689
            logDebug "received device manufacturer ${descMap?.value}" // library marker kkossev.commonLib, line 690
            // received device manufacturer IKEA of Sweden // library marker kkossev.commonLib, line 691
            def manufacturer = device.getDataValue("manufacturer") // library marker kkossev.commonLib, line 692
            if ((manufacturer == null || manufacturer == "unknown") && (descMap?.value != null) ) { // library marker kkossev.commonLib, line 693
                logWarn "updating device manufacturer from ${manufacturer} to ${descMap?.value}" // library marker kkossev.commonLib, line 694
                device.updateDataValue("manufacturer", descMap?.value) // library marker kkossev.commonLib, line 695
            } // library marker kkossev.commonLib, line 696
            break // library marker kkossev.commonLib, line 697
        case 0x0005: // library marker kkossev.commonLib, line 698
            logDebug "received device model ${descMap?.value}" // library marker kkossev.commonLib, line 699
            // received device model Remote Control N2 // library marker kkossev.commonLib, line 700
            def model = device.getDataValue("model") // library marker kkossev.commonLib, line 701
            if ((model == null || model == "unknown") && (descMap?.value != null) ) { // library marker kkossev.commonLib, line 702
                logWarn "updating device model from ${model} to ${descMap?.value}" // library marker kkossev.commonLib, line 703
                device.updateDataValue("model", descMap?.value) // library marker kkossev.commonLib, line 704
            } // library marker kkossev.commonLib, line 705
            break // library marker kkossev.commonLib, line 706
        case 0x0007: // library marker kkossev.commonLib, line 707
            def powerSourceReported = powerSourceOpts.options[descMap?.value as int] // library marker kkossev.commonLib, line 708
            logDebug "received Power source <b>${powerSourceReported}</b> (${descMap?.value})" // library marker kkossev.commonLib, line 709
            //powerSourceEvent( powerSourceReported ) // library marker kkossev.commonLib, line 710
            break // library marker kkossev.commonLib, line 711
        case 0xFFDF: // library marker kkossev.commonLib, line 712
            logDebug "Tuya check-in (Cluster Revision=${descMap?.value})" // library marker kkossev.commonLib, line 713
            break // library marker kkossev.commonLib, line 714
        case 0xFFE2: // library marker kkossev.commonLib, line 715
            logDebug "Tuya check-in (AppVersion=${descMap?.value})" // library marker kkossev.commonLib, line 716
            break // library marker kkossev.commonLib, line 717
        case [0xFFE0, 0xFFE1, 0xFFE3, 0xFFE4] : // library marker kkossev.commonLib, line 718
            logDebug "Tuya unknown attribute ${descMap?.attrId} value=${descMap?.value}" // library marker kkossev.commonLib, line 719
            break // library marker kkossev.commonLib, line 720
        case 0xFFFE: // library marker kkossev.commonLib, line 721
            logDebug "Tuya attributeReportingStatus (attribute FFFE) value=${descMap?.value}" // library marker kkossev.commonLib, line 722
            break // library marker kkossev.commonLib, line 723
        case FIRMWARE_VERSION_ID:    // 0x4000 // library marker kkossev.commonLib, line 724
            final String version = descMap.value ?: 'unknown' // library marker kkossev.commonLib, line 725
            log.info "device firmware version is ${version}" // library marker kkossev.commonLib, line 726
            updateDataValue('softwareBuild', version) // library marker kkossev.commonLib, line 727
            break // library marker kkossev.commonLib, line 728
        default: // library marker kkossev.commonLib, line 729
            logWarn "zigbee received unknown Basic cluster attribute 0x${descMap.attrId} (value ${descMap.value})" // library marker kkossev.commonLib, line 730
            break // library marker kkossev.commonLib, line 731
    } // library marker kkossev.commonLib, line 732
} // library marker kkossev.commonLib, line 733

/* // library marker kkossev.commonLib, line 735
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 736
 * power cluster            0x0001 // library marker kkossev.commonLib, line 737
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 738
*/ // library marker kkossev.commonLib, line 739
void parsePowerCluster(final Map descMap) { // library marker kkossev.commonLib, line 740
    if (state.lastRx == null) { state.lastRx = [:] } // library marker kkossev.commonLib, line 741
    if (descMap.value == null || descMap.value == 'FFFF') { return } // invalid or unknown value // library marker kkossev.commonLib, line 742
    if (descMap.attrId in ["0020", "0021"]) { // library marker kkossev.commonLib, line 743
        state.lastRx["batteryTime"] = new Date().getTime() // library marker kkossev.commonLib, line 744
        state.stats["battCtr"] = (state.stats["battCtr"] ?: 0 ) + 1 // library marker kkossev.commonLib, line 745
    } // library marker kkossev.commonLib, line 746

    final long rawValue = hexStrToUnsignedInt(descMap.value) // library marker kkossev.commonLib, line 748
    if (descMap.attrId == "0020") { // library marker kkossev.commonLib, line 749
        sendBatteryVoltageEvent(rawValue) // library marker kkossev.commonLib, line 750
        if ((settings.voltageToPercent ?: false) == true) { // library marker kkossev.commonLib, line 751
            sendBatteryVoltageEvent(rawValue, convertToPercent=true) // library marker kkossev.commonLib, line 752
        } // library marker kkossev.commonLib, line 753
    } // library marker kkossev.commonLib, line 754
    else if (descMap.attrId == "0021") { // library marker kkossev.commonLib, line 755
        sendBatteryPercentageEvent(rawValue * 2)     // library marker kkossev.commonLib, line 756
    } // library marker kkossev.commonLib, line 757
    else { // library marker kkossev.commonLib, line 758
        logWarn "zigbee received unknown Power cluster attribute 0x${descMap.attrId} (value ${descMap.value})" // library marker kkossev.commonLib, line 759
    } // library marker kkossev.commonLib, line 760
} // library marker kkossev.commonLib, line 761

def sendBatteryVoltageEvent(rawValue, Boolean convertToPercent=false) { // library marker kkossev.commonLib, line 763
    logDebug "batteryVoltage = ${(double)rawValue / 10.0} V" // library marker kkossev.commonLib, line 764
    def result = [:] // library marker kkossev.commonLib, line 765
    def volts = rawValue / 10 // library marker kkossev.commonLib, line 766
    if (!(rawValue == 0 || rawValue == 255)) { // library marker kkossev.commonLib, line 767
        def minVolts = 2.2 // library marker kkossev.commonLib, line 768
        def maxVolts = 3.2 // library marker kkossev.commonLib, line 769
        def pct = (volts - minVolts) / (maxVolts - minVolts) // library marker kkossev.commonLib, line 770
        def roundedPct = Math.round(pct * 100) // library marker kkossev.commonLib, line 771
        if (roundedPct <= 0) roundedPct = 1 // library marker kkossev.commonLib, line 772
        if (roundedPct >100) roundedPct = 100 // library marker kkossev.commonLib, line 773
        if (convertToPercent == true) { // library marker kkossev.commonLib, line 774
            result.value = Math.min(100, roundedPct) // library marker kkossev.commonLib, line 775
            result.name = 'battery' // library marker kkossev.commonLib, line 776
            result.unit  = '%' // library marker kkossev.commonLib, line 777
            result.descriptionText = "battery is ${roundedPct} %" // library marker kkossev.commonLib, line 778
        } // library marker kkossev.commonLib, line 779
        else { // library marker kkossev.commonLib, line 780
            result.value = volts // library marker kkossev.commonLib, line 781
            result.name = 'batteryVoltage' // library marker kkossev.commonLib, line 782
            result.unit  = 'V' // library marker kkossev.commonLib, line 783
            result.descriptionText = "battery is ${volts} Volts" // library marker kkossev.commonLib, line 784
        } // library marker kkossev.commonLib, line 785
        result.type = 'physical' // library marker kkossev.commonLib, line 786
        result.isStateChange = true // library marker kkossev.commonLib, line 787
        logInfo "${result.descriptionText}" // library marker kkossev.commonLib, line 788
        sendEvent(result) // library marker kkossev.commonLib, line 789
    } // library marker kkossev.commonLib, line 790
    else { // library marker kkossev.commonLib, line 791
        logWarn "ignoring BatteryResult(${rawValue})" // library marker kkossev.commonLib, line 792
    }     // library marker kkossev.commonLib, line 793
} // library marker kkossev.commonLib, line 794

def sendBatteryPercentageEvent( batteryPercent, isDigital=false ) { // library marker kkossev.commonLib, line 796
    if ((batteryPercent as int) == 255) { // library marker kkossev.commonLib, line 797
        logWarn "ignoring battery report raw=${batteryPercent}" // library marker kkossev.commonLib, line 798
        return // library marker kkossev.commonLib, line 799
    } // library marker kkossev.commonLib, line 800
    def map = [:] // library marker kkossev.commonLib, line 801
    map.name = 'battery' // library marker kkossev.commonLib, line 802
    map.timeStamp = now() // library marker kkossev.commonLib, line 803
    map.value = batteryPercent < 0 ? 0 : batteryPercent > 100 ? 100 : (batteryPercent as int) // library marker kkossev.commonLib, line 804
    map.unit  = '%' // library marker kkossev.commonLib, line 805
    map.type = isDigital ? 'digital' : 'physical'     // library marker kkossev.commonLib, line 806
    map.descriptionText = "${map.name} is ${map.value} ${map.unit}" // library marker kkossev.commonLib, line 807
    map.isStateChange = true // library marker kkossev.commonLib, line 808
    //  // library marker kkossev.commonLib, line 809
    def latestBatteryEvent = device.latestState('battery', skipCache=true) // library marker kkossev.commonLib, line 810
    def latestBatteryEventTime = latestBatteryEvent != null ? latestBatteryEvent.getDate().getTime() : now() // library marker kkossev.commonLib, line 811
    //log.debug "battery latest state timeStamp is ${latestBatteryTime} now is ${now()}" // library marker kkossev.commonLib, line 812
    def timeDiff = ((now() - latestBatteryEventTime) / 1000) as int // library marker kkossev.commonLib, line 813
    if (settings?.batteryDelay == null || (settings?.batteryDelay as int) == 0 || timeDiff > (settings?.batteryDelay as int)) { // library marker kkossev.commonLib, line 814
        // send it now! // library marker kkossev.commonLib, line 815
        sendDelayedBatteryPercentageEvent(map) // library marker kkossev.commonLib, line 816
    } // library marker kkossev.commonLib, line 817
    else { // library marker kkossev.commonLib, line 818
        def delayedTime = (settings?.batteryDelay as int) - timeDiff // library marker kkossev.commonLib, line 819
        map.delayed = delayedTime // library marker kkossev.commonLib, line 820
        map.descriptionText += " [delayed ${map.delayed} seconds]" // library marker kkossev.commonLib, line 821
        logDebug "this  battery event (${map.value}%) will be delayed ${delayedTime} seconds" // library marker kkossev.commonLib, line 822
        runIn( delayedTime, 'sendDelayedBatteryEvent', [overwrite: true, data: map]) // library marker kkossev.commonLib, line 823
    } // library marker kkossev.commonLib, line 824
} // library marker kkossev.commonLib, line 825

private void sendDelayedBatteryPercentageEvent(Map map) { // library marker kkossev.commonLib, line 827
    logInfo "${map.descriptionText}" // library marker kkossev.commonLib, line 828
    //map.each {log.trace "$it"} // library marker kkossev.commonLib, line 829
    sendEvent(map) // library marker kkossev.commonLib, line 830
} // library marker kkossev.commonLib, line 831

private void sendDelayedBatteryVoltageEvent(Map map) { // library marker kkossev.commonLib, line 833
    logInfo "${map.descriptionText}" // library marker kkossev.commonLib, line 834
    //map.each {log.trace "$it"} // library marker kkossev.commonLib, line 835
    sendEvent(map) // library marker kkossev.commonLib, line 836
} // library marker kkossev.commonLib, line 837


/* // library marker kkossev.commonLib, line 840
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 841
 * Zigbee Identity Cluster 0x0003 // library marker kkossev.commonLib, line 842
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 843
*/ // library marker kkossev.commonLib, line 844

void parseIdentityCluster(final Map descMap) { // library marker kkossev.commonLib, line 846
    logDebug "unprocessed parseIdentityCluster" // library marker kkossev.commonLib, line 847
} // library marker kkossev.commonLib, line 848



/* // library marker kkossev.commonLib, line 852
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 853
 * Zigbee Scenes Cluster 0x005 // library marker kkossev.commonLib, line 854
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 855
*/ // library marker kkossev.commonLib, line 856

void parseScenesCluster(final Map descMap) { // library marker kkossev.commonLib, line 858
    if (DEVICE_TYPE in ["ButtonDimmer"]) { // library marker kkossev.commonLib, line 859
        parseScenesClusterButtonDimmer(descMap) // library marker kkossev.commonLib, line 860
    }     // library marker kkossev.commonLib, line 861
    else { // library marker kkossev.commonLib, line 862
        logWarn "unprocessed ScenesCluste attribute ${descMap.attrId}" // library marker kkossev.commonLib, line 863
    } // library marker kkossev.commonLib, line 864
} // library marker kkossev.commonLib, line 865


/* // library marker kkossev.commonLib, line 868
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 869
 * Zigbee Groups Cluster Parsing 0x004    ZigbeeGroupsOpts // library marker kkossev.commonLib, line 870
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 871
*/ // library marker kkossev.commonLib, line 872

void parseGroupsCluster(final Map descMap) { // library marker kkossev.commonLib, line 874
    // :catchall: 0104 0004 01 01 0040 00 F396 01 00 0000 00 01 00C005, profileId:0104, clusterId:0004, clusterInt:4, sourceEndpoint:01, destinationEndpoint:01, options:0040, messageType:00, dni:F396, isClusterSpecific:true, isManufacturerSpecific:false, manufacturerId:0000, command:00, direction:01, data:[00, C0, 05]] // library marker kkossev.commonLib, line 875
    logDebug "parseGroupsCluster: command=${descMap.command} data=${descMap.data}" // library marker kkossev.commonLib, line 876
    if (state.zigbeeGroups == null) state.zigbeeGroups = [:]     // library marker kkossev.commonLib, line 877
    switch (descMap.command as Integer) { // library marker kkossev.commonLib, line 878
        case 0x00: // Add group    0x0001 – 0xfff7 // library marker kkossev.commonLib, line 879
            final List<String> data = descMap.data as List<String> // library marker kkossev.commonLib, line 880
            final int statusCode = hexStrToUnsignedInt(data[0]) // library marker kkossev.commonLib, line 881
            final String statusName = ZigbeeStatusEnum[statusCode] ?: "0x${data[0]}" // library marker kkossev.commonLib, line 882
            final String groupId = data[2] + data[1] // library marker kkossev.commonLib, line 883
            final int groupIdInt = hexStrToUnsignedInt(groupId) // library marker kkossev.commonLib, line 884
            if (statusCode > 0x00) { // library marker kkossev.commonLib, line 885
                logWarn "received zigbee GROUPS cluster response for command: ${descMap.command} \'${ZigbeeGroupsOpts.options[descMap.command as int]}\' : groupId 0x${groupId} (${groupIdInt}) <b>error: ${statusName}</b>" // library marker kkossev.commonLib, line 886
            } // library marker kkossev.commonLib, line 887
            else { // library marker kkossev.commonLib, line 888
                logDebug "received zigbee GROUPS cluster response for command: ${descMap.command} \'${ZigbeeGroupsOpts.options[descMap.command as int]}\' : groupId 0x${groupId} (${groupIdInt}) statusCode: ${statusName}" // library marker kkossev.commonLib, line 889
                // add the group to state.zigbeeGroups['groups'] if not exist // library marker kkossev.commonLib, line 890
                int groupCount = state.zigbeeGroups['groups'].size() // library marker kkossev.commonLib, line 891
                for (int i=0; i<groupCount; i++ ) { // library marker kkossev.commonLib, line 892
                    if (safeToInt(state.zigbeeGroups['groups'][i]) == groupIdInt) { // library marker kkossev.commonLib, line 893
                        logDebug "Zigbee group ${groupIdInt} (0x${groupId}) already exist" // library marker kkossev.commonLib, line 894
                        return // library marker kkossev.commonLib, line 895
                    } // library marker kkossev.commonLib, line 896
                } // library marker kkossev.commonLib, line 897
                state.zigbeeGroups['groups'].add(groupIdInt) // library marker kkossev.commonLib, line 898
                logInfo "Zigbee group added new group ${groupIdInt} (0x${zigbee.convertToHexString(groupIdInt,4)})" // library marker kkossev.commonLib, line 899
                state.zigbeeGroups['groups'].sort() // library marker kkossev.commonLib, line 900
            } // library marker kkossev.commonLib, line 901
            break // library marker kkossev.commonLib, line 902
        case 0x01: // View group // library marker kkossev.commonLib, line 903
            // The view group command allows the sending device to request that the receiving entity or entities respond with a view group response command containing the application name string for a particular group. // library marker kkossev.commonLib, line 904
            logDebug "received View group GROUPS cluster command: ${descMap.command} (${descMap})" // library marker kkossev.commonLib, line 905
            final List<String> data = descMap.data as List<String> // library marker kkossev.commonLib, line 906
            final int statusCode = hexStrToUnsignedInt(data[0]) // library marker kkossev.commonLib, line 907
            final String statusName = ZigbeeStatusEnum[statusCode] ?: "0x${data[0]}" // library marker kkossev.commonLib, line 908
            final String groupId = data[2] + data[1] // library marker kkossev.commonLib, line 909
            final int groupIdInt = hexStrToUnsignedInt(groupId) // library marker kkossev.commonLib, line 910
            if (statusCode > 0x00) { // library marker kkossev.commonLib, line 911
                logWarn "zigbee response View group ${groupIdInt} (0x${groupId}) error: ${statusName}" // library marker kkossev.commonLib, line 912
            } // library marker kkossev.commonLib, line 913
            else { // library marker kkossev.commonLib, line 914
                logInfo "received zigbee GROUPS cluster response for command: ${descMap.command} \'${ZigbeeGroupsOpts.options[descMap.command as int]}\' : groupId ${groupIdInt} (0x${groupId})  statusCode: ${statusName}" // library marker kkossev.commonLib, line 915
            } // library marker kkossev.commonLib, line 916
            break // library marker kkossev.commonLib, line 917
        case 0x02: // Get group membership // library marker kkossev.commonLib, line 918
            final List<String> data = descMap.data as List<String> // library marker kkossev.commonLib, line 919
            final int capacity = hexStrToUnsignedInt(data[0]) // library marker kkossev.commonLib, line 920
            final int groupCount = hexStrToUnsignedInt(data[1]) // library marker kkossev.commonLib, line 921
            final Set<String> groups = [] // library marker kkossev.commonLib, line 922
            for (int i = 0; i < groupCount; i++) { // library marker kkossev.commonLib, line 923
                int pos = (i * 2) + 2 // library marker kkossev.commonLib, line 924
                String group = data[pos + 1] + data[pos] // library marker kkossev.commonLib, line 925
                groups.add(hexStrToUnsignedInt(group)) // library marker kkossev.commonLib, line 926
            } // library marker kkossev.commonLib, line 927
            state.zigbeeGroups['groups'] = groups // library marker kkossev.commonLib, line 928
            state.zigbeeGroups['capacity'] = capacity // library marker kkossev.commonLib, line 929
            logInfo "received zigbee GROUPS cluster response for command: ${descMap.command} \'${ZigbeeGroupsOpts.options[descMap.command as int]}\' : groups ${groups} groupCount: ${groupCount} capacity: ${capacity}" // library marker kkossev.commonLib, line 930
            break // library marker kkossev.commonLib, line 931
        case 0x03: // Remove group // library marker kkossev.commonLib, line 932
            logInfo "received  Remove group GROUPS cluster command: ${descMap.command} (${descMap})" // library marker kkossev.commonLib, line 933
            final List<String> data = descMap.data as List<String> // library marker kkossev.commonLib, line 934
            final int statusCode = hexStrToUnsignedInt(data[0]) // library marker kkossev.commonLib, line 935
            final String statusName = ZigbeeStatusEnum[statusCode] ?: "0x${data[0]}" // library marker kkossev.commonLib, line 936
            final String groupId = data[2] + data[1] // library marker kkossev.commonLib, line 937
            final int groupIdInt = hexStrToUnsignedInt(groupId) // library marker kkossev.commonLib, line 938
            if (statusCode > 0x00) { // library marker kkossev.commonLib, line 939
                logWarn "zigbee response remove group ${groupIdInt} (0x${groupId}) error: ${statusName}" // library marker kkossev.commonLib, line 940
            } // library marker kkossev.commonLib, line 941
            else { // library marker kkossev.commonLib, line 942
                logDebug "received zigbee GROUPS cluster response for command: ${descMap.command} \'${ZigbeeGroupsOpts.options[descMap.command as int]}\' : groupId ${groupIdInt} (0x${groupId})  statusCode: ${statusName}" // library marker kkossev.commonLib, line 943
            } // library marker kkossev.commonLib, line 944
            // remove it from the states, even if status code was 'Not Found' // library marker kkossev.commonLib, line 945
            def index = state.zigbeeGroups['groups'].indexOf(groupIdInt) // library marker kkossev.commonLib, line 946
            if (index >= 0) { // library marker kkossev.commonLib, line 947
                state.zigbeeGroups['groups'].remove(index) // library marker kkossev.commonLib, line 948
                logDebug "Zigbee group ${groupIdInt} (0x${groupId}) removed" // library marker kkossev.commonLib, line 949
            } // library marker kkossev.commonLib, line 950
            break // library marker kkossev.commonLib, line 951
        case 0x04: //Remove all groups // library marker kkossev.commonLib, line 952
            logInfo "received zigbee GROUPS cluster response for command: ${descMap.command} \'${ZigbeeGroupsOpts.options[descMap.command as int]}\' : groupId 0x${groupId} statusCode: ${statusName}" // library marker kkossev.commonLib, line 953
            logWarn "not implemented!" // library marker kkossev.commonLib, line 954
            break // library marker kkossev.commonLib, line 955
        case 0x05: // Add group if identifying // library marker kkossev.commonLib, line 956
            //  add group membership in a particular group for one or more endpoints on the receiving device, on condition that it is identifying itself. Identifying functionality is controlled using the identify cluster, (see 3.5).  // library marker kkossev.commonLib, line 957
            logInfo "received zigbee GROUPS cluster response for command: ${descMap.command} \'${ZigbeeGroupsOpts.options[descMap.command as int]}\' : groupId 0x${groupId} statusCode: ${statusName}" // library marker kkossev.commonLib, line 958
            logWarn "not implemented!" // library marker kkossev.commonLib, line 959
            break // library marker kkossev.commonLib, line 960
        default: // library marker kkossev.commonLib, line 961
            logWarn "received unknown GROUPS cluster command: ${descMap.command} (${descMap})" // library marker kkossev.commonLib, line 962
            break // library marker kkossev.commonLib, line 963
    } // library marker kkossev.commonLib, line 964
} // library marker kkossev.commonLib, line 965

List<String> addGroupMembership(groupNr) { // library marker kkossev.commonLib, line 967
    List<String> cmds = [] // library marker kkossev.commonLib, line 968
    final Integer group = safeToInt(groupNr) // library marker kkossev.commonLib, line 969
    if (group < 1 || group > 0xFFF7) { // library marker kkossev.commonLib, line 970
        logWarn "addGroupMembership: invalid group ${groupNr}" // library marker kkossev.commonLib, line 971
        return // library marker kkossev.commonLib, line 972
    } // library marker kkossev.commonLib, line 973
    final String groupHex = DataType.pack(group, DataType.UINT16, true) // library marker kkossev.commonLib, line 974
    cmds += zigbee.command(zigbee.GROUPS_CLUSTER, 0x00, [:], DELAY_MS, "${groupHex} 00") // library marker kkossev.commonLib, line 975
    logDebug "addGroupMembership: adding group ${group} to ${state.zigbeeGroups['groups']} cmds=${cmds}" // library marker kkossev.commonLib, line 976
    return cmds // library marker kkossev.commonLib, line 977
} // library marker kkossev.commonLib, line 978

List<String> viewGroupMembership(groupNr) { // library marker kkossev.commonLib, line 980
    List<String> cmds = [] // library marker kkossev.commonLib, line 981
    final Integer group = safeToInt(groupNr) // library marker kkossev.commonLib, line 982
    final String groupHex = DataType.pack(group, DataType.UINT16, true) // library marker kkossev.commonLib, line 983
    cmds += zigbee.command(zigbee.GROUPS_CLUSTER, 0x01, [:], DELAY_MS, "${groupHex} 00") // library marker kkossev.commonLib, line 984
    logDebug "viewGroupMembership: zigbeeGroups is ${state.zigbeeGroups['groups']} cmds=${cmds}" // library marker kkossev.commonLib, line 985
    return cmds // library marker kkossev.commonLib, line 986
} // library marker kkossev.commonLib, line 987

List<String> getGroupMembership(dummy) { // library marker kkossev.commonLib, line 989
    List<String> cmds = [] // library marker kkossev.commonLib, line 990
    cmds += zigbee.command(zigbee.GROUPS_CLUSTER, 0x02, [:], DELAY_MS, "00") // library marker kkossev.commonLib, line 991
    logDebug "getGroupMembership: zigbeeGroups is ${state.zigbeeGroups['groups']} cmds=${cmds}" // library marker kkossev.commonLib, line 992
    return cmds // library marker kkossev.commonLib, line 993
} // library marker kkossev.commonLib, line 994

List<String> removeGroupMembership(groupNr) { // library marker kkossev.commonLib, line 996
    List<String> cmds = [] // library marker kkossev.commonLib, line 997
    final Integer group = safeToInt(groupNr) // library marker kkossev.commonLib, line 998
    if (group < 1 || group > 0xFFF7) { // library marker kkossev.commonLib, line 999
        logWarn "removeGroupMembership: invalid group ${groupNr}" // library marker kkossev.commonLib, line 1000
        return // library marker kkossev.commonLib, line 1001
    } // library marker kkossev.commonLib, line 1002
    final String groupHex = DataType.pack(group, DataType.UINT16, true) // library marker kkossev.commonLib, line 1003
    cmds += zigbee.command(zigbee.GROUPS_CLUSTER, 0x03, [:], DELAY_MS, "${groupHex} 00") // library marker kkossev.commonLib, line 1004
    logDebug "removeGroupMembership: deleting group ${group} from ${state.zigbeeGroups['groups']} cmds=${cmds}" // library marker kkossev.commonLib, line 1005
    return cmds // library marker kkossev.commonLib, line 1006
} // library marker kkossev.commonLib, line 1007

List<String> removeAllGroups(groupNr) { // library marker kkossev.commonLib, line 1009
    List<String> cmds = [] // library marker kkossev.commonLib, line 1010
    final Integer group = safeToInt(groupNr) // library marker kkossev.commonLib, line 1011
    final String groupHex = DataType.pack(group, DataType.UINT16, true) // library marker kkossev.commonLib, line 1012
    cmds += zigbee.command(zigbee.GROUPS_CLUSTER, 0x04, [:], DELAY_MS, "${groupHex} 00") // library marker kkossev.commonLib, line 1013
    logDebug "removeAllGroups: zigbeeGroups is ${state.zigbeeGroups['groups']} cmds=${cmds}" // library marker kkossev.commonLib, line 1014
    return cmds // library marker kkossev.commonLib, line 1015
} // library marker kkossev.commonLib, line 1016

List<String> notImplementedGroups(groupNr) { // library marker kkossev.commonLib, line 1018
    List<String> cmds = [] // library marker kkossev.commonLib, line 1019
    final Integer group = safeToInt(groupNr) // library marker kkossev.commonLib, line 1020
    final String groupHex = DataType.pack(group, DataType.UINT16, true) // library marker kkossev.commonLib, line 1021
    logWarn "notImplementedGroups: zigbeeGroups is ${state.zigbeeGroups['groups']} cmds=${cmds}" // library marker kkossev.commonLib, line 1022
    return cmds // library marker kkossev.commonLib, line 1023
} // library marker kkossev.commonLib, line 1024

@Field static final Map GroupCommandsMap = [ // library marker kkossev.commonLib, line 1026
    "--- select ---"           : [ min: null, max: null,   type: 'none',   defaultValue: 99, function: 'GroupCommandsHelp'], // library marker kkossev.commonLib, line 1027
    "Add group"                : [ min: 1,    max: 0xFFF7, type: 'number', defaultValue: 0,  function: 'addGroupMembership'], // library marker kkossev.commonLib, line 1028
    "View group"               : [ min: 0,    max: 0xFFF7, type: 'number', defaultValue: 1,  function: 'viewGroupMembership'], // library marker kkossev.commonLib, line 1029
    "Get group membership"     : [ min: null, max: null,   type: 'none',   defaultValue: 2,  function: 'getGroupMembership'], // library marker kkossev.commonLib, line 1030
    "Remove group"             : [ min: 0,    max: 0xFFF7, type: 'number', defaultValue: 3,  function: 'removeGroupMembership'], // library marker kkossev.commonLib, line 1031
    "Remove all groups"        : [ min: null, max: null,   type: 'none',   defaultValue: 4,  function: 'removeAllGroups'], // library marker kkossev.commonLib, line 1032
    "Add group if identifying" : [ min: 1,    max: 0xFFF7, type: 'number', defaultValue: 5,  function: 'notImplementedGroups'] // library marker kkossev.commonLib, line 1033
] // library marker kkossev.commonLib, line 1034
/* // library marker kkossev.commonLib, line 1035
@Field static final Map ZigbeeGroupsOpts = [ // library marker kkossev.commonLib, line 1036
    defaultValue: 0, // library marker kkossev.commonLib, line 1037
    options     : [99: '--- select ---', 0: 'Add group', 1: 'View group', 2: 'Get group membership', 3: 'Remove group', 4: 'Remove all groups', 5: 'Add group if identifying'] // library marker kkossev.commonLib, line 1038
] // library marker kkossev.commonLib, line 1039
*/ // library marker kkossev.commonLib, line 1040

def zigbeeGroups( command=null, par=null ) // library marker kkossev.commonLib, line 1042
{ // library marker kkossev.commonLib, line 1043
    logInfo "executing command \'${command}\', parameter ${par}" // library marker kkossev.commonLib, line 1044
    ArrayList<String> cmds = [] // library marker kkossev.commonLib, line 1045
    if (state.zigbeeGroups == null) state.zigbeeGroups = [:] // library marker kkossev.commonLib, line 1046
    if (state.zigbeeGroups['groups'] == null) state.zigbeeGroups['groups'] = [] // library marker kkossev.commonLib, line 1047
    def value // library marker kkossev.commonLib, line 1048
    Boolean validated = false // library marker kkossev.commonLib, line 1049
    if (command == null || !(command in (GroupCommandsMap.keySet() as List))) { // library marker kkossev.commonLib, line 1050
        logWarn "zigbeeGroups: command <b>${command}</b> must be one of these : ${GroupCommandsMap.keySet() as List}" // library marker kkossev.commonLib, line 1051
        return // library marker kkossev.commonLib, line 1052
    } // library marker kkossev.commonLib, line 1053
    value = GroupCommandsMap[command]?.type == "number" ? safeToInt(par, -1) : 0 // library marker kkossev.commonLib, line 1054
    if (GroupCommandsMap[command]?.type == 'none' || (value >= GroupCommandsMap[command]?.min && value <= GroupCommandsMap[command]?.max)) validated = true // library marker kkossev.commonLib, line 1055
    if (validated == false && GroupCommandsMap[command]?.min != null && GroupCommandsMap[command]?.max != null) { // library marker kkossev.commonLib, line 1056
        log.warn "zigbeeGroups: command <b>command</b> parameter <b>${par}</b> must be within ${GroupCommandsMap[command]?.min} and  ${GroupCommandsMap[command]?.max} " // library marker kkossev.commonLib, line 1057
        return // library marker kkossev.commonLib, line 1058
    } // library marker kkossev.commonLib, line 1059
    // // library marker kkossev.commonLib, line 1060
    def func // library marker kkossev.commonLib, line 1061
   // try { // library marker kkossev.commonLib, line 1062
        func = GroupCommandsMap[command]?.function // library marker kkossev.commonLib, line 1063
        def type = GroupCommandsMap[command]?.type // library marker kkossev.commonLib, line 1064
        // device.updateSetting("$par", [value:value, type:type])  // TODO !!! // library marker kkossev.commonLib, line 1065
        cmds = "$func"(value) // library marker kkossev.commonLib, line 1066
 //   } // library marker kkossev.commonLib, line 1067
//    catch (e) { // library marker kkossev.commonLib, line 1068
//        logWarn "Exception ${e} caught while processing <b>$func</b>(<b>$value</b>)" // library marker kkossev.commonLib, line 1069
//        return // library marker kkossev.commonLib, line 1070
//    } // library marker kkossev.commonLib, line 1071

    logDebug "executed <b>$func</b>(<b>$value</b>)" // library marker kkossev.commonLib, line 1073
    sendZigbeeCommands( cmds ) // library marker kkossev.commonLib, line 1074
} // library marker kkossev.commonLib, line 1075

def GroupCommandsHelp( val ) { // library marker kkossev.commonLib, line 1077
    logWarn "GroupCommands: select one of the commands in this list!"              // library marker kkossev.commonLib, line 1078
} // library marker kkossev.commonLib, line 1079

/* // library marker kkossev.commonLib, line 1081
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 1082
 * on/off cluster            0x0006 // library marker kkossev.commonLib, line 1083
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 1084
*/ // library marker kkossev.commonLib, line 1085

void parseOnOffCluster(final Map descMap) { // library marker kkossev.commonLib, line 1087
    if (state.lastRx == null) { state.lastRx = [:] } // library marker kkossev.commonLib, line 1088
    if (DEVICE_TYPE in ["ButtonDimmer"]) { // library marker kkossev.commonLib, line 1089
        parseOnOffClusterButtonDimmer(descMap) // library marker kkossev.commonLib, line 1090
    }     // library marker kkossev.commonLib, line 1091

    else if (descMap.attrId == "0000") { // library marker kkossev.commonLib, line 1093
        if (descMap.value == null || descMap.value == 'FFFF') { logDebug "parseOnOffCluster: invalid value: ${descMap.value}"; return } // invalid or unknown value // library marker kkossev.commonLib, line 1094
        final long rawValue = hexStrToUnsignedInt(descMap.value) // library marker kkossev.commonLib, line 1095
        sendSwitchEvent(rawValue) // library marker kkossev.commonLib, line 1096
    } // library marker kkossev.commonLib, line 1097
    else if (descMap.attrId in ["4000", "4001", "4002", "4004", "8000", "8001", "8002", "8003"]) { // library marker kkossev.commonLib, line 1098
        parseOnOffAttributes(descMap) // library marker kkossev.commonLib, line 1099
    } // library marker kkossev.commonLib, line 1100
    else { // library marker kkossev.commonLib, line 1101
        logWarn "unprocessed OnOffCluster attribute ${descMap.attrId}" // library marker kkossev.commonLib, line 1102
    } // library marker kkossev.commonLib, line 1103
} // library marker kkossev.commonLib, line 1104

def clearIsDigital()        { state.states["isDigital"] = false } // library marker kkossev.commonLib, line 1106
def switchDebouncingClear() { state.states["debounce"]  = false } // library marker kkossev.commonLib, line 1107
def isRefreshRequestClear() { state.states["isRefresh"] = false } // library marker kkossev.commonLib, line 1108

def toggle() { // library marker kkossev.commonLib, line 1110
    def descriptionText = "central button switch is " // library marker kkossev.commonLib, line 1111
    def state = "" // library marker kkossev.commonLib, line 1112
    if ((device.currentState('switch')?.value ?: 'n/a') == 'off' ) { // library marker kkossev.commonLib, line 1113
        state = "on" // library marker kkossev.commonLib, line 1114
    } // library marker kkossev.commonLib, line 1115
    else { // library marker kkossev.commonLib, line 1116
        state = "off" // library marker kkossev.commonLib, line 1117
    } // library marker kkossev.commonLib, line 1118
    descriptionText += state // library marker kkossev.commonLib, line 1119
    sendEvent(name: "switch", value: state, descriptionText: descriptionText, type: "physical", isStateChange: true) // library marker kkossev.commonLib, line 1120
    logInfo "${descriptionText}" // library marker kkossev.commonLib, line 1121
} // library marker kkossev.commonLib, line 1122

def off() { // library marker kkossev.commonLib, line 1124
    if (DEVICE_TYPE in ["Thermostat"]) { thermostatOff(); return } // library marker kkossev.commonLib, line 1125
    if ((settings?.alwaysOn ?: false) == true) { // library marker kkossev.commonLib, line 1126
        logWarn "AlwaysOn option for ${device.displayName} is enabled , the command to switch it OFF is ignored!" // library marker kkossev.commonLib, line 1127
        return // library marker kkossev.commonLib, line 1128
    } // library marker kkossev.commonLib, line 1129
    if (state.states == null) { state.states = [:] } // library marker kkossev.commonLib, line 1130
    state.states["isDigital"] = true // library marker kkossev.commonLib, line 1131
    logDebug "Switching ${device.displayName} Off" // library marker kkossev.commonLib, line 1132
    def cmds = zigbee.off() // library marker kkossev.commonLib, line 1133
    /* // library marker kkossev.commonLib, line 1134
    if (device.getDataValue("model") == "HY0105") { // library marker kkossev.commonLib, line 1135
        cmds += zigbee.command(0x0006, 0x00, "", [destEndpoint: 0x02]) // library marker kkossev.commonLib, line 1136
    } // library marker kkossev.commonLib, line 1137
        else if (state.model == "TS0601") { // library marker kkossev.commonLib, line 1138
            if (isDinRail() || isRTXCircuitBreaker()) { // library marker kkossev.commonLib, line 1139
                cmds = sendTuyaCommand("10", DP_TYPE_BOOL, "00") // library marker kkossev.commonLib, line 1140
            } // library marker kkossev.commonLib, line 1141
            else { // library marker kkossev.commonLib, line 1142
                cmds = zigbee.command(0xEF00, 0x0, "00010101000100") // library marker kkossev.commonLib, line 1143
            } // library marker kkossev.commonLib, line 1144
        } // library marker kkossev.commonLib, line 1145
        else if (isHEProblematic()) { // library marker kkossev.commonLib, line 1146
            cmds = ["he cmd 0x${device.deviceNetworkId}  0x01 0x0006 0 {}","delay 200"] // library marker kkossev.commonLib, line 1147
            logWarn "isHEProblematic() : sending off() : ${cmds}" // library marker kkossev.commonLib, line 1148
        } // library marker kkossev.commonLib, line 1149
        else if (device.endpointId == "F2") { // library marker kkossev.commonLib, line 1150
            cmds = ["he cmd 0x${device.deviceNetworkId} 0x01 0x0006 0 {}","delay 200"] // library marker kkossev.commonLib, line 1151
        } // library marker kkossev.commonLib, line 1152
*/ // library marker kkossev.commonLib, line 1153
    if (_THREE_STATE == true && settings?.threeStateEnable == true) { // library marker kkossev.commonLib, line 1154
        if ((device.currentState('switch')?.value ?: 'n/a') == 'off' ) { // library marker kkossev.commonLib, line 1155
            runIn(1, 'refresh',  [overwrite: true]) // library marker kkossev.commonLib, line 1156
        } // library marker kkossev.commonLib, line 1157
        def value = SwitchThreeStateOpts.options[2]    // 'switching_on' // library marker kkossev.commonLib, line 1158
        def descriptionText = "${value} (2)" // library marker kkossev.commonLib, line 1159
        sendEvent(name: "switch", value: value, descriptionText: descriptionText, type: "digital", isStateChange: true) // library marker kkossev.commonLib, line 1160
        logInfo "${descriptionText}" // library marker kkossev.commonLib, line 1161
    } // library marker kkossev.commonLib, line 1162
    else { // library marker kkossev.commonLib, line 1163
        logWarn "_THREE_STATE=${_THREE_STATE} settings?.threeStateEnable=${settings?.threeStateEnable}" // library marker kkossev.commonLib, line 1164
    } // library marker kkossev.commonLib, line 1165


    runInMillis( DIGITAL_TIMER, clearIsDigital, [overwrite: true]) // library marker kkossev.commonLib, line 1168
    sendZigbeeCommands(cmds) // library marker kkossev.commonLib, line 1169
} // library marker kkossev.commonLib, line 1170

def on() { // library marker kkossev.commonLib, line 1172
    if (DEVICE_TYPE in ["Thermostat"]) { thermostatOn(); return } // library marker kkossev.commonLib, line 1173
    if (state.states == null) { state.states = [:] } // library marker kkossev.commonLib, line 1174
    state.states["isDigital"] = true // library marker kkossev.commonLib, line 1175
    logDebug "Switching ${device.displayName} On" // library marker kkossev.commonLib, line 1176
    def cmds = zigbee.on() // library marker kkossev.commonLib, line 1177
/* // library marker kkossev.commonLib, line 1178
    if (device.getDataValue("model") == "HY0105") { // library marker kkossev.commonLib, line 1179
        cmds += zigbee.command(0x0006, 0x01, "", [destEndpoint: 0x02]) // library marker kkossev.commonLib, line 1180
    }     // library marker kkossev.commonLib, line 1181
    else if (state.model == "TS0601") { // library marker kkossev.commonLib, line 1182
        if (isDinRail() || isRTXCircuitBreaker()) { // library marker kkossev.commonLib, line 1183
            cmds = sendTuyaCommand("10", DP_TYPE_BOOL, "01") // library marker kkossev.commonLib, line 1184
        } // library marker kkossev.commonLib, line 1185
        else { // library marker kkossev.commonLib, line 1186
            cmds = zigbee.command(0xEF00, 0x0, "00010101000101") // library marker kkossev.commonLib, line 1187
        } // library marker kkossev.commonLib, line 1188
    } // library marker kkossev.commonLib, line 1189
    else if (isHEProblematic()) { // library marker kkossev.commonLib, line 1190
        cmds = ["he cmd 0x${device.deviceNetworkId} 0x01 0x0006 1 {}","delay 200"] // library marker kkossev.commonLib, line 1191
        logWarn "isHEProblematic() : sending off() : ${cmds}" // library marker kkossev.commonLib, line 1192
    } // library marker kkossev.commonLib, line 1193
    else if (device.endpointId == "F2") { // library marker kkossev.commonLib, line 1194
        cmds = ["he cmd 0x${device.deviceNetworkId} 0x01 0x0006 1 {}","delay 200"] // library marker kkossev.commonLib, line 1195
    } // library marker kkossev.commonLib, line 1196
*/ // library marker kkossev.commonLib, line 1197
    if (_THREE_STATE == true && settings?.threeStateEnable == true) { // library marker kkossev.commonLib, line 1198
        if ((device.currentState('switch')?.value ?: 'n/a') == 'on' ) { // library marker kkossev.commonLib, line 1199
            runIn(1, 'refresh',  [overwrite: true]) // library marker kkossev.commonLib, line 1200
        } // library marker kkossev.commonLib, line 1201
        def value = SwitchThreeStateOpts.options[3]    // 'switching_on' // library marker kkossev.commonLib, line 1202
        def descriptionText = "${value} (3)" // library marker kkossev.commonLib, line 1203
        sendEvent(name: "switch", value: value, descriptionText: descriptionText, type: "digital", isStateChange: true) // library marker kkossev.commonLib, line 1204
        logInfo "${descriptionText}" // library marker kkossev.commonLib, line 1205
    } // library marker kkossev.commonLib, line 1206
    else { // library marker kkossev.commonLib, line 1207
        logWarn "_THREE_STATE=${_THREE_STATE} settings?.threeStateEnable=${settings?.threeStateEnable}" // library marker kkossev.commonLib, line 1208
    } // library marker kkossev.commonLib, line 1209


    runInMillis( DIGITAL_TIMER, clearIsDigital, [overwrite: true]) // library marker kkossev.commonLib, line 1212
    sendZigbeeCommands(cmds) // library marker kkossev.commonLib, line 1213
} // library marker kkossev.commonLib, line 1214

def sendSwitchEvent( switchValue ) { // library marker kkossev.commonLib, line 1216
    def value = (switchValue == null) ? 'unknown' : (switchValue == 0x00) ? 'off' : (switchValue == 0x01) ? 'on' : 'unknown' // library marker kkossev.commonLib, line 1217
    def map = [:]  // library marker kkossev.commonLib, line 1218
    boolean bWasChange = false // library marker kkossev.commonLib, line 1219
    boolean debounce   = state.states["debounce"] ?: false // library marker kkossev.commonLib, line 1220
    def lastSwitch = state.states["lastSwitch"] ?: "unknown" // library marker kkossev.commonLib, line 1221
    if (debounce == true && value == lastSwitch) {    // some devices send only catchall events, some only readattr reports, but some will fire both... // library marker kkossev.commonLib, line 1222
        logDebug "Ignored duplicated switch event ${value}" // library marker kkossev.commonLib, line 1223
        runInMillis( DEBOUNCING_TIMER, switchDebouncingClear, [overwrite: true]) // library marker kkossev.commonLib, line 1224
        return null // library marker kkossev.commonLib, line 1225
    } // library marker kkossev.commonLib, line 1226
    else { // library marker kkossev.commonLib, line 1227
        //log.trace "value=${value}  lastSwitch=${state.states['lastSwitch']}" // library marker kkossev.commonLib, line 1228
    } // library marker kkossev.commonLib, line 1229
    def isDigital = state.states["isDigital"] // library marker kkossev.commonLib, line 1230
    map.type = isDigital == true ? "digital" : "physical" // library marker kkossev.commonLib, line 1231
    if (lastSwitch != value ) { // library marker kkossev.commonLib, line 1232
        bWasChange = true // library marker kkossev.commonLib, line 1233
        logDebug "switch state changed from <b>${lastSwitch}</b> to <b>${value}</b>" // library marker kkossev.commonLib, line 1234
        state.states["debounce"]   = true // library marker kkossev.commonLib, line 1235
        state.states["lastSwitch"] = value // library marker kkossev.commonLib, line 1236
        runInMillis( DEBOUNCING_TIMER, switchDebouncingClear, [overwrite: true])         // library marker kkossev.commonLib, line 1237
    } // library marker kkossev.commonLib, line 1238
    else { // library marker kkossev.commonLib, line 1239
        state.states["debounce"] = true // library marker kkossev.commonLib, line 1240
        runInMillis( DEBOUNCING_TIMER, switchDebouncingClear, [overwrite: true])      // library marker kkossev.commonLib, line 1241
    } // library marker kkossev.commonLib, line 1242

    map.name = "switch" // library marker kkossev.commonLib, line 1244
    map.value = value // library marker kkossev.commonLib, line 1245
    boolean isRefresh = state.states["isRefresh"] ?: false // library marker kkossev.commonLib, line 1246
    if (isRefresh == true) { // library marker kkossev.commonLib, line 1247
        map.descriptionText = "${device.displayName} is ${value} [Refresh]" // library marker kkossev.commonLib, line 1248
        map.isStateChange = true // library marker kkossev.commonLib, line 1249
    } // library marker kkossev.commonLib, line 1250
    else { // library marker kkossev.commonLib, line 1251
        map.descriptionText = "${device.displayName} is ${value} [${map.type}]" // library marker kkossev.commonLib, line 1252
    } // library marker kkossev.commonLib, line 1253
    logInfo "${map.descriptionText}" // library marker kkossev.commonLib, line 1254
    sendEvent(map) // library marker kkossev.commonLib, line 1255
    clearIsDigital() // library marker kkossev.commonLib, line 1256
} // library marker kkossev.commonLib, line 1257

@Field static final Map powerOnBehaviourOptions = [    // library marker kkossev.commonLib, line 1259
    '0': 'switch off', // library marker kkossev.commonLib, line 1260
    '1': 'switch on', // library marker kkossev.commonLib, line 1261
    '2': 'switch last state' // library marker kkossev.commonLib, line 1262
] // library marker kkossev.commonLib, line 1263

@Field static final Map switchTypeOptions = [    // library marker kkossev.commonLib, line 1265
    '0': 'toggle', // library marker kkossev.commonLib, line 1266
    '1': 'state', // library marker kkossev.commonLib, line 1267
    '2': 'momentary' // library marker kkossev.commonLib, line 1268
] // library marker kkossev.commonLib, line 1269

Map myParseDescriptionAsMap( String description ) // library marker kkossev.commonLib, line 1271
{ // library marker kkossev.commonLib, line 1272
    def descMap = [:] // library marker kkossev.commonLib, line 1273
    try { // library marker kkossev.commonLib, line 1274
        descMap = zigbee.parseDescriptionAsMap(description) // library marker kkossev.commonLib, line 1275
    } // library marker kkossev.commonLib, line 1276
    catch (e1) { // library marker kkossev.commonLib, line 1277
        logWarn "exception ${e1} caught while parseDescriptionAsMap <b>myParseDescriptionAsMap</b> description:  ${description}" // library marker kkossev.commonLib, line 1278
        // try alternative custom parsing // library marker kkossev.commonLib, line 1279
        descMap = [:] // library marker kkossev.commonLib, line 1280
        try { // library marker kkossev.commonLib, line 1281
            descMap += description.replaceAll('\\[|\\]', '').split(',').collectEntries { entry -> // library marker kkossev.commonLib, line 1282
                def pair = entry.split(':') // library marker kkossev.commonLib, line 1283
                [(pair.first().trim()): pair.last().trim()] // library marker kkossev.commonLib, line 1284
            }         // library marker kkossev.commonLib, line 1285
        } // library marker kkossev.commonLib, line 1286
        catch (e2) { // library marker kkossev.commonLib, line 1287
            logWarn "exception ${e2} caught while parsing using an alternative method <b>myParseDescriptionAsMap</b> description:  ${description}" // library marker kkossev.commonLib, line 1288
            return [:] // library marker kkossev.commonLib, line 1289
        } // library marker kkossev.commonLib, line 1290
        logDebug "alternative method parsing success: descMap=${descMap}" // library marker kkossev.commonLib, line 1291
    } // library marker kkossev.commonLib, line 1292
    return descMap // library marker kkossev.commonLib, line 1293
} // library marker kkossev.commonLib, line 1294

boolean isTuyaE00xCluster( String description ) // library marker kkossev.commonLib, line 1296
{ // library marker kkossev.commonLib, line 1297
    if(description == null || !(description.indexOf('cluster: E000') >= 0 || description.indexOf('cluster: E001') >= 0)) { // library marker kkossev.commonLib, line 1298
        return false  // library marker kkossev.commonLib, line 1299
    } // library marker kkossev.commonLib, line 1300
    // try to parse ... // library marker kkossev.commonLib, line 1301
    //logDebug "Tuya cluster: E000 or E001 - try to parse it..." // library marker kkossev.commonLib, line 1302
    def descMap = [:] // library marker kkossev.commonLib, line 1303
    try { // library marker kkossev.commonLib, line 1304
        descMap = zigbee.parseDescriptionAsMap(description) // library marker kkossev.commonLib, line 1305
        logDebug "TuyaE00xCluster Desc Map: ${descMap}" // library marker kkossev.commonLib, line 1306
    } // library marker kkossev.commonLib, line 1307
    catch ( e ) { // library marker kkossev.commonLib, line 1308
        logDebug "<b>exception</b> caught while parsing description:  ${description}" // library marker kkossev.commonLib, line 1309
        logDebug "TuyaE00xCluster Desc Map: ${descMap}" // library marker kkossev.commonLib, line 1310
        // cluster E001 is the one that is generating exceptions... // library marker kkossev.commonLib, line 1311
        return true // library marker kkossev.commonLib, line 1312
    } // library marker kkossev.commonLib, line 1313

    if (descMap.cluster == "E000" && descMap.attrId in ["D001", "D002", "D003"]) { // library marker kkossev.commonLib, line 1315
        logDebug "Tuya Specific cluster ${descMap.cluster} attribute ${descMap.attrId} value is ${descMap.value}" // library marker kkossev.commonLib, line 1316
    } // library marker kkossev.commonLib, line 1317
    else if (descMap.cluster == "E001" && descMap.attrId == "D010") { // library marker kkossev.commonLib, line 1318
        if (settings?.logEnable) { logInfo "power on behavior is <b>${powerOnBehaviourOptions[safeToInt(descMap.value).toString()]}</b> (${descMap.value})" } // library marker kkossev.commonLib, line 1319
    } // library marker kkossev.commonLib, line 1320
    else if (descMap.cluster == "E001" && descMap.attrId == "D030") { // library marker kkossev.commonLib, line 1321
        if (settings?.logEnable) { logInfo "swith type is <b>${switchTypeOptions[safeToInt(descMap.value).toString()]}</b> (${descMap.value})" } // library marker kkossev.commonLib, line 1322
    } // library marker kkossev.commonLib, line 1323
    else { // library marker kkossev.commonLib, line 1324
        logDebug "<b>unprocessed</b> TuyaE00xCluster Desc Map: $descMap" // library marker kkossev.commonLib, line 1325
        return false  // library marker kkossev.commonLib, line 1326
    } // library marker kkossev.commonLib, line 1327
    return true    // processed // library marker kkossev.commonLib, line 1328
} // library marker kkossev.commonLib, line 1329

// return true if further processing in the main parse method should be cancelled ! // library marker kkossev.commonLib, line 1331
boolean otherTuyaOddities( String description ) { // library marker kkossev.commonLib, line 1332
  /* // library marker kkossev.commonLib, line 1333
    if (description.indexOf('cluster: 0000') >= 0 && description.indexOf('attrId: 0004') >= 0) { // library marker kkossev.commonLib, line 1334
        if (logEnable) log.debug "${device.displayName} skipping Tuya parse of  cluster 0 attrId 4"             // parseDescriptionAsMap throws exception when processing Tuya cluster 0 attrId 4  // library marker kkossev.commonLib, line 1335
        return true // library marker kkossev.commonLib, line 1336
    } // library marker kkossev.commonLib, line 1337
*/ // library marker kkossev.commonLib, line 1338
    def descMap = [:] // library marker kkossev.commonLib, line 1339
    try { // library marker kkossev.commonLib, line 1340
        descMap = zigbee.parseDescriptionAsMap(description) // library marker kkossev.commonLib, line 1341
    } // library marker kkossev.commonLib, line 1342
    catch (e1) { // library marker kkossev.commonLib, line 1343
        logWarn "exception ${e1} caught while parseDescriptionAsMap <b>otherTuyaOddities</b> description:  ${description}" // library marker kkossev.commonLib, line 1344
        // try alternative custom parsing // library marker kkossev.commonLib, line 1345
        descMap = [:] // library marker kkossev.commonLib, line 1346
        try { // library marker kkossev.commonLib, line 1347
            descMap += description.replaceAll('\\[|\\]', '').split(',').collectEntries { entry -> // library marker kkossev.commonLib, line 1348
                def pair = entry.split(':') // library marker kkossev.commonLib, line 1349
                [(pair.first().trim()): pair.last().trim()] // library marker kkossev.commonLib, line 1350
            }         // library marker kkossev.commonLib, line 1351
        } // library marker kkossev.commonLib, line 1352
        catch (e2) { // library marker kkossev.commonLib, line 1353
            logWarn "exception ${e2} caught while parsing using an alternative method <b>otherTuyaOddities</b> description:  ${description}" // library marker kkossev.commonLib, line 1354
            return true // library marker kkossev.commonLib, line 1355
        } // library marker kkossev.commonLib, line 1356
        logDebug "alternative method parsing success: descMap=${descMap}" // library marker kkossev.commonLib, line 1357
    } // library marker kkossev.commonLib, line 1358
    //if (logEnable) {log.trace "${device.displayName} Checking Tuya Oddities Desc Map: $descMap"}         // library marker kkossev.commonLib, line 1359
    if (descMap.attrId == null ) { // library marker kkossev.commonLib, line 1360
        //logDebug "otherTuyaOddities: descMap = ${descMap}" // library marker kkossev.commonLib, line 1361
        //if (logEnable) log.trace "${device.displayName} otherTuyaOddities - Cluster ${descMap.clusterId} NO ATTRIBUTE, skipping" // library marker kkossev.commonLib, line 1362
        return false // library marker kkossev.commonLib, line 1363
    } // library marker kkossev.commonLib, line 1364
    boolean bWasAtLeastOneAttributeProcessed = false // library marker kkossev.commonLib, line 1365
    boolean bWasThereAnyStandardAttribite = false // library marker kkossev.commonLib, line 1366
    // attribute report received // library marker kkossev.commonLib, line 1367
    List attrData = [[cluster: descMap.cluster ,attrId: descMap.attrId, value: descMap.value, status: descMap.status]] // library marker kkossev.commonLib, line 1368
    descMap.additionalAttrs.each { // library marker kkossev.commonLib, line 1369
        attrData << [cluster: descMap.cluster, attrId: it.attrId, value: it.value, status: it.status] // library marker kkossev.commonLib, line 1370
        //log.trace "Tuya oddity: filling in attrData ${attrData}" // library marker kkossev.commonLib, line 1371
    } // library marker kkossev.commonLib, line 1372
    attrData.each { // library marker kkossev.commonLib, line 1373
        //log.trace "each it=${it}" // library marker kkossev.commonLib, line 1374
        def map = [:] // library marker kkossev.commonLib, line 1375
        if (it.status == "86") { // library marker kkossev.commonLib, line 1376
            logWarn "Tuya Cluster ${descMap.cluster} unsupported attrId ${it.attrId}" // library marker kkossev.commonLib, line 1377
            // TODO - skip parsing? // library marker kkossev.commonLib, line 1378
        } // library marker kkossev.commonLib, line 1379
        switch (it.cluster) { // library marker kkossev.commonLib, line 1380
            case "0000" : // library marker kkossev.commonLib, line 1381
                if (it.attrId in ["FFE0", "FFE1", "FFE2", "FFE4"]) { // library marker kkossev.commonLib, line 1382
                    logDebug "Cluster ${descMap.cluster} Tuya specific attrId ${it.attrId} value ${it.value})" // library marker kkossev.commonLib, line 1383
                    bWasAtLeastOneAttributeProcessed = true // library marker kkossev.commonLib, line 1384
                } // library marker kkossev.commonLib, line 1385
                else if (it.attrId in ["FFFE", "FFDF"]) { // library marker kkossev.commonLib, line 1386
                    logDebug "Cluster ${descMap.cluster} Tuya specific attrId ${it.attrId} value ${it.value})" // library marker kkossev.commonLib, line 1387
                    bWasAtLeastOneAttributeProcessed = true // library marker kkossev.commonLib, line 1388
                } // library marker kkossev.commonLib, line 1389
                else { // library marker kkossev.commonLib, line 1390
                    //logDebug "otherTuyaOddities? - Cluster ${descMap.cluster} attrId ${it.attrId} value ${it.value}) N/A, skipping" // library marker kkossev.commonLib, line 1391
                    bWasThereAnyStandardAttribite = true // library marker kkossev.commonLib, line 1392
                } // library marker kkossev.commonLib, line 1393
                break // library marker kkossev.commonLib, line 1394
            default : // library marker kkossev.commonLib, line 1395
                //if (logEnable) log.trace "${device.displayName} otherTuyaOddities - Cluster ${it.cluster} N/A, skipping" // library marker kkossev.commonLib, line 1396
                break // library marker kkossev.commonLib, line 1397
        } // switch // library marker kkossev.commonLib, line 1398
    } // for each attribute // library marker kkossev.commonLib, line 1399
    return bWasAtLeastOneAttributeProcessed && !bWasThereAnyStandardAttribite // library marker kkossev.commonLib, line 1400
} // library marker kkossev.commonLib, line 1401

private boolean isCircuitBreaker()      { device.getDataValue("manufacturer") in ["_TZ3000_ky0fq4ho"] } // library marker kkossev.commonLib, line 1403
private boolean isRTXCircuitBreaker()   { device.getDataValue("manufacturer") in ["_TZE200_abatw3kj"] } // library marker kkossev.commonLib, line 1404

def parseOnOffAttributes( it ) { // library marker kkossev.commonLib, line 1406
    logDebug "OnOff attribute ${it.attrId} cluster ${it.cluster } reported: value=${it.value}" // library marker kkossev.commonLib, line 1407
    def mode // library marker kkossev.commonLib, line 1408
    def attrName // library marker kkossev.commonLib, line 1409
    if (it.value == null) { // library marker kkossev.commonLib, line 1410
        logDebug "OnOff attribute ${it.attrId} cluster ${it.cluster } skipping NULL value status=${it.status}" // library marker kkossev.commonLib, line 1411
        return // library marker kkossev.commonLib, line 1412
    } // library marker kkossev.commonLib, line 1413
    def value = zigbee.convertHexToInt(it.value) // library marker kkossev.commonLib, line 1414
    switch (it.attrId) { // library marker kkossev.commonLib, line 1415
        case "4000" :    // non-Tuya GlobalSceneControl (bool), read-only // library marker kkossev.commonLib, line 1416
            attrName = "Global Scene Control" // library marker kkossev.commonLib, line 1417
            mode = value == 0 ? "off" : value == 1 ? "on" : null // library marker kkossev.commonLib, line 1418
            break // library marker kkossev.commonLib, line 1419
        case "4001" :    // non-Tuya OnTime (UINT16), read-only // library marker kkossev.commonLib, line 1420
            attrName = "On Time" // library marker kkossev.commonLib, line 1421
            mode = value // library marker kkossev.commonLib, line 1422
            break // library marker kkossev.commonLib, line 1423
        case "4002" :    // non-Tuya OffWaitTime (UINT16), read-only // library marker kkossev.commonLib, line 1424
            attrName = "Off Wait Time" // library marker kkossev.commonLib, line 1425
            mode = value // library marker kkossev.commonLib, line 1426
            break // library marker kkossev.commonLib, line 1427
        case "4003" :    // non-Tuya "powerOnState" (ENUM8), read-write, default=1  // library marker kkossev.commonLib, line 1428
            attrName = "Power On State" // library marker kkossev.commonLib, line 1429
            mode = value == 0 ? "off" : value == 1 ? "on" : value == 2 ?  "Last state" : "UNKNOWN" // library marker kkossev.commonLib, line 1430
            break // library marker kkossev.commonLib, line 1431
        case "8000" :    // command "childLock", [[name:"Child Lock", type: "ENUM", description: "Select Child Lock mode", constraints: ["off", "on"]]] // library marker kkossev.commonLib, line 1432
            attrName = "Child Lock" // library marker kkossev.commonLib, line 1433
            mode = value == 0 ? "off" : "on" // library marker kkossev.commonLib, line 1434
            break // library marker kkossev.commonLib, line 1435
        case "8001" :    // command "ledMode", [[name:"LED mode", type: "ENUM", description: "Select LED mode", constraints: ["Disabled", "Lit when On", "Lit when Off", "Always Green", "Red when On; Green when Off", "Green when On; Red when Off", "Always Red" ]]] // library marker kkossev.commonLib, line 1436
            attrName = "LED mode" // library marker kkossev.commonLib, line 1437
            if (isCircuitBreaker()) { // library marker kkossev.commonLib, line 1438
                mode = value == 0 ? "Always Green" : value == 1 ? "Red when On; Green when Off" : value == 2 ? "Green when On; Red when Off" : value == 3 ? "Always Red" : null // library marker kkossev.commonLib, line 1439
            } // library marker kkossev.commonLib, line 1440
            else { // library marker kkossev.commonLib, line 1441
                mode = value == 0 ? "Disabled"  : value == 1 ? "Lit when On" : value == 2 ? "Lit when Off" : value == 3 ? "Freeze": null // library marker kkossev.commonLib, line 1442
            } // library marker kkossev.commonLib, line 1443
            break // library marker kkossev.commonLib, line 1444
        case "8002" :    // command "powerOnState", [[name:"Power On State", type: "ENUM", description: "Select Power On State", constraints: ["off","on", "Last state"]]] // library marker kkossev.commonLib, line 1445
            attrName = "Power On State" // library marker kkossev.commonLib, line 1446
            mode = value == 0 ? "off" : value == 1 ? "on" : value == 2 ?  "Last state" : null // library marker kkossev.commonLib, line 1447
            break // library marker kkossev.commonLib, line 1448
        case "8003" : //  Over current alarm // library marker kkossev.commonLib, line 1449
            attrName = "Over current alarm" // library marker kkossev.commonLib, line 1450
            mode = value == 0 ? "Over Current OK" : value == 1 ? "Over Current Alarm" : null // library marker kkossev.commonLib, line 1451
            break // library marker kkossev.commonLib, line 1452
        default : // library marker kkossev.commonLib, line 1453
            logWarn "Unprocessed Tuya OnOff attribute ${it.attrId} cluster ${it.cluster } reported: value=${it.value}" // library marker kkossev.commonLib, line 1454
            return // library marker kkossev.commonLib, line 1455
    } // library marker kkossev.commonLib, line 1456
    if (settings?.logEnable) { logInfo "${attrName} is ${mode}" } // library marker kkossev.commonLib, line 1457
} // library marker kkossev.commonLib, line 1458

def sendButtonEvent(buttonNumber, buttonState, isDigital=false) { // library marker kkossev.commonLib, line 1460
    def event = [name: buttonState, value: buttonNumber.toString(), data: [buttonNumber: buttonNumber], descriptionText: "button $buttonNumber was $buttonState", isStateChange: true, type: isDigital==true ? 'digital' : 'physical'] // library marker kkossev.commonLib, line 1461
    if (txtEnable) {log.info "${device.displayName} $event.descriptionText"} // library marker kkossev.commonLib, line 1462
    sendEvent(event) // library marker kkossev.commonLib, line 1463
} // library marker kkossev.commonLib, line 1464

def push() {                // Momentary capability // library marker kkossev.commonLib, line 1466
    logDebug "push momentary" // library marker kkossev.commonLib, line 1467
    if (DEVICE_TYPE in ["Fingerbot"])     { pushFingerbot(); return }     // library marker kkossev.commonLib, line 1468
    logWarn "push() not implemented for ${(DEVICE_TYPE)}" // library marker kkossev.commonLib, line 1469
} // library marker kkossev.commonLib, line 1470

def push(buttonNumber) {    //pushableButton capability // library marker kkossev.commonLib, line 1472
    if (DEVICE_TYPE in ["Fingerbot"])     { pushFingerbot(buttonNumber); return }     // library marker kkossev.commonLib, line 1473
    sendButtonEvent(buttonNumber, "pushed", isDigital=true) // library marker kkossev.commonLib, line 1474
} // library marker kkossev.commonLib, line 1475

def doubleTap(buttonNumber) { // library marker kkossev.commonLib, line 1477
    sendButtonEvent(buttonNumber, "doubleTapped", isDigital=true) // library marker kkossev.commonLib, line 1478
} // library marker kkossev.commonLib, line 1479

def hold(buttonNumber) { // library marker kkossev.commonLib, line 1481
    sendButtonEvent(buttonNumber, "held", isDigital=true) // library marker kkossev.commonLib, line 1482
} // library marker kkossev.commonLib, line 1483

def release(buttonNumber) { // library marker kkossev.commonLib, line 1485
    sendButtonEvent(buttonNumber, "released", isDigital=true) // library marker kkossev.commonLib, line 1486
} // library marker kkossev.commonLib, line 1487

void sendNumberOfButtonsEvent(numberOfButtons) { // library marker kkossev.commonLib, line 1489
    sendEvent(name: "numberOfButtons", value: numberOfButtons, isStateChange: true, type: "digital") // library marker kkossev.commonLib, line 1490
} // library marker kkossev.commonLib, line 1491

void sendSupportedButtonValuesEvent(supportedValues) { // library marker kkossev.commonLib, line 1493
    sendEvent(name: "supportedButtonValues", value: JsonOutput.toJson(supportedValues), isStateChange: true, type: "digital") // library marker kkossev.commonLib, line 1494
} // library marker kkossev.commonLib, line 1495


/* // library marker kkossev.commonLib, line 1498
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 1499
 * Level Control Cluster            0x0008 // library marker kkossev.commonLib, line 1500
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 1501
*/ // library marker kkossev.commonLib, line 1502
void parseLevelControlCluster(final Map descMap) { // library marker kkossev.commonLib, line 1503
    if (state.lastRx == null) { state.lastRx = [:] } // library marker kkossev.commonLib, line 1504
    if (DEVICE_TYPE in ["ButtonDimmer"]) { // library marker kkossev.commonLib, line 1505
        parseLevelControlClusterButtonDimmer(descMap) // library marker kkossev.commonLib, line 1506
    } // library marker kkossev.commonLib, line 1507
    else if (DEVICE_TYPE in ["Bulb"]) { // library marker kkossev.commonLib, line 1508
        parseLevelControlClusterBulb(descMap) // library marker kkossev.commonLib, line 1509
    } // library marker kkossev.commonLib, line 1510
    else if (descMap.attrId == "0000") { // library marker kkossev.commonLib, line 1511
        if (descMap.value == null || descMap.value == 'FFFF') { logDebug "parseLevelControlCluster: invalid value: ${descMap.value}"; return } // invalid or unknown value // library marker kkossev.commonLib, line 1512
        final long rawValue = hexStrToUnsignedInt(descMap.value) // library marker kkossev.commonLib, line 1513
        sendLevelControlEvent(rawValue) // library marker kkossev.commonLib, line 1514
    } // library marker kkossev.commonLib, line 1515
    else { // library marker kkossev.commonLib, line 1516
        logWarn "unprocessed LevelControl attribute ${descMap.attrId}" // library marker kkossev.commonLib, line 1517
    } // library marker kkossev.commonLib, line 1518
} // library marker kkossev.commonLib, line 1519


def sendLevelControlEvent( rawValue ) { // library marker kkossev.commonLib, line 1522
    def value = rawValue as int // library marker kkossev.commonLib, line 1523
    if (value <0) value = 0 // library marker kkossev.commonLib, line 1524
    if (value >100) value = 100 // library marker kkossev.commonLib, line 1525
    def map = [:]  // library marker kkossev.commonLib, line 1526

    def isDigital = state.states["isDigital"] // library marker kkossev.commonLib, line 1528
    map.type = isDigital == true ? "digital" : "physical" // library marker kkossev.commonLib, line 1529

    map.name = "level" // library marker kkossev.commonLib, line 1531
    map.value = value // library marker kkossev.commonLib, line 1532
    boolean isRefresh = state.states["isRefresh"] ?: false // library marker kkossev.commonLib, line 1533
    if (isRefresh == true) { // library marker kkossev.commonLib, line 1534
        map.descriptionText = "${device.displayName} is ${value} [Refresh]" // library marker kkossev.commonLib, line 1535
        map.isStateChange = true // library marker kkossev.commonLib, line 1536
    } // library marker kkossev.commonLib, line 1537
    else { // library marker kkossev.commonLib, line 1538
        map.descriptionText = "${device.displayName} was set ${value} [${map.type}]" // library marker kkossev.commonLib, line 1539
    } // library marker kkossev.commonLib, line 1540
    logInfo "${map.descriptionText}" // library marker kkossev.commonLib, line 1541
    sendEvent(map) // library marker kkossev.commonLib, line 1542
    clearIsDigital() // library marker kkossev.commonLib, line 1543
} // library marker kkossev.commonLib, line 1544

/** // library marker kkossev.commonLib, line 1546
 * Get the level transition rate // library marker kkossev.commonLib, line 1547
 * @param level desired target level (0-100) // library marker kkossev.commonLib, line 1548
 * @param transitionTime transition time in seconds (optional) // library marker kkossev.commonLib, line 1549
 * @return transition rate in 1/10ths of a second // library marker kkossev.commonLib, line 1550
 */ // library marker kkossev.commonLib, line 1551
private Integer getLevelTransitionRate(final Integer desiredLevel, final Integer transitionTime = null) { // library marker kkossev.commonLib, line 1552
    int rate = 0 // library marker kkossev.commonLib, line 1553
    final Boolean isOn = device.currentValue('switch') == 'on' // library marker kkossev.commonLib, line 1554
    Integer currentLevel = (device.currentValue('level') as Integer) ?: 0 // library marker kkossev.commonLib, line 1555
    if (!isOn) { // library marker kkossev.commonLib, line 1556
        currentLevel = 0 // library marker kkossev.commonLib, line 1557
    } // library marker kkossev.commonLib, line 1558
    // Check if 'transitionTime' has a value // library marker kkossev.commonLib, line 1559
    if (transitionTime > 0) { // library marker kkossev.commonLib, line 1560
        // Calculate the rate by converting 'transitionTime' to BigDecimal, multiplying by 10, and converting to Integer // library marker kkossev.commonLib, line 1561
        rate = transitionTime * 10 // library marker kkossev.commonLib, line 1562
    } else { // library marker kkossev.commonLib, line 1563
        // Check if the 'levelUpTransition' setting has a value and the current level is less than the desired level // library marker kkossev.commonLib, line 1564
        if (((settings.levelUpTransition ?: 0) as Integer) > 0 && currentLevel < desiredLevel) { // library marker kkossev.commonLib, line 1565
            // Set the rate to the value of the 'levelUpTransition' setting converted to Integer // library marker kkossev.commonLib, line 1566
            rate = settings.levelUpTransition.toInteger() // library marker kkossev.commonLib, line 1567
        } // library marker kkossev.commonLib, line 1568
        // Check if the 'levelDownTransition' setting has a value and the current level is greater than the desired level // library marker kkossev.commonLib, line 1569
        else if (((settings.levelDownTransition ?: 0) as Integer) > 0 && currentLevel > desiredLevel) { // library marker kkossev.commonLib, line 1570
            // Set the rate to the value of the 'levelDownTransition' setting converted to Integer // library marker kkossev.commonLib, line 1571
            rate = settings.levelDownTransition.toInteger() // library marker kkossev.commonLib, line 1572
        } // library marker kkossev.commonLib, line 1573
    } // library marker kkossev.commonLib, line 1574
    logDebug "using level transition rate ${rate}" // library marker kkossev.commonLib, line 1575
    return rate // library marker kkossev.commonLib, line 1576
} // library marker kkossev.commonLib, line 1577

// Command option that enable changes when off // library marker kkossev.commonLib, line 1579
@Field static final String PRE_STAGING_OPTION = '01 01' // library marker kkossev.commonLib, line 1580

/** // library marker kkossev.commonLib, line 1582
 * Constrain a value to a range // library marker kkossev.commonLib, line 1583
 * @param value value to constrain // library marker kkossev.commonLib, line 1584
 * @param min minimum value (default 0) // library marker kkossev.commonLib, line 1585
 * @param max maximum value (default 100) // library marker kkossev.commonLib, line 1586
 * @param nullValue value to return if value is null (default 0) // library marker kkossev.commonLib, line 1587
 */ // library marker kkossev.commonLib, line 1588
private static BigDecimal constrain(final BigDecimal value, final BigDecimal min = 0, final BigDecimal max = 100, final BigDecimal nullValue = 0) { // library marker kkossev.commonLib, line 1589
    if (min == null || max == null) { // library marker kkossev.commonLib, line 1590
        return value // library marker kkossev.commonLib, line 1591
    } // library marker kkossev.commonLib, line 1592
    return value != null ? max.min(value.max(min)) : nullValue // library marker kkossev.commonLib, line 1593
} // library marker kkossev.commonLib, line 1594

/** // library marker kkossev.commonLib, line 1596
 * Constrain a value to a range // library marker kkossev.commonLib, line 1597
 * @param value value to constrain // library marker kkossev.commonLib, line 1598
 * @param min minimum value (default 0) // library marker kkossev.commonLib, line 1599
 * @param max maximum value (default 100) // library marker kkossev.commonLib, line 1600
 * @param nullValue value to return if value is null (default 0) // library marker kkossev.commonLib, line 1601
 */ // library marker kkossev.commonLib, line 1602
private static Integer constrain(final Object value, final Integer min = 0, final Integer max = 100, final Integer nullValue = 0) { // library marker kkossev.commonLib, line 1603
    if (min == null || max == null) { // library marker kkossev.commonLib, line 1604
        return value as Integer // library marker kkossev.commonLib, line 1605
    } // library marker kkossev.commonLib, line 1606
    return value != null ? Math.min(Math.max(value as Integer, min) as Integer, max) : nullValue // library marker kkossev.commonLib, line 1607
} // library marker kkossev.commonLib, line 1608

// Delay before reading attribute (when using polling) // library marker kkossev.commonLib, line 1610
@Field static final int POLL_DELAY_MS = 1000 // library marker kkossev.commonLib, line 1611

/** // library marker kkossev.commonLib, line 1613
 * If the device is polling, delay the execution of the provided commands // library marker kkossev.commonLib, line 1614
 * @param delayMs delay in milliseconds // library marker kkossev.commonLib, line 1615
 * @param commands commands to execute // library marker kkossev.commonLib, line 1616
 * @return list of commands to be sent to the device // library marker kkossev.commonLib, line 1617
 */ // library marker kkossev.commonLib, line 1618
private List<String> ifPolling(final int delayMs = 0, final Closure commands) { // library marker kkossev.commonLib, line 1619
    if (state.reportingEnabled == false) { // library marker kkossev.commonLib, line 1620
        final int value = Math.max(delayMs, POLL_DELAY_MS) // library marker kkossev.commonLib, line 1621
        return ["delay ${value}"] + (commands() as List<String>) as List<String> // library marker kkossev.commonLib, line 1622
    } // library marker kkossev.commonLib, line 1623
    return [] // library marker kkossev.commonLib, line 1624
} // library marker kkossev.commonLib, line 1625

def intTo16bitUnsignedHex(value) { // library marker kkossev.commonLib, line 1627
    def hexStr = zigbee.convertToHexString(value.toInteger(),4) // library marker kkossev.commonLib, line 1628
    return new String(hexStr.substring(2, 4) + hexStr.substring(0, 2)) // library marker kkossev.commonLib, line 1629
} // library marker kkossev.commonLib, line 1630

def intTo8bitUnsignedHex(value) { // library marker kkossev.commonLib, line 1632
    return zigbee.convertToHexString(value.toInteger(), 2) // library marker kkossev.commonLib, line 1633
} // library marker kkossev.commonLib, line 1634

/** // library marker kkossev.commonLib, line 1636
 * Send 'switchLevel' attribute event // library marker kkossev.commonLib, line 1637
 * @param isOn true if light is on, false otherwise // library marker kkossev.commonLib, line 1638
 * @param level brightness level (0-254) // library marker kkossev.commonLib, line 1639
 */ // library marker kkossev.commonLib, line 1640
private List<String> setLevelPrivate(final Object value, final Integer rate = 0, final Integer delay = 0, final Boolean levelPreset = false) { // library marker kkossev.commonLib, line 1641
    List<String> cmds = [] // library marker kkossev.commonLib, line 1642
    final Integer level = constrain(value) // library marker kkossev.commonLib, line 1643
    final String hexLevel = DataType.pack(Math.round(level * 2.54).intValue(), DataType.UINT8) // library marker kkossev.commonLib, line 1644
    final String hexRate = DataType.pack(rate, DataType.UINT16, true) // library marker kkossev.commonLib, line 1645
    final int levelCommand = levelPreset ? 0x00 : 0x04 // library marker kkossev.commonLib, line 1646
    if (device.currentValue('switch') == 'off' && level > 0 && levelPreset == false) { // library marker kkossev.commonLib, line 1647
        // If light is off, first go to level 0 then to desired level // library marker kkossev.commonLib, line 1648
        cmds += zigbee.command(zigbee.LEVEL_CONTROL_CLUSTER, 0x00, [destEndpoint:safeToInt(getDestinationEP())], delay, "00 0000 ${PRE_STAGING_OPTION}") // library marker kkossev.commonLib, line 1649
    } // library marker kkossev.commonLib, line 1650
    // Payload: Level | Transition Time | Options Mask | Options Override // library marker kkossev.commonLib, line 1651
    // Options: Bit 0x01 enables pre-staging level // library marker kkossev.commonLib, line 1652
    /* // library marker kkossev.commonLib, line 1653
    cmds += zigbee.command(zigbee.LEVEL_CONTROL_CLUSTER, levelCommand, [destEndpoint:safeToInt(getDestinationEP())], delay, "${hexLevel} ${hexRate} ${PRE_STAGING_OPTION}") + // library marker kkossev.commonLib, line 1654
        ifPolling(DELAY_MS + (rate * 100)) { zigbee.levelRefresh(0) } // library marker kkossev.commonLib, line 1655
    */ // library marker kkossev.commonLib, line 1656
    int duration = 10            // TODO !!! // library marker kkossev.commonLib, line 1657
    String endpointId = "01"     // TODO !!! // library marker kkossev.commonLib, line 1658
     cmds +=  ["he cmd 0x${device.deviceNetworkId} 0x${endpointId} 0x0008 4 { 0x${intTo8bitUnsignedHex(level)} 0x${intTo16bitUnsignedHex(duration)} }",] // library marker kkossev.commonLib, line 1659

    return cmds // library marker kkossev.commonLib, line 1661
} // library marker kkossev.commonLib, line 1662


/** // library marker kkossev.commonLib, line 1665
 * Set Level Command // library marker kkossev.commonLib, line 1666
 * @param value level percent (0-100) // library marker kkossev.commonLib, line 1667
 * @param transitionTime transition time in seconds // library marker kkossev.commonLib, line 1668
 * @return List of zigbee commands // library marker kkossev.commonLib, line 1669
 */ // library marker kkossev.commonLib, line 1670
void /*List<String>*/ setLevel(final Object value, final Object transitionTime = null) { // library marker kkossev.commonLib, line 1671
    logInfo "setLevel (${value}, ${transitionTime})" // library marker kkossev.commonLib, line 1672
    if (DEVICE_TYPE in  ["ButtonDimmer"]) { setLevelButtonDimmer(value, transitionTime); return } // library marker kkossev.commonLib, line 1673
    if (DEVICE_TYPE in  ["Bulb"]) { setLevelBulb(value, transitionTime); return } // library marker kkossev.commonLib, line 1674
    else { // library marker kkossev.commonLib, line 1675
        final Integer rate = getLevelTransitionRate(value as Integer, transitionTime as Integer) // library marker kkossev.commonLib, line 1676
        scheduleCommandTimeoutCheck() // library marker kkossev.commonLib, line 1677
        /*return*/ sendZigbeeCommands ( setLevelPrivate(value, rate)) // library marker kkossev.commonLib, line 1678
    } // library marker kkossev.commonLib, line 1679
} // library marker kkossev.commonLib, line 1680

/* // library marker kkossev.commonLib, line 1682
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 1683
 * Color Control Cluster            0x0300 // library marker kkossev.commonLib, line 1684
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 1685
*/ // library marker kkossev.commonLib, line 1686
void parseColorControlCluster(final Map descMap, description) { // library marker kkossev.commonLib, line 1687
    if (state.lastRx == null) { state.lastRx = [:] } // library marker kkossev.commonLib, line 1688
    if (DEVICE_TYPE in ["Bulb"]) { // library marker kkossev.commonLib, line 1689
        parseColorControlClusterBulb(descMap, description) // library marker kkossev.commonLib, line 1690
    } // library marker kkossev.commonLib, line 1691
    else if (descMap.attrId == "0000") { // library marker kkossev.commonLib, line 1692
        if (descMap.value == null || descMap.value == 'FFFF') { logDebug "parseLevelControlCluster: invalid value: ${descMap.value}"; return } // invalid or unknown value // library marker kkossev.commonLib, line 1693
        final long rawValue = hexStrToUnsignedInt(descMap.value) // library marker kkossev.commonLib, line 1694
        sendLevelControlEvent(rawValue) // library marker kkossev.commonLib, line 1695
    } // library marker kkossev.commonLib, line 1696
    else { // library marker kkossev.commonLib, line 1697
        logWarn "unprocessed LevelControl attribute ${descMap.attrId}" // library marker kkossev.commonLib, line 1698
    } // library marker kkossev.commonLib, line 1699
} // library marker kkossev.commonLib, line 1700

/* // library marker kkossev.commonLib, line 1702
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 1703
 * Illuminance    cluster 0x0400 // library marker kkossev.commonLib, line 1704
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 1705
*/ // library marker kkossev.commonLib, line 1706
void parseIlluminanceCluster(final Map descMap) { // library marker kkossev.commonLib, line 1707
    if (state.lastRx == null) { state.lastRx = [:] } // library marker kkossev.commonLib, line 1708
    if (descMap.value == null || descMap.value == 'FFFF') { return } // invalid or unknown value // library marker kkossev.commonLib, line 1709
    final long value = hexStrToUnsignedInt(descMap.value) // library marker kkossev.commonLib, line 1710
    def lux = value > 0 ? Math.round(Math.pow(10,(value/10000))) : 0 // library marker kkossev.commonLib, line 1711
    handleIlluminanceEvent(lux) // library marker kkossev.commonLib, line 1712
} // library marker kkossev.commonLib, line 1713

void handleIlluminanceEvent( illuminance, Boolean isDigital=false ) { // library marker kkossev.commonLib, line 1715
    def eventMap = [:] // library marker kkossev.commonLib, line 1716
    if (state.stats != null) state.stats['illumCtr'] = (state.stats['illumCtr'] ?: 0) + 1 else state.stats=[:] // library marker kkossev.commonLib, line 1717
    eventMap.name = "illuminance" // library marker kkossev.commonLib, line 1718
    Integer illumCorrected = Math.round((illuminance * ((settings?.illuminanceCoeff ?: 1.00) as float))) // library marker kkossev.commonLib, line 1719
    eventMap.value  = illumCorrected // library marker kkossev.commonLib, line 1720
    eventMap.type = isDigital ? "digital" : "physical" // library marker kkossev.commonLib, line 1721
    eventMap.unit = "lx" // library marker kkossev.commonLib, line 1722
    eventMap.descriptionText = "${eventMap.name} is ${eventMap.value} ${eventMap.unit}" // library marker kkossev.commonLib, line 1723
    Integer timeElapsed = Math.round((now() - (state.lastRx['illumTime'] ?: now()))/1000) // library marker kkossev.commonLib, line 1724
    Integer minTime = settings?.minReportingTime ?: DEFAULT_MIN_REPORTING_TIME // library marker kkossev.commonLib, line 1725
    Integer timeRamaining = (minTime - timeElapsed) as Integer // library marker kkossev.commonLib, line 1726
    Integer lastIllum = device.currentValue("illuminance") ?: 0 // library marker kkossev.commonLib, line 1727
    Integer delta = Math.abs(lastIllum- illumCorrected) // library marker kkossev.commonLib, line 1728
    if (delta < ((settings?.illuminanceThreshold ?: DEFAULT_ILLUMINANCE_THRESHOLD) as int)) { // library marker kkossev.commonLib, line 1729
        logDebug "<b>skipped</b> illuminance ${illumCorrected}, less than delta ${settings?.illuminanceThreshold} (lastIllum=${lastIllum})" // library marker kkossev.commonLib, line 1730
        return // library marker kkossev.commonLib, line 1731
    } // library marker kkossev.commonLib, line 1732
    if (timeElapsed >= minTime) { // library marker kkossev.commonLib, line 1733
        logInfo "${eventMap.descriptionText}" // library marker kkossev.commonLib, line 1734
        unschedule("sendDelayedIllumEvent")        //get rid of stale queued reports // library marker kkossev.commonLib, line 1735
        state.lastRx['illumTime'] = now() // library marker kkossev.commonLib, line 1736
        sendEvent(eventMap) // library marker kkossev.commonLib, line 1737
    }         // library marker kkossev.commonLib, line 1738
    else {         // queue the event // library marker kkossev.commonLib, line 1739
        eventMap.type = "delayed" // library marker kkossev.commonLib, line 1740
        logDebug "${device.displayName} <b>delaying ${timeRamaining} seconds</b> event : ${eventMap}" // library marker kkossev.commonLib, line 1741
        runIn(timeRamaining, 'sendDelayedIllumEvent',  [overwrite: true, data: eventMap]) // library marker kkossev.commonLib, line 1742
    } // library marker kkossev.commonLib, line 1743
} // library marker kkossev.commonLib, line 1744

private void sendDelayedIllumEvent(Map eventMap) { // library marker kkossev.commonLib, line 1746
    logInfo "${eventMap.descriptionText} (${eventMap.type})" // library marker kkossev.commonLib, line 1747
    state.lastRx['illumTime'] = now()     // TODO - -(minReportingTimeHumidity * 2000) // library marker kkossev.commonLib, line 1748
    sendEvent(eventMap) // library marker kkossev.commonLib, line 1749
} // library marker kkossev.commonLib, line 1750

@Field static final Map tuyaIlluminanceOpts = [0: 'low', 1: 'medium', 2: 'high'] // library marker kkossev.commonLib, line 1752


/* // library marker kkossev.commonLib, line 1755
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 1756
 * temperature // library marker kkossev.commonLib, line 1757
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 1758
*/ // library marker kkossev.commonLib, line 1759
void parseTemperatureCluster(final Map descMap) { // library marker kkossev.commonLib, line 1760
    if (state.lastRx == null) { state.lastRx = [:] } // library marker kkossev.commonLib, line 1761
    if (descMap.value == null || descMap.value == 'FFFF') { return } // invalid or unknown value // library marker kkossev.commonLib, line 1762
    final long value = hexStrToUnsignedInt(descMap.value) // library marker kkossev.commonLib, line 1763
    handleTemperatureEvent(value/100.0F as Float) // library marker kkossev.commonLib, line 1764
} // library marker kkossev.commonLib, line 1765

void handleTemperatureEvent( Float temperature, Boolean isDigital=false ) { // library marker kkossev.commonLib, line 1767
    def eventMap = [:] // library marker kkossev.commonLib, line 1768
    if (state.stats != null) state.stats['tempCtr'] = (state.stats['tempCtr'] ?: 0) + 1 else state.stats=[:] // library marker kkossev.commonLib, line 1769
    eventMap.name = "temperature" // library marker kkossev.commonLib, line 1770
    def Scale = location.temperatureScale // library marker kkossev.commonLib, line 1771
    if (Scale == "F") { // library marker kkossev.commonLib, line 1772
        temperature = (temperature * 1.8) + 32 // library marker kkossev.commonLib, line 1773
        eventMap.unit = "\u00B0"+"F" // library marker kkossev.commonLib, line 1774
    } // library marker kkossev.commonLib, line 1775
    else { // library marker kkossev.commonLib, line 1776
        eventMap.unit = "\u00B0"+"C" // library marker kkossev.commonLib, line 1777
    } // library marker kkossev.commonLib, line 1778
    def tempCorrected = (temperature + safeToDouble(settings?.temperatureOffset ?: 0)) as Float // library marker kkossev.commonLib, line 1779
    eventMap.value  =  (Math.round(tempCorrected * 10) / 10.0) as Float // library marker kkossev.commonLib, line 1780
    eventMap.type = isDigital == true ? "digital" : "physical" // library marker kkossev.commonLib, line 1781
    //eventMap.isStateChange = true // library marker kkossev.commonLib, line 1782
    eventMap.descriptionText = "${eventMap.name} is ${eventMap.value} ${eventMap.unit}" // library marker kkossev.commonLib, line 1783
    Integer timeElapsed = Math.round((now() - (state.lastRx['tempTime'] ?: now()))/1000) // library marker kkossev.commonLib, line 1784
    Integer minTime = settings?.minReportingTime ?: DEFAULT_MIN_REPORTING_TIME // library marker kkossev.commonLib, line 1785
    Integer timeRamaining = (minTime - timeElapsed) as Integer // library marker kkossev.commonLib, line 1786
    if (timeElapsed >= minTime) { // library marker kkossev.commonLib, line 1787
        logInfo "${eventMap.descriptionText}" // library marker kkossev.commonLib, line 1788
        unschedule("sendDelayedTempEvent")        //get rid of stale queued reports // library marker kkossev.commonLib, line 1789
        state.lastRx['tempTime'] = now() // library marker kkossev.commonLib, line 1790
        sendEvent(eventMap) // library marker kkossev.commonLib, line 1791
    }         // library marker kkossev.commonLib, line 1792
    else {         // queue the event // library marker kkossev.commonLib, line 1793
        eventMap.type = "delayed" // library marker kkossev.commonLib, line 1794
        logDebug "${device.displayName} DELAYING ${timeRamaining} seconds event : ${eventMap}" // library marker kkossev.commonLib, line 1795
        runIn(timeRamaining, 'sendDelayedTempEvent',  [overwrite: true, data: eventMap]) // library marker kkossev.commonLib, line 1796
    } // library marker kkossev.commonLib, line 1797
} // library marker kkossev.commonLib, line 1798

private void sendDelayedTempEvent(Map eventMap) { // library marker kkossev.commonLib, line 1800
    logInfo "${eventMap.descriptionText} (${eventMap.type})" // library marker kkossev.commonLib, line 1801
    state.lastRx['tempTime'] = now()     // TODO - -(minReportingTimeHumidity * 2000) // library marker kkossev.commonLib, line 1802
    sendEvent(eventMap) // library marker kkossev.commonLib, line 1803
} // library marker kkossev.commonLib, line 1804

/* // library marker kkossev.commonLib, line 1806
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 1807
 * humidity // library marker kkossev.commonLib, line 1808
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 1809
*/ // library marker kkossev.commonLib, line 1810
void parseHumidityCluster(final Map descMap) { // library marker kkossev.commonLib, line 1811
    if (state.lastRx == null) { state.lastRx = [:] } // library marker kkossev.commonLib, line 1812
    if (descMap.value == null || descMap.value == 'FFFF') { return } // invalid or unknown value // library marker kkossev.commonLib, line 1813
    final long value = hexStrToUnsignedInt(descMap.value) // library marker kkossev.commonLib, line 1814
    handleHumidityEvent(value/100.0F as Float) // library marker kkossev.commonLib, line 1815
} // library marker kkossev.commonLib, line 1816

void handleHumidityEvent( Float humidity, Boolean isDigital=false ) { // library marker kkossev.commonLib, line 1818
    def eventMap = [:] // library marker kkossev.commonLib, line 1819
    if (state.stats != null) state.stats['humiCtr'] = (state.stats['humiCtr'] ?: 0) + 1 else state.stats=[:] // library marker kkossev.commonLib, line 1820
    double humidityAsDouble = safeToDouble(humidity) + safeToDouble(settings?.humidityOffset ?: 0) // library marker kkossev.commonLib, line 1821
    if (humidityAsDouble <= 0.0 || humidityAsDouble > 100.0) { // library marker kkossev.commonLib, line 1822
        logWarn "ignored invalid humidity ${humidity} (${humidityAsDouble})" // library marker kkossev.commonLib, line 1823
        return // library marker kkossev.commonLib, line 1824
    } // library marker kkossev.commonLib, line 1825
    eventMap.value = Math.round(humidityAsDouble) // library marker kkossev.commonLib, line 1826
    eventMap.name = "humidity" // library marker kkossev.commonLib, line 1827
    eventMap.unit = "% RH" // library marker kkossev.commonLib, line 1828
    eventMap.type = isDigital == true ? "digital" : "physical" // library marker kkossev.commonLib, line 1829
    //eventMap.isStateChange = true // library marker kkossev.commonLib, line 1830
    eventMap.descriptionText = "${eventMap.name} is ${humidityAsDouble.round(1)} ${eventMap.unit}" // library marker kkossev.commonLib, line 1831
    Integer timeElapsed = Math.round((now() - (state.lastRx['humiTime'] ?: now()))/1000) // library marker kkossev.commonLib, line 1832
    Integer minTime = settings?.minReportingTime ?: DEFAULT_MIN_REPORTING_TIME // library marker kkossev.commonLib, line 1833
    Integer timeRamaining = (minTime - timeElapsed) as Integer     // library marker kkossev.commonLib, line 1834
    if (timeElapsed >= minTime) { // library marker kkossev.commonLib, line 1835
        logInfo "${eventMap.descriptionText}" // library marker kkossev.commonLib, line 1836
        unschedule("sendDelayedHumidityEvent") // library marker kkossev.commonLib, line 1837
        state.lastRx['humiTime'] = now() // library marker kkossev.commonLib, line 1838
        sendEvent(eventMap) // library marker kkossev.commonLib, line 1839
    } // library marker kkossev.commonLib, line 1840
    else { // library marker kkossev.commonLib, line 1841
        eventMap.type = "delayed" // library marker kkossev.commonLib, line 1842
        logDebug "DELAYING ${timeRamaining} seconds event : ${eventMap}" // library marker kkossev.commonLib, line 1843
        runIn(timeRamaining, 'sendDelayedHumidityEvent',  [overwrite: true, data: eventMap]) // library marker kkossev.commonLib, line 1844
    } // library marker kkossev.commonLib, line 1845
} // library marker kkossev.commonLib, line 1846

private void sendDelayedHumidityEvent(Map eventMap) { // library marker kkossev.commonLib, line 1848
    logInfo "${eventMap.descriptionText} (${eventMap.type})" // library marker kkossev.commonLib, line 1849
    state.lastRx['humiTime'] = now()     // TODO - -(minReportingTimeHumidity * 2000) // library marker kkossev.commonLib, line 1850
    sendEvent(eventMap) // library marker kkossev.commonLib, line 1851
} // library marker kkossev.commonLib, line 1852

/* // library marker kkossev.commonLib, line 1854
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 1855
 * Electrical Measurement Cluster 0x0702 // library marker kkossev.commonLib, line 1856
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 1857
*/ // library marker kkossev.commonLib, line 1858

void parseElectricalMeasureCluster(final Map descMap) { // library marker kkossev.commonLib, line 1860
    if (state.lastRx == null) { state.lastRx = [:] } // library marker kkossev.commonLib, line 1861
    if (descMap.value == null || descMap.value == 'FFFF') { return } // invalid or unknown value // library marker kkossev.commonLib, line 1862
    def value = hexStrToUnsignedInt(descMap.value) // library marker kkossev.commonLib, line 1863
    if (DEVICE_TYPE in  ["Switch"]) { // library marker kkossev.commonLib, line 1864
        parseElectricalMeasureClusterSwitch(descMap) // library marker kkossev.commonLib, line 1865
    } // library marker kkossev.commonLib, line 1866
    else { // library marker kkossev.commonLib, line 1867
        logWarn "parseElectricalMeasureCluster is NOT implemented1" // library marker kkossev.commonLib, line 1868
    } // library marker kkossev.commonLib, line 1869
} // library marker kkossev.commonLib, line 1870

/* // library marker kkossev.commonLib, line 1872
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 1873
 * Metering Cluster 0x0B04 // library marker kkossev.commonLib, line 1874
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 1875
*/ // library marker kkossev.commonLib, line 1876

void parseMeteringCluster(final Map descMap) { // library marker kkossev.commonLib, line 1878
    if (state.lastRx == null) { state.lastRx = [:] } // library marker kkossev.commonLib, line 1879
    if (descMap.value == null || descMap.value == 'FFFF') { return } // invalid or unknown value // library marker kkossev.commonLib, line 1880
    def value = hexStrToUnsignedInt(descMap.value) // library marker kkossev.commonLib, line 1881
    if (DEVICE_TYPE in  ["Switch"]) { // library marker kkossev.commonLib, line 1882
        parseMeteringClusterSwitch(descMap) // library marker kkossev.commonLib, line 1883
    } // library marker kkossev.commonLib, line 1884
    else { // library marker kkossev.commonLib, line 1885
        logWarn "parseMeteringCluster is NOT implemented1" // library marker kkossev.commonLib, line 1886
    } // library marker kkossev.commonLib, line 1887
} // library marker kkossev.commonLib, line 1888


/* // library marker kkossev.commonLib, line 1891
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 1892
 * pm2.5 // library marker kkossev.commonLib, line 1893
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 1894
*/ // library marker kkossev.commonLib, line 1895
void parsePm25Cluster(final Map descMap) { // library marker kkossev.commonLib, line 1896
    if (state.lastRx == null) { state.lastRx = [:] } // library marker kkossev.commonLib, line 1897
    if (descMap.value == null || descMap.value == 'FFFF') { return } // invalid or unknown value // library marker kkossev.commonLib, line 1898
    def value = hexStrToUnsignedInt(descMap.value) // library marker kkossev.commonLib, line 1899
    Float floatValue = Float.intBitsToFloat(value.intValue()) // library marker kkossev.commonLib, line 1900
    //logDebug "pm25 float value = ${floatValue}" // library marker kkossev.commonLib, line 1901
    handlePm25Event(floatValue as Integer) // library marker kkossev.commonLib, line 1902
} // library marker kkossev.commonLib, line 1903

void handlePm25Event( Integer pm25, Boolean isDigital=false ) { // library marker kkossev.commonLib, line 1905
    def eventMap = [:] // library marker kkossev.commonLib, line 1906
    if (state.stats != null) state.stats['pm25Ctr'] = (state.stats['pm25Ctr'] ?: 0) + 1 else state.stats=[:] // library marker kkossev.commonLib, line 1907
    double pm25AsDouble = safeToDouble(pm25) + safeToDouble(settings?.pm25Offset ?: 0) // library marker kkossev.commonLib, line 1908
    if (pm25AsDouble <= 0.0 || pm25AsDouble > 999.0) { // library marker kkossev.commonLib, line 1909
        logWarn "ignored invalid pm25 ${pm25} (${pm25AsDouble})" // library marker kkossev.commonLib, line 1910
        return // library marker kkossev.commonLib, line 1911
    } // library marker kkossev.commonLib, line 1912
    eventMap.value = Math.round(pm25AsDouble) // library marker kkossev.commonLib, line 1913
    eventMap.name = "pm25" // library marker kkossev.commonLib, line 1914
    eventMap.unit = "\u03BCg/m3"    //"mg/m3" // library marker kkossev.commonLib, line 1915
    eventMap.type = isDigital == true ? "digital" : "physical" // library marker kkossev.commonLib, line 1916
    eventMap.isStateChange = true // library marker kkossev.commonLib, line 1917
    eventMap.descriptionText = "${eventMap.name} is ${pm25AsDouble.round()} ${eventMap.unit}" // library marker kkossev.commonLib, line 1918
    Integer timeElapsed = Math.round((now() - (state.lastRx['pm25Time'] ?: now()))/1000) // library marker kkossev.commonLib, line 1919
    Integer minTime = settings?.minReportingTimePm25 ?: DEFAULT_MIN_REPORTING_TIME // library marker kkossev.commonLib, line 1920
    Integer timeRamaining = (minTime - timeElapsed) as Integer     // library marker kkossev.commonLib, line 1921
    if (timeElapsed >= minTime) { // library marker kkossev.commonLib, line 1922
        logInfo "${eventMap.descriptionText}" // library marker kkossev.commonLib, line 1923
        unschedule("sendDelayedPm25Event") // library marker kkossev.commonLib, line 1924
        state.lastRx['pm25Time'] = now() // library marker kkossev.commonLib, line 1925
        sendEvent(eventMap) // library marker kkossev.commonLib, line 1926
    } // library marker kkossev.commonLib, line 1927
    else { // library marker kkossev.commonLib, line 1928
        eventMap.type = "delayed" // library marker kkossev.commonLib, line 1929
        logDebug "DELAYING ${timeRamaining} seconds event : ${eventMap}" // library marker kkossev.commonLib, line 1930
        runIn(timeRamaining, 'sendDelayedPm25Event',  [overwrite: true, data: eventMap]) // library marker kkossev.commonLib, line 1931
    } // library marker kkossev.commonLib, line 1932
} // library marker kkossev.commonLib, line 1933

private void sendDelayedPm25Event(Map eventMap) { // library marker kkossev.commonLib, line 1935
    logInfo "${eventMap.descriptionText} (${eventMap.type})" // library marker kkossev.commonLib, line 1936
    state.lastRx['pm25Time'] = now()     // TODO - -(minReportingTimeHumidity * 2000) // library marker kkossev.commonLib, line 1937
    sendEvent(eventMap) // library marker kkossev.commonLib, line 1938
} // library marker kkossev.commonLib, line 1939

/* // library marker kkossev.commonLib, line 1941
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 1942
 * Analog Input Cluster 0x000C // library marker kkossev.commonLib, line 1943
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 1944
*/ // library marker kkossev.commonLib, line 1945
void parseAnalogInputCluster(final Map descMap) { // library marker kkossev.commonLib, line 1946
    if (DEVICE_TYPE in ["AirQuality"]) { // library marker kkossev.commonLib, line 1947
        parseAirQualityIndexCluster(descMap) // library marker kkossev.commonLib, line 1948
    } // library marker kkossev.commonLib, line 1949
    else if (DEVICE_TYPE in ["AqaraCube"]) { // library marker kkossev.commonLib, line 1950
        parseAqaraCubeAnalogInputCluster(descMap) // library marker kkossev.commonLib, line 1951
    } // library marker kkossev.commonLib, line 1952
    else { // library marker kkossev.commonLib, line 1953
        logWarn "parseAnalogInputCluster: don't know how to handle descMap=${descMap}" // library marker kkossev.commonLib, line 1954
    } // library marker kkossev.commonLib, line 1955
} // library marker kkossev.commonLib, line 1956


/* // library marker kkossev.commonLib, line 1959
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 1960
 * Multistate Input Cluster 0x0012 // library marker kkossev.commonLib, line 1961
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 1962
*/ // library marker kkossev.commonLib, line 1963

void parseMultistateInputCluster(final Map descMap) { // library marker kkossev.commonLib, line 1965
    if (state.lastRx == null) { state.lastRx = [:] } // library marker kkossev.commonLib, line 1966
    if (descMap.value == null || descMap.value == 'FFFF') { return } // invalid or unknown value // library marker kkossev.commonLib, line 1967
    def value = hexStrToUnsignedInt(descMap.value) // library marker kkossev.commonLib, line 1968
    Float floatValue = Float.intBitsToFloat(value.intValue()) // library marker kkossev.commonLib, line 1969
    if (DEVICE_TYPE in  ["AqaraCube"]) { // library marker kkossev.commonLib, line 1970
        parseMultistateInputClusterAqaraCube(descMap) // library marker kkossev.commonLib, line 1971
    } // library marker kkossev.commonLib, line 1972
    else { // library marker kkossev.commonLib, line 1973
        handleMultistateInputEvent(value as Integer) // library marker kkossev.commonLib, line 1974
    } // library marker kkossev.commonLib, line 1975
} // library marker kkossev.commonLib, line 1976

void handleMultistateInputEvent( Integer value, Boolean isDigital=false ) { // library marker kkossev.commonLib, line 1978
    def eventMap = [:] // library marker kkossev.commonLib, line 1979
    eventMap.value = value // library marker kkossev.commonLib, line 1980
    eventMap.name = "multistateInput" // library marker kkossev.commonLib, line 1981
    eventMap.unit = "" // library marker kkossev.commonLib, line 1982
    eventMap.type = isDigital == true ? "digital" : "physical" // library marker kkossev.commonLib, line 1983
    eventMap.descriptionText = "${eventMap.name} is ${eventMap.value} ${eventMap.unit}" // library marker kkossev.commonLib, line 1984
    sendEvent(eventMap) // library marker kkossev.commonLib, line 1985
    logInfo "${eventMap.descriptionText}" // library marker kkossev.commonLib, line 1986
} // library marker kkossev.commonLib, line 1987

/* // library marker kkossev.commonLib, line 1989
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 1990
 * Window Covering Cluster 0x0102 // library marker kkossev.commonLib, line 1991
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 1992
*/ // library marker kkossev.commonLib, line 1993

void parseWindowCoveringCluster(final Map descMap) { // library marker kkossev.commonLib, line 1995
    if (state.lastRx == null) { state.lastRx = [:] } // library marker kkossev.commonLib, line 1996
    if (DEVICE_TYPE in  ["ButtonDimmer"]) { // library marker kkossev.commonLib, line 1997
        parseWindowCoveringClusterButtonDimmer(descMap) // library marker kkossev.commonLib, line 1998
    } // library marker kkossev.commonLib, line 1999
    else { // library marker kkossev.commonLib, line 2000
        logWarn "parseWindowCoveringCluster: don't know how to handle descMap=${descMap}" // library marker kkossev.commonLib, line 2001
    } // library marker kkossev.commonLib, line 2002
} // library marker kkossev.commonLib, line 2003

/* // library marker kkossev.commonLib, line 2005
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 2006
 * thermostat cluster 0x0201 // library marker kkossev.commonLib, line 2007
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 2008
*/ // library marker kkossev.commonLib, line 2009
void parseThermostatCluster(final Map descMap) { // library marker kkossev.commonLib, line 2010
    if (state.lastRx == null) { state.lastRx = [:] } // library marker kkossev.commonLib, line 2011
    if (DEVICE_TYPE in  ["Thermostat"]) { // library marker kkossev.commonLib, line 2012
        parseThermostatClusterThermostat(descMap) // library marker kkossev.commonLib, line 2013
    } // library marker kkossev.commonLib, line 2014
    else { // library marker kkossev.commonLib, line 2015
        logWarn "parseThermostatCluster: don't know how to handle descMap=${descMap}" // library marker kkossev.commonLib, line 2016
    } // library marker kkossev.commonLib, line 2017
} // library marker kkossev.commonLib, line 2018



// ------------------------------------------------------------------------------------------------------------------------- // library marker kkossev.commonLib, line 2022

def parseE002Cluster( descMap ) { // library marker kkossev.commonLib, line 2024
    if (DEVICE_TYPE in ["Radar"])     { parseE002ClusterRadar(descMap) }     // library marker kkossev.commonLib, line 2025
    else { // library marker kkossev.commonLib, line 2026
        logWarn "Unprocessed cluster 0xE002 command ${descMap.command} attrId ${descMap.attrId} value ${value} (0x${descMap.value})" // library marker kkossev.commonLib, line 2027
    } // library marker kkossev.commonLib, line 2028
} // library marker kkossev.commonLib, line 2029


/* // library marker kkossev.commonLib, line 2032
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 2033
 * Tuya cluster EF00 specific code // library marker kkossev.commonLib, line 2034
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 2035
*/ // library marker kkossev.commonLib, line 2036
private static getCLUSTER_TUYA()       { 0xEF00 } // library marker kkossev.commonLib, line 2037
private static getSETDATA()            { 0x00 } // library marker kkossev.commonLib, line 2038
private static getSETTIME()            { 0x24 } // library marker kkossev.commonLib, line 2039

// Tuya Commands // library marker kkossev.commonLib, line 2041
private static getTUYA_REQUEST()       { 0x00 } // library marker kkossev.commonLib, line 2042
private static getTUYA_REPORTING()     { 0x01 } // library marker kkossev.commonLib, line 2043
private static getTUYA_QUERY()         { 0x02 } // library marker kkossev.commonLib, line 2044
private static getTUYA_STATUS_SEARCH() { 0x06 } // library marker kkossev.commonLib, line 2045
private static getTUYA_TIME_SYNCHRONISATION() { 0x24 } // library marker kkossev.commonLib, line 2046

// tuya DP type // library marker kkossev.commonLib, line 2048
private static getDP_TYPE_RAW()        { "01" }    // [ bytes ] // library marker kkossev.commonLib, line 2049
private static getDP_TYPE_BOOL()       { "01" }    // [ 0/1 ] // library marker kkossev.commonLib, line 2050
private static getDP_TYPE_VALUE()      { "02" }    // [ 4 byte value ] // library marker kkossev.commonLib, line 2051
private static getDP_TYPE_STRING()     { "03" }    // [ N byte string ] // library marker kkossev.commonLib, line 2052
private static getDP_TYPE_ENUM()       { "04" }    // [ 0-255 ] // library marker kkossev.commonLib, line 2053
private static getDP_TYPE_BITMAP()     { "05" }    // [ 1,2,4 bytes ] as bits // library marker kkossev.commonLib, line 2054


void parseTuyaCluster(final Map descMap) { // library marker kkossev.commonLib, line 2057
    if (descMap?.clusterInt == CLUSTER_TUYA && descMap?.command == "24") {        //getSETTIME // library marker kkossev.commonLib, line 2058
        logDebug "Tuya time synchronization request from device, descMap = ${descMap}" // library marker kkossev.commonLib, line 2059
        def offset = 0 // library marker kkossev.commonLib, line 2060
        try { // library marker kkossev.commonLib, line 2061
            offset = location.getTimeZone().getOffset(new Date().getTime()) // library marker kkossev.commonLib, line 2062
            //if (settings?.logEnable) log.debug "${device.displayName} timezone offset of current location is ${offset}" // library marker kkossev.commonLib, line 2063
        } // library marker kkossev.commonLib, line 2064
        catch(e) { // library marker kkossev.commonLib, line 2065
            logWarn "cannot resolve current location. please set location in Hubitat location setting. Setting timezone offset to zero" // library marker kkossev.commonLib, line 2066
        } // library marker kkossev.commonLib, line 2067
        def cmds = zigbee.command(CLUSTER_TUYA, SETTIME, "0008" +zigbee.convertToHexString((int)(now()/1000),8) +  zigbee.convertToHexString((int)((now()+offset)/1000), 8)) // library marker kkossev.commonLib, line 2068
        logDebug "sending time data : ${cmds}" // library marker kkossev.commonLib, line 2069
        cmds.each{ sendHubCommand(new hubitat.device.HubAction(it, hubitat.device.Protocol.ZIGBEE)) } // library marker kkossev.commonLib, line 2070
        //if (state.txCounter != null) state.txCounter = state.txCounter + 1 // library marker kkossev.commonLib, line 2071
    } // library marker kkossev.commonLib, line 2072
    else if (descMap?.clusterInt == CLUSTER_TUYA && descMap?.command == "0B") {    // ZCL Command Default Response // library marker kkossev.commonLib, line 2073
        String clusterCmd = descMap?.data[0] // library marker kkossev.commonLib, line 2074
        def status = descMap?.data[1]             // library marker kkossev.commonLib, line 2075
        logDebug "device has received Tuya cluster ZCL command 0x${clusterCmd} response 0x${status} data = ${descMap?.data}" // library marker kkossev.commonLib, line 2076
        if (status != "00") { // library marker kkossev.commonLib, line 2077
            logWarn "ATTENTION! manufacturer = ${device.getDataValue("manufacturer")} unsupported Tuya cluster ZCL command 0x${clusterCmd} response 0x${status} data = ${descMap?.data} !!!"                 // library marker kkossev.commonLib, line 2078
        } // library marker kkossev.commonLib, line 2079
    }  // library marker kkossev.commonLib, line 2080
    else if ((descMap?.clusterInt == CLUSTER_TUYA) && (descMap?.command == "01" || descMap?.command == "02" || descMap?.command == "05" || descMap?.command == "06")) // library marker kkossev.commonLib, line 2081
    { // library marker kkossev.commonLib, line 2082
        def dataLen = descMap?.data.size() // library marker kkossev.commonLib, line 2083
        //log.warn "dataLen=${dataLen}" // library marker kkossev.commonLib, line 2084
        def transid = zigbee.convertHexToInt(descMap?.data[1])           // "transid" is just a "counter", a response will have the same transid as the command // library marker kkossev.commonLib, line 2085
        if (dataLen <= 5) { // library marker kkossev.commonLib, line 2086
            logWarn "unprocessed short Tuya command response: dp_id=${descMap?.data[3]} dp=${descMap?.data[2]} fncmd_len=${fncmd_len} data=${descMap?.data})" // library marker kkossev.commonLib, line 2087
            return // library marker kkossev.commonLib, line 2088
        } // library marker kkossev.commonLib, line 2089
        for (int i = 0; i < (dataLen-4); ) { // library marker kkossev.commonLib, line 2090
            def dp = zigbee.convertHexToInt(descMap?.data[2+i])          // "dp" field describes the action/message of a command frame // library marker kkossev.commonLib, line 2091
            def dp_id = zigbee.convertHexToInt(descMap?.data[3+i])       // "dp_identifier" is device dependant // library marker kkossev.commonLib, line 2092
            def fncmd_len = zigbee.convertHexToInt(descMap?.data[5+i])  // library marker kkossev.commonLib, line 2093
            def fncmd = getTuyaAttributeValue(descMap?.data, i)          // // library marker kkossev.commonLib, line 2094
            logDebug "dp_id=${dp_id} dp=${dp} fncmd=${fncmd} fncmd_len=${fncmd_len} (index=${i})" // library marker kkossev.commonLib, line 2095
            processTuyaDP( descMap, dp, dp_id, fncmd) // library marker kkossev.commonLib, line 2096
            i = i + fncmd_len + 4; // library marker kkossev.commonLib, line 2097
        } // library marker kkossev.commonLib, line 2098
    } // library marker kkossev.commonLib, line 2099
    else { // library marker kkossev.commonLib, line 2100
        logWarn "unprocessed Tuya command ${descMap?.command}" // library marker kkossev.commonLib, line 2101
    } // library marker kkossev.commonLib, line 2102
} // library marker kkossev.commonLib, line 2103

void processTuyaDP(descMap, dp, dp_id, fncmd, dp_len=0) { // library marker kkossev.commonLib, line 2105
    if (DEVICE_TYPE in ["Radar"])         { processTuyaDpRadar(descMap, dp, dp_id, fncmd); return }     // library marker kkossev.commonLib, line 2106
    if (DEVICE_TYPE in ["Fingerbot"])     { processTuyaDpFingerbot(descMap, dp, dp_id, fncmd); return }     // library marker kkossev.commonLib, line 2107
    // check if the method  method exists // library marker kkossev.commonLib, line 2108
    if (this.respondsTo(processTuyaDPfromDeviceProfile)) { // library marker kkossev.commonLib, line 2109
        if (processTuyaDPfromDeviceProfile(descMap, dp, dp_id, fncmd, dp_len) == true) {    // sucessfuly processed the new way - we are done.  version 3.0  // library marker kkossev.commonLib, line 2110
            return // library marker kkossev.commonLib, line 2111
        }     // library marker kkossev.commonLib, line 2112
    } // library marker kkossev.commonLib, line 2113
    switch (dp) { // library marker kkossev.commonLib, line 2114
        case 0x01 : // on/off // library marker kkossev.commonLib, line 2115
            if (DEVICE_TYPE in  ["LightSensor"]) { // library marker kkossev.commonLib, line 2116
                logDebug "LightSensor BrightnessLevel = ${tuyaIlluminanceOpts[fncmd as int]} (${fncmd})" // library marker kkossev.commonLib, line 2117
            } // library marker kkossev.commonLib, line 2118
            else { // library marker kkossev.commonLib, line 2119
                sendSwitchEvent(fncmd) // library marker kkossev.commonLib, line 2120
            } // library marker kkossev.commonLib, line 2121
            break // library marker kkossev.commonLib, line 2122
        case 0x02 : // library marker kkossev.commonLib, line 2123
            if (DEVICE_TYPE in  ["LightSensor"]) { // library marker kkossev.commonLib, line 2124
                handleIlluminanceEvent(fncmd) // library marker kkossev.commonLib, line 2125
            } // library marker kkossev.commonLib, line 2126
            else { // library marker kkossev.commonLib, line 2127
                logDebug "Tuya cmd: dp=${dp} value=${fncmd} descMap.data = ${descMap?.data}"  // library marker kkossev.commonLib, line 2128
            } // library marker kkossev.commonLib, line 2129
            break // library marker kkossev.commonLib, line 2130
        case 0x04 : // battery // library marker kkossev.commonLib, line 2131
            sendBatteryPercentageEvent(fncmd) // library marker kkossev.commonLib, line 2132
            break // library marker kkossev.commonLib, line 2133
        default : // library marker kkossev.commonLib, line 2134
            logWarn "<b>NOT PROCESSED</b> Tuya cmd: dp=${dp} value=${fncmd} descMap.data = ${descMap?.data}"  // library marker kkossev.commonLib, line 2135
            break             // library marker kkossev.commonLib, line 2136
    } // library marker kkossev.commonLib, line 2137
} // library marker kkossev.commonLib, line 2138

private int getTuyaAttributeValue(ArrayList _data, index) { // library marker kkossev.commonLib, line 2140
    int retValue = 0 // library marker kkossev.commonLib, line 2141

    if (_data.size() >= 6) { // library marker kkossev.commonLib, line 2143
        int dataLength = _data[5+index] as Integer // library marker kkossev.commonLib, line 2144
        int power = 1; // library marker kkossev.commonLib, line 2145
        for (i in dataLength..1) { // library marker kkossev.commonLib, line 2146
            retValue = retValue + power * zigbee.convertHexToInt(_data[index+i+5]) // library marker kkossev.commonLib, line 2147
            power = power * 256 // library marker kkossev.commonLib, line 2148
        } // library marker kkossev.commonLib, line 2149
    } // library marker kkossev.commonLib, line 2150
    return retValue // library marker kkossev.commonLib, line 2151
} // library marker kkossev.commonLib, line 2152


private sendTuyaCommand(dp, dp_type, fncmd) { // library marker kkossev.commonLib, line 2155
    ArrayList<String> cmds = [] // library marker kkossev.commonLib, line 2156
    def ep = safeToInt(state.destinationEP) // library marker kkossev.commonLib, line 2157
    if (ep==null || ep==0) ep = 1 // library marker kkossev.commonLib, line 2158
    def tuyaCmd = isFingerbot() ? 0x04 : SETDATA // library marker kkossev.commonLib, line 2159

    cmds += zigbee.command(CLUSTER_TUYA, tuyaCmd, [destEndpoint :ep], PACKET_ID + dp + dp_type + zigbee.convertToHexString((int)(fncmd.length()/2), 4) + fncmd ) // library marker kkossev.commonLib, line 2161
    logDebug "${device.displayName} sendTuyaCommand = ${cmds}" // library marker kkossev.commonLib, line 2162
    return cmds // library marker kkossev.commonLib, line 2163
} // library marker kkossev.commonLib, line 2164

private getPACKET_ID() { // library marker kkossev.commonLib, line 2166
    return zigbee.convertToHexString(new Random().nextInt(65536), 4)  // library marker kkossev.commonLib, line 2167
} // library marker kkossev.commonLib, line 2168

def tuyaTest( dpCommand, dpValue, dpTypeString ) { // library marker kkossev.commonLib, line 2170
    ArrayList<String> cmds = [] // library marker kkossev.commonLib, line 2171
    def dpType   = dpTypeString=="DP_TYPE_VALUE" ? DP_TYPE_VALUE : dpTypeString=="DP_TYPE_BOOL" ? DP_TYPE_BOOL : dpTypeString=="DP_TYPE_ENUM" ? DP_TYPE_ENUM : null // library marker kkossev.commonLib, line 2172
    def dpValHex = dpTypeString=="DP_TYPE_VALUE" ? zigbee.convertToHexString(dpValue as int, 8) : dpValue // library marker kkossev.commonLib, line 2173

    if (settings?.logEnable) log.warn "${device.displayName}  sending TEST command=${dpCommand} value=${dpValue} ($dpValHex) type=${dpType}" // library marker kkossev.commonLib, line 2175

    sendZigbeeCommands( sendTuyaCommand(dpCommand, dpType, dpValHex) ) // library marker kkossev.commonLib, line 2177
} // library marker kkossev.commonLib, line 2178

private getANALOG_INPUT_BASIC_CLUSTER() { 0x000C } // library marker kkossev.commonLib, line 2180
private getANALOG_INPUT_BASIC_PRESENT_VALUE_ATTRIBUTE() { 0x0055 } // library marker kkossev.commonLib, line 2181

def tuyaBlackMagic() { // library marker kkossev.commonLib, line 2183
    def ep = safeToInt(state.destinationEP ?: 01) // library marker kkossev.commonLib, line 2184
    if (ep==null || ep==0) ep = 1 // library marker kkossev.commonLib, line 2185
    return zigbee.readAttribute(0x0000, [0x0004, 0x000, 0x0001, 0x0005, 0x0007, 0xfffe], [destEndpoint :ep], delay=200) // library marker kkossev.commonLib, line 2186
} // library marker kkossev.commonLib, line 2187

void aqaraBlackMagic() { // library marker kkossev.commonLib, line 2189
    List<String> cmds = [] // library marker kkossev.commonLib, line 2190
    if (isAqaraTVOC() || isAqaraTRV_OLD()) { // library marker kkossev.commonLib, line 2191
        cmds += ["he raw 0x${device.deviceNetworkId} 0 0 0x8002 {40 00 00 00 00 40 8f 5f 11 52 52 00 41 2c 52 00 00} {0x0000}", "delay 200",] // library marker kkossev.commonLib, line 2192
        cmds += "zdo bind 0x${device.deviceNetworkId} 0x01 0x01 0xFCC0 {${device.zigbeeId}} {}" // library marker kkossev.commonLib, line 2193
        cmds += "zdo bind 0x${device.deviceNetworkId} 0x01 0x01 0x0406 {${device.zigbeeId}} {}" // library marker kkossev.commonLib, line 2194
        cmds += zigbee.readAttribute(0x0001, 0x0020, [:], delay=200)    // TODO: check - battery voltage // library marker kkossev.commonLib, line 2195
        if (isAqaraTVOC()) { // library marker kkossev.commonLib, line 2196
            cmds += zigbee.readAttribute(0xFCC0, [0x0102, 0x010C], [mfgCode: 0x115F], delay=200)    // TVOC only // library marker kkossev.commonLib, line 2197
        } // library marker kkossev.commonLib, line 2198
        sendZigbeeCommands( cmds ) // library marker kkossev.commonLib, line 2199
        logDebug "sent aqaraBlackMagic()" // library marker kkossev.commonLib, line 2200
    } // library marker kkossev.commonLib, line 2201
    else { // library marker kkossev.commonLib, line 2202
        logDebug "aqaraBlackMagic() was SKIPPED" // library marker kkossev.commonLib, line 2203
    } // library marker kkossev.commonLib, line 2204
} // library marker kkossev.commonLib, line 2205


/** // library marker kkossev.commonLib, line 2208
 * initializes the device // library marker kkossev.commonLib, line 2209
 * Invoked from configure() // library marker kkossev.commonLib, line 2210
 * @return zigbee commands // library marker kkossev.commonLib, line 2211
 */ // library marker kkossev.commonLib, line 2212
def initializeDevice() { // library marker kkossev.commonLib, line 2213
    ArrayList<String> cmds = [] // library marker kkossev.commonLib, line 2214
    logInfo 'initializeDevice...' // library marker kkossev.commonLib, line 2215

    // start with the device-specific initialization first. // library marker kkossev.commonLib, line 2217
    if (DEVICE_TYPE in  ["AirQuality"])          { return initializeDeviceAirQuality() } // library marker kkossev.commonLib, line 2218
    else if (DEVICE_TYPE in  ["IRBlaster"])      { return initializeDeviceIrBlaster() } // library marker kkossev.commonLib, line 2219
    else if (DEVICE_TYPE in  ["Radar"])          { return initializeDeviceRadar() } // library marker kkossev.commonLib, line 2220
    else if (DEVICE_TYPE in  ["ButtonDimmer"])   { return initializeDeviceButtonDimmer() } // library marker kkossev.commonLib, line 2221


    // not specific device type - do some generic initializations // library marker kkossev.commonLib, line 2224
    if (DEVICE_TYPE in  ["THSensor"]) { // library marker kkossev.commonLib, line 2225
        cmds += zigbee.configureReporting(zigbee.TEMPERATURE_MEASUREMENT_CLUSTER, 0 /*TEMPERATURE_MEASUREMENT_MEASURED_VALUE_ATTRIBUTE*/, DataType.INT16, 15, 300, 100 /* 100=0.1도*/)                // 402 - temperature // library marker kkossev.commonLib, line 2226
        cmds += zigbee.configureReporting(zigbee.RELATIVE_HUMIDITY_MEASUREMENT_CLUSTER, 0 /*RALATIVE_HUMIDITY_MEASUREMENT_MEASURED_VALUE_ATTRIBUTE*/, DataType.UINT16, 15, 300, 400/*10/100=0.4%*/)   // 405 - humidity // library marker kkossev.commonLib, line 2227
    } // library marker kkossev.commonLib, line 2228
    // // library marker kkossev.commonLib, line 2229
    if (cmds == []) { // library marker kkossev.commonLib, line 2230
        cmds = ["delay 299"] // library marker kkossev.commonLib, line 2231
    } // library marker kkossev.commonLib, line 2232
    return cmds // library marker kkossev.commonLib, line 2233
} // library marker kkossev.commonLib, line 2234


/** // library marker kkossev.commonLib, line 2237
 * configures the device // library marker kkossev.commonLib, line 2238
 * Invoked from updated() // library marker kkossev.commonLib, line 2239
 * @return zigbee commands // library marker kkossev.commonLib, line 2240
 */ // library marker kkossev.commonLib, line 2241
def configureDevice() { // library marker kkossev.commonLib, line 2242
    ArrayList<String> cmds = [] // library marker kkossev.commonLib, line 2243
    logInfo 'configureDevice...' // library marker kkossev.commonLib, line 2244

    if (DEVICE_TYPE in  ["AirQuality"]) { cmds += configureDeviceAirQuality() } // library marker kkossev.commonLib, line 2246
    else if (DEVICE_TYPE in  ["Fingerbot"])  { cmds += configureDeviceFingerbot() } // library marker kkossev.commonLib, line 2247
    else if (DEVICE_TYPE in  ["AqaraCube"])  { cmds += configureDeviceAqaraCube() } // library marker kkossev.commonLib, line 2248
    else if (DEVICE_TYPE in  ["Switch"])     { cmds += configureDeviceSwitch() } // library marker kkossev.commonLib, line 2249
    else if (DEVICE_TYPE in  ["IRBlaster"])  { cmds += configureDeviceIrBlaster() } // library marker kkossev.commonLib, line 2250
    else if (DEVICE_TYPE in  ["Radar"])      { cmds += configureDeviceRadar() } // library marker kkossev.commonLib, line 2251
    else if (DEVICE_TYPE in  ["ButtonDimmer"]) { cmds += configureDeviceButtonDimmer() } // library marker kkossev.commonLib, line 2252
    else if (DEVICE_TYPE in  ["Bulb"])       { cmds += configureBulb() } // library marker kkossev.commonLib, line 2253
    if (cmds == []) {  // library marker kkossev.commonLib, line 2254
        cmds = ["delay 277",] // library marker kkossev.commonLib, line 2255
    } // library marker kkossev.commonLib, line 2256
    sendZigbeeCommands(cmds)   // library marker kkossev.commonLib, line 2257
} // library marker kkossev.commonLib, line 2258

/* // library marker kkossev.commonLib, line 2260
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 2261
 * Hubitat default handlers methods // library marker kkossev.commonLib, line 2262
 * ----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 2263
*/ // library marker kkossev.commonLib, line 2264

def refresh() { // library marker kkossev.commonLib, line 2266
    logInfo "refresh()... DEVICE_TYPE is ${DEVICE_TYPE}" // library marker kkossev.commonLib, line 2267
    checkDriverVersion() // library marker kkossev.commonLib, line 2268
    List<String> cmds = [] // library marker kkossev.commonLib, line 2269
    if (state.states == null) state.states = [:] // library marker kkossev.commonLib, line 2270
    state.states["isRefresh"] = true // library marker kkossev.commonLib, line 2271

    // device type specific refresh handlers // library marker kkossev.commonLib, line 2273
    if (DEVICE_TYPE in  ["AqaraCube"])       { cmds += refreshAqaraCube() } // library marker kkossev.commonLib, line 2274
    else if (DEVICE_TYPE in  ["Fingerbot"])  { cmds += refreshFingerbot() } // library marker kkossev.commonLib, line 2275
    else if (DEVICE_TYPE in  ["AirQuality"]) { cmds += refreshAirQuality() } // library marker kkossev.commonLib, line 2276
    else if (DEVICE_TYPE in  ["Switch"])     { cmds += refreshSwitch() } // library marker kkossev.commonLib, line 2277
    else if (DEVICE_TYPE in  ["IRBlaster"])  { cmds += refreshIrBlaster() } // library marker kkossev.commonLib, line 2278
    else if (DEVICE_TYPE in  ["Radar"])      { cmds += refreshRadar() } // library marker kkossev.commonLib, line 2279
    else if (DEVICE_TYPE in  ["Thermostat"]) { cmds += refreshThermostat() } // library marker kkossev.commonLib, line 2280
    else if (DEVICE_TYPE in  ["Bulb"])       { cmds += refreshBulb() } // library marker kkossev.commonLib, line 2281
    else { // library marker kkossev.commonLib, line 2282
        // generic refresh handling, based on teh device capabilities  // library marker kkossev.commonLib, line 2283
        if (device.hasCapability("Battery")) { // library marker kkossev.commonLib, line 2284
            cmds += zigbee.readAttribute(0x0001, 0x0020, [:], delay=200)         // battery voltage // library marker kkossev.commonLib, line 2285
            cmds += zigbee.readAttribute(0x0001, 0x0021, [:], delay=200)         // battery percentage  // library marker kkossev.commonLib, line 2286
        } // library marker kkossev.commonLib, line 2287
        if (DEVICE_TYPE in  ["Plug", "Dimmer"]) { // library marker kkossev.commonLib, line 2288
            cmds += zigbee.readAttribute(0x0006, 0x0000, [:], delay=200) // library marker kkossev.commonLib, line 2289
            cmds += zigbee.command(zigbee.GROUPS_CLUSTER, 0x02, [:], DELAY_MS, '00')            // Get group membership // library marker kkossev.commonLib, line 2290
        } // library marker kkossev.commonLib, line 2291
        if (DEVICE_TYPE in  ["Dimmer"]) { // library marker kkossev.commonLib, line 2292
            cmds += zigbee.readAttribute(0x0008, 0x0000, [:], delay=200)         // library marker kkossev.commonLib, line 2293
        } // library marker kkossev.commonLib, line 2294
        if (DEVICE_TYPE in  ["THSensor", "AirQuality"]) { // library marker kkossev.commonLib, line 2295
            cmds += zigbee.readAttribute(0x0402, 0x0000, [:], delay=200)         // library marker kkossev.commonLib, line 2296
            cmds += zigbee.readAttribute(0x0405, 0x0000, [:], delay=200)         // library marker kkossev.commonLib, line 2297
        } // library marker kkossev.commonLib, line 2298
    } // library marker kkossev.commonLib, line 2299

    runInMillis( REFRESH_TIMER, clearRefreshRequest, [overwrite: true])                 // 3 seconds // library marker kkossev.commonLib, line 2301
    if (cmds != null && cmds != [] ) { // library marker kkossev.commonLib, line 2302
        sendZigbeeCommands(cmds) // library marker kkossev.commonLib, line 2303
    } // library marker kkossev.commonLib, line 2304
    else { // library marker kkossev.commonLib, line 2305
        logDebug "no refresh() commands defined for device type ${DEVICE_TYPE}" // library marker kkossev.commonLib, line 2306
    } // library marker kkossev.commonLib, line 2307
} // library marker kkossev.commonLib, line 2308

def clearRefreshRequest() { if (state.states == null) {state.states = [:] }; state.states["isRefresh"] = false } // library marker kkossev.commonLib, line 2310

void clearInfoEvent() { // library marker kkossev.commonLib, line 2312
    sendInfoEvent('clear') // library marker kkossev.commonLib, line 2313
} // library marker kkossev.commonLib, line 2314

void sendInfoEvent(String info=null) { // library marker kkossev.commonLib, line 2316
    if (info == null || info == "clear") { // library marker kkossev.commonLib, line 2317
        logDebug "clearing the Info event" // library marker kkossev.commonLib, line 2318
        sendEvent(name: "Info", value: " ", isDigital: true) // library marker kkossev.commonLib, line 2319
    } // library marker kkossev.commonLib, line 2320
    else { // library marker kkossev.commonLib, line 2321
        logInfo "${info}" // library marker kkossev.commonLib, line 2322
        sendEvent(name: "Info", value: info, isDigital: true) // library marker kkossev.commonLib, line 2323
        runIn(INFO_AUTO_CLEAR_PERIOD, "clearInfoEvent")            // automatically clear the Info attribute after 1 minute // library marker kkossev.commonLib, line 2324
    } // library marker kkossev.commonLib, line 2325
} // library marker kkossev.commonLib, line 2326

def ping() { // library marker kkossev.commonLib, line 2328
    if (!(isAqaraTVOC())) { // library marker kkossev.commonLib, line 2329
        if (state.lastTx == nill ) state.lastTx = [:]  // library marker kkossev.commonLib, line 2330
        state.lastTx["pingTime"] = new Date().getTime() // library marker kkossev.commonLib, line 2331
        if (state.states == nill ) state.states = [:]  // library marker kkossev.commonLib, line 2332
        state.states["isPing"] = true // library marker kkossev.commonLib, line 2333
        scheduleCommandTimeoutCheck() // library marker kkossev.commonLib, line 2334
        sendZigbeeCommands( zigbee.readAttribute(zigbee.BASIC_CLUSTER, 0x01, [:], 0) ) // library marker kkossev.commonLib, line 2335
        logDebug 'ping...' // library marker kkossev.commonLib, line 2336
    } // library marker kkossev.commonLib, line 2337
    else { // library marker kkossev.commonLib, line 2338
        // Aqara TVOC is sleepy or does not respond to the ping. // library marker kkossev.commonLib, line 2339
        logInfo "ping() command is not available for this sleepy device." // library marker kkossev.commonLib, line 2340
        sendRttEvent("n/a") // library marker kkossev.commonLib, line 2341
    } // library marker kkossev.commonLib, line 2342
} // library marker kkossev.commonLib, line 2343

/** // library marker kkossev.commonLib, line 2345
 * sends 'rtt'event (after a ping() command) // library marker kkossev.commonLib, line 2346
 * @param null: calculate the RTT in ms // library marker kkossev.commonLib, line 2347
 *        value: send the text instead ('timeout', 'n/a', etc..) // library marker kkossev.commonLib, line 2348
 * @return none // library marker kkossev.commonLib, line 2349
 */ // library marker kkossev.commonLib, line 2350
void sendRttEvent( String value=null) { // library marker kkossev.commonLib, line 2351
    def now = new Date().getTime() // library marker kkossev.commonLib, line 2352
    if (state.lastTx == null ) state.lastTx = [:] // library marker kkossev.commonLib, line 2353
    def timeRunning = now.toInteger() - (state.lastTx["pingTime"] ?: now).toInteger() // library marker kkossev.commonLib, line 2354
    def descriptionText = "Round-trip time is ${timeRunning} ms (min=${state.stats["pingsMin"]} max=${state.stats["pingsMax"]} average=${state.stats["pingsAvg"]})" // library marker kkossev.commonLib, line 2355
    if (value == null) { // library marker kkossev.commonLib, line 2356
        logInfo "${descriptionText}" // library marker kkossev.commonLib, line 2357
        sendEvent(name: "rtt", value: timeRunning, descriptionText: descriptionText, unit: "ms", isDigital: true)     // library marker kkossev.commonLib, line 2358
    } // library marker kkossev.commonLib, line 2359
    else { // library marker kkossev.commonLib, line 2360
        descriptionText = "Round-trip time : ${value}" // library marker kkossev.commonLib, line 2361
        logInfo "${descriptionText}" // library marker kkossev.commonLib, line 2362
        sendEvent(name: "rtt", value: value, descriptionText: descriptionText, isDigital: true)     // library marker kkossev.commonLib, line 2363
    } // library marker kkossev.commonLib, line 2364
} // library marker kkossev.commonLib, line 2365

/** // library marker kkossev.commonLib, line 2367
 * Lookup the cluster name from the cluster ID // library marker kkossev.commonLib, line 2368
 * @param cluster cluster ID // library marker kkossev.commonLib, line 2369
 * @return cluster name if known, otherwise "private cluster" // library marker kkossev.commonLib, line 2370
 */ // library marker kkossev.commonLib, line 2371
private String clusterLookup(final Object cluster) { // library marker kkossev.commonLib, line 2372
    if (cluster != null) { // library marker kkossev.commonLib, line 2373
        return zigbee.clusterLookup(cluster.toInteger()) ?: "private cluster 0x${intToHexStr(cluster.toInteger())}" // library marker kkossev.commonLib, line 2374
    } // library marker kkossev.commonLib, line 2375
    else { // library marker kkossev.commonLib, line 2376
        logWarn "cluster is NULL!" // library marker kkossev.commonLib, line 2377
        return "NULL" // library marker kkossev.commonLib, line 2378
    } // library marker kkossev.commonLib, line 2379
} // library marker kkossev.commonLib, line 2380

private void scheduleCommandTimeoutCheck(int delay = COMMAND_TIMEOUT) { // library marker kkossev.commonLib, line 2382
    runIn(delay, 'deviceCommandTimeout') // library marker kkossev.commonLib, line 2383
} // library marker kkossev.commonLib, line 2384

void deviceCommandTimeout() { // library marker kkossev.commonLib, line 2386
    logWarn 'no response received (sleepy device or offline?)' // library marker kkossev.commonLib, line 2387
    sendRttEvent("timeout") // library marker kkossev.commonLib, line 2388
    state.stats['pingsFail'] = (state.stats['pingsFail'] ?: 0) + 1 // library marker kkossev.commonLib, line 2389
} // library marker kkossev.commonLib, line 2390

/** // library marker kkossev.commonLib, line 2392
 * Schedule a device health check // library marker kkossev.commonLib, line 2393
 * @param intervalMins interval in minutes // library marker kkossev.commonLib, line 2394
 */ // library marker kkossev.commonLib, line 2395
private void scheduleDeviceHealthCheck(final int intervalMins, final int healthMethod) { // library marker kkossev.commonLib, line 2396
    if (healthMethod == 1 || healthMethod == 2)  { // library marker kkossev.commonLib, line 2397
        String cron = getCron( intervalMins*60 ) // library marker kkossev.commonLib, line 2398
        schedule(cron, 'deviceHealthCheck') // library marker kkossev.commonLib, line 2399
        logDebug "deviceHealthCheck is scheduled every ${intervalMins} minutes" // library marker kkossev.commonLib, line 2400
    } // library marker kkossev.commonLib, line 2401
    else { // library marker kkossev.commonLib, line 2402
        logWarn "deviceHealthCheck is not scheduled!" // library marker kkossev.commonLib, line 2403
        unschedule('deviceHealthCheck') // library marker kkossev.commonLib, line 2404
    } // library marker kkossev.commonLib, line 2405
} // library marker kkossev.commonLib, line 2406

private void unScheduleDeviceHealthCheck() { // library marker kkossev.commonLib, line 2408
    unschedule('deviceHealthCheck') // library marker kkossev.commonLib, line 2409
    device.deleteCurrentState('healthStatus') // library marker kkossev.commonLib, line 2410
    logWarn "device health check is disabled!" // library marker kkossev.commonLib, line 2411

} // library marker kkossev.commonLib, line 2413

// called when any event was received from the Zigbee device in the parse() method. // library marker kkossev.commonLib, line 2415
void setHealthStatusOnline() { // library marker kkossev.commonLib, line 2416
    if(state.health == null) { state.health = [:] } // library marker kkossev.commonLib, line 2417
    state.health['checkCtr3']  = 0 // library marker kkossev.commonLib, line 2418
    if (!((device.currentValue('healthStatus') ?: 'unknown') in ['online'])) {    // library marker kkossev.commonLib, line 2419
        sendHealthStatusEvent('online') // library marker kkossev.commonLib, line 2420
        logInfo "is now online!" // library marker kkossev.commonLib, line 2421
    } // library marker kkossev.commonLib, line 2422
} // library marker kkossev.commonLib, line 2423


def deviceHealthCheck() { // library marker kkossev.commonLib, line 2426
    if (state.health == null) { state.health = [:] } // library marker kkossev.commonLib, line 2427
    def ctr = state.health['checkCtr3'] ?: 0 // library marker kkossev.commonLib, line 2428
    if (ctr  >= PRESENCE_COUNT_THRESHOLD) { // library marker kkossev.commonLib, line 2429
        if ((device.currentValue("healthStatus") ?: 'unknown') != 'offline' ) { // library marker kkossev.commonLib, line 2430
            logWarn "not present!" // library marker kkossev.commonLib, line 2431
            sendHealthStatusEvent('offline') // library marker kkossev.commonLib, line 2432
        } // library marker kkossev.commonLib, line 2433
    } // library marker kkossev.commonLib, line 2434
    else { // library marker kkossev.commonLib, line 2435
        logDebug "deviceHealthCheck - online (notPresentCounter=${ctr})" // library marker kkossev.commonLib, line 2436
    } // library marker kkossev.commonLib, line 2437
    state.health['checkCtr3'] = ctr + 1 // library marker kkossev.commonLib, line 2438
} // library marker kkossev.commonLib, line 2439

void sendHealthStatusEvent(value) { // library marker kkossev.commonLib, line 2441
    def descriptionText = "healthStatus changed to ${value}" // library marker kkossev.commonLib, line 2442
    sendEvent(name: "healthStatus", value: value, descriptionText: descriptionText, isStateChange: true, isDigital: true) // library marker kkossev.commonLib, line 2443
    if (value == 'online') { // library marker kkossev.commonLib, line 2444
        logInfo "${descriptionText}" // library marker kkossev.commonLib, line 2445
    } // library marker kkossev.commonLib, line 2446
    else { // library marker kkossev.commonLib, line 2447
        if (settings?.txtEnable) { log.warn "${device.displayName}} <b>${descriptionText}</b>" } // library marker kkossev.commonLib, line 2448
    } // library marker kkossev.commonLib, line 2449
} // library marker kkossev.commonLib, line 2450



/** // library marker kkossev.commonLib, line 2454
 * Scheduled job for polling device specific attribute(s) // library marker kkossev.commonLib, line 2455
 */ // library marker kkossev.commonLib, line 2456
void autoPoll() { // library marker kkossev.commonLib, line 2457
    logDebug "autoPoll()..." // library marker kkossev.commonLib, line 2458
    checkDriverVersion() // library marker kkossev.commonLib, line 2459
    List<String> cmds = [] // library marker kkossev.commonLib, line 2460
    if (state.states == null) state.states = [:] // library marker kkossev.commonLib, line 2461
    //state.states["isRefresh"] = true // library marker kkossev.commonLib, line 2462

    if (DEVICE_TYPE in  ["AirQuality"]) { // library marker kkossev.commonLib, line 2464
        cmds += zigbee.readAttribute(0xfc7e, 0x0000, [mfgCode: 0x117c], delay=200)      // tVOC   !! mfcode="0x117c" !! attributes: (float) 0: Measured Value; 1: Min Measured Value; 2:Max Measured Value; // library marker kkossev.commonLib, line 2465
    } // library marker kkossev.commonLib, line 2466

    if (cmds != null && cmds != [] ) { // library marker kkossev.commonLib, line 2468
        sendZigbeeCommands(cmds) // library marker kkossev.commonLib, line 2469
    }     // library marker kkossev.commonLib, line 2470
} // library marker kkossev.commonLib, line 2471


/** // library marker kkossev.commonLib, line 2474
 * Invoked by Hubitat when the driver configuration is updated // library marker kkossev.commonLib, line 2475
 */ // library marker kkossev.commonLib, line 2476
void updated() { // library marker kkossev.commonLib, line 2477
    logInfo 'updated...' // library marker kkossev.commonLib, line 2478
    logInfo"driver version ${driverVersionAndTimeStamp()}" // library marker kkossev.commonLib, line 2479
    unschedule() // library marker kkossev.commonLib, line 2480

    if (settings.logEnable) { // library marker kkossev.commonLib, line 2482
        logTrace settings // library marker kkossev.commonLib, line 2483
        runIn(86400, logsOff) // library marker kkossev.commonLib, line 2484
    } // library marker kkossev.commonLib, line 2485
    if (settings.traceEnable) { // library marker kkossev.commonLib, line 2486
        logTrace settings // library marker kkossev.commonLib, line 2487
        runIn(1800, traceOff) // library marker kkossev.commonLib, line 2488
    }     // library marker kkossev.commonLib, line 2489

    final int healthMethod = (settings.healthCheckMethod as Integer) ?: 0 // library marker kkossev.commonLib, line 2491
    if (healthMethod == 1 || healthMethod == 2) {                            //    [0: 'Disabled', 1: 'Activity check', 2: 'Periodic polling'] // library marker kkossev.commonLib, line 2492
        // schedule the periodic timer // library marker kkossev.commonLib, line 2493
        final int interval = (settings.healthCheckInterval as Integer) ?: 0 // library marker kkossev.commonLib, line 2494
        if (interval > 0) { // library marker kkossev.commonLib, line 2495
            //log.trace "healthMethod=${healthMethod} interval=${interval}" // library marker kkossev.commonLib, line 2496
            log.info "scheduling health check every ${interval} minutes by ${HealthcheckMethodOpts.options[healthCheckMethod as int]} method" // library marker kkossev.commonLib, line 2497
            scheduleDeviceHealthCheck(interval, healthMethod) // library marker kkossev.commonLib, line 2498
        } // library marker kkossev.commonLib, line 2499
    } // library marker kkossev.commonLib, line 2500
    else { // library marker kkossev.commonLib, line 2501
        unScheduleDeviceHealthCheck()        // unschedule the periodic job, depending on the healthMethod // library marker kkossev.commonLib, line 2502
        log.info "Health Check is disabled!" // library marker kkossev.commonLib, line 2503
    } // library marker kkossev.commonLib, line 2504

    if (DEVICE_TYPE in ["AirQuality"])  { updatedAirQuality() } // library marker kkossev.commonLib, line 2506
    if (DEVICE_TYPE in ["IRBlaster"])   { updatedIrBlaster() } // library marker kkossev.commonLib, line 2507
    if (DEVICE_TYPE in ["Thermostat"])  { updatedThermostat() } // library marker kkossev.commonLib, line 2508

    //configureDevice()    // sends Zigbee commands  // commented out 11/18/2023 // library marker kkossev.commonLib, line 2510

    sendInfoEvent("updated") // library marker kkossev.commonLib, line 2512
} // library marker kkossev.commonLib, line 2513

/** // library marker kkossev.commonLib, line 2515
 * Disable logging (for debugging) // library marker kkossev.commonLib, line 2516
 */ // library marker kkossev.commonLib, line 2517
void logsOff() { // library marker kkossev.commonLib, line 2518
    logInfo "debug logging disabled..." // library marker kkossev.commonLib, line 2519
    device.updateSetting('logEnable', [value: 'false', type: 'bool']) // library marker kkossev.commonLib, line 2520
} // library marker kkossev.commonLib, line 2521
void traceOff() { // library marker kkossev.commonLib, line 2522
    logInfo "trace logging disabled..." // library marker kkossev.commonLib, line 2523
    device.updateSetting('traceEnable', [value: 'false', type: 'bool']) // library marker kkossev.commonLib, line 2524
} // library marker kkossev.commonLib, line 2525

def configure(command) { // library marker kkossev.commonLib, line 2527
    ArrayList<String> cmds = [] // library marker kkossev.commonLib, line 2528
    logInfo "configure(${command})..." // library marker kkossev.commonLib, line 2529

    Boolean validated = false // library marker kkossev.commonLib, line 2531
    if (!(command in (ConfigureOpts.keySet() as List))) { // library marker kkossev.commonLib, line 2532
        logWarn "configure: command <b>${command}</b> must be one of these : ${ConfigureOpts.keySet() as List}" // library marker kkossev.commonLib, line 2533
        return // library marker kkossev.commonLib, line 2534
    } // library marker kkossev.commonLib, line 2535
    // // library marker kkossev.commonLib, line 2536
    def func // library marker kkossev.commonLib, line 2537
   // try { // library marker kkossev.commonLib, line 2538
        func = ConfigureOpts[command]?.function // library marker kkossev.commonLib, line 2539
        cmds = "$func"() // library marker kkossev.commonLib, line 2540
 //   } // library marker kkossev.commonLib, line 2541
//    catch (e) { // library marker kkossev.commonLib, line 2542
//        logWarn "Exception ${e} caught while processing <b>$func</b>(<b>$value</b>)" // library marker kkossev.commonLib, line 2543
//        return // library marker kkossev.commonLib, line 2544
//    } // library marker kkossev.commonLib, line 2545

    logInfo "executed '${func}'" // library marker kkossev.commonLib, line 2547
} // library marker kkossev.commonLib, line 2548

def configureHelp( val ) { // library marker kkossev.commonLib, line 2550
    if (settings?.txtEnable) { log.warn "${device.displayName} configureHelp: select one of the commands in this list!" } // library marker kkossev.commonLib, line 2551
} // library marker kkossev.commonLib, line 2552

def loadAllDefaults() { // library marker kkossev.commonLib, line 2554
    logWarn "loadAllDefaults() !!!" // library marker kkossev.commonLib, line 2555
    deleteAllSettings() // library marker kkossev.commonLib, line 2556
    deleteAllCurrentStates() // library marker kkossev.commonLib, line 2557
    deleteAllScheduledJobs() // library marker kkossev.commonLib, line 2558
    deleteAllStates() // library marker kkossev.commonLib, line 2559
    deleteAllChildDevices() // library marker kkossev.commonLib, line 2560
    initialize() // library marker kkossev.commonLib, line 2561
    configure() // library marker kkossev.commonLib, line 2562
    updated() // calls  also   configureDevice() // library marker kkossev.commonLib, line 2563
    sendInfoEvent("All Defaults Loaded!") // library marker kkossev.commonLib, line 2564
} // library marker kkossev.commonLib, line 2565

/** // library marker kkossev.commonLib, line 2567
 * Send configuration parameters to the device // library marker kkossev.commonLib, line 2568
 * Invoked when device is first installed and when the user updates the configuration // library marker kkossev.commonLib, line 2569
 * @return sends zigbee commands // library marker kkossev.commonLib, line 2570
 */ // library marker kkossev.commonLib, line 2571
def configure() { // library marker kkossev.commonLib, line 2572
    ArrayList<String> cmds = [] // library marker kkossev.commonLib, line 2573
    logInfo 'configure...' // library marker kkossev.commonLib, line 2574
    logDebug settings // library marker kkossev.commonLib, line 2575
    cmds += tuyaBlackMagic() // library marker kkossev.commonLib, line 2576
    if (isAqaraTVOC() || isAqaraTRV_OLD()) { // library marker kkossev.commonLib, line 2577
        aqaraBlackMagic() // library marker kkossev.commonLib, line 2578
    } // library marker kkossev.commonLib, line 2579
    cmds += initializeDevice() // library marker kkossev.commonLib, line 2580
    cmds += configureDevice() // library marker kkossev.commonLib, line 2581
    sendZigbeeCommands(cmds) // library marker kkossev.commonLib, line 2582
    sendInfoEvent("sent device configuration") // library marker kkossev.commonLib, line 2583
} // library marker kkossev.commonLib, line 2584

/** // library marker kkossev.commonLib, line 2586
 * Invoked by Hubitat when driver is installed // library marker kkossev.commonLib, line 2587
 */ // library marker kkossev.commonLib, line 2588
void installed() { // library marker kkossev.commonLib, line 2589
    logInfo 'installed...' // library marker kkossev.commonLib, line 2590
    // populate some default values for attributes // library marker kkossev.commonLib, line 2591
    sendEvent(name: 'healthStatus', value: 'unknown') // library marker kkossev.commonLib, line 2592
    sendEvent(name: 'powerSource', value: 'unknown') // library marker kkossev.commonLib, line 2593
    sendInfoEvent("installed") // library marker kkossev.commonLib, line 2594
    runIn(3, 'updated') // library marker kkossev.commonLib, line 2595
} // library marker kkossev.commonLib, line 2596

/** // library marker kkossev.commonLib, line 2598
 * Invoked when initialize button is clicked // library marker kkossev.commonLib, line 2599
 */ // library marker kkossev.commonLib, line 2600
void initialize() { // library marker kkossev.commonLib, line 2601
    logInfo 'initialize...' // library marker kkossev.commonLib, line 2602
    initializeVars(fullInit = true) // library marker kkossev.commonLib, line 2603
    updateTuyaVersion() // library marker kkossev.commonLib, line 2604
    updateAqaraVersion() // library marker kkossev.commonLib, line 2605
} // library marker kkossev.commonLib, line 2606


/* // library marker kkossev.commonLib, line 2609
 *----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 2610
 * kkossev drivers commonly used functions // library marker kkossev.commonLib, line 2611
 *----------------------------------------------------------------------------- // library marker kkossev.commonLib, line 2612
*/ // library marker kkossev.commonLib, line 2613

static Integer safeToInt(val, Integer defaultVal=0) { // library marker kkossev.commonLib, line 2615
    return "${val}"?.isInteger() ? "${val}".toInteger() : defaultVal // library marker kkossev.commonLib, line 2616
} // library marker kkossev.commonLib, line 2617

static Double safeToDouble(val, Double defaultVal=0.0) { // library marker kkossev.commonLib, line 2619
    return "${val}"?.isDouble() ? "${val}".toDouble() : defaultVal // library marker kkossev.commonLib, line 2620
} // library marker kkossev.commonLib, line 2621

void sendZigbeeCommands(ArrayList<String> cmd) { // library marker kkossev.commonLib, line 2623
    logDebug "sendZigbeeCommands(cmd=$cmd)" // library marker kkossev.commonLib, line 2624
    hubitat.device.HubMultiAction allActions = new hubitat.device.HubMultiAction() // library marker kkossev.commonLib, line 2625
    cmd.each { // library marker kkossev.commonLib, line 2626
            allActions.add(new hubitat.device.HubAction(it, hubitat.device.Protocol.ZIGBEE)) // library marker kkossev.commonLib, line 2627
            if (state.stats != null) { state.stats['txCtr'] = (state.stats['txCtr'] ?: 0) + 1 } else { state.stats=[:] } // library marker kkossev.commonLib, line 2628
    } // library marker kkossev.commonLib, line 2629
    if (state.lastTx != null) { state.lastTx['cmdTime'] = now() } else { state.lastTx = [:] } // library marker kkossev.commonLib, line 2630
    sendHubCommand(allActions) // library marker kkossev.commonLib, line 2631
} // library marker kkossev.commonLib, line 2632

def driverVersionAndTimeStamp() { version() + ' ' + timeStamp() + ((_DEBUG) ? " (debug version!) " : " ") + "(${device.getDataValue('model')} ${device.getDataValue('manufacturer')}) (${getModel()} ${location.hub.firmwareVersionString}) "} // library marker kkossev.commonLib, line 2634

def getDeviceInfo() { // library marker kkossev.commonLib, line 2636
    return "model=${device.getDataValue('model')} manufacturer=${device.getDataValue('manufacturer')} destinationEP=${state.destinationEP ?: UNKNOWN} <b>deviceProfile=${state.deviceProfile ?: UNKNOWN}</b>" // library marker kkossev.commonLib, line 2637
} // library marker kkossev.commonLib, line 2638

def getDestinationEP() {    // [destEndpoint:safeToInt(getDestinationEP())] // library marker kkossev.commonLib, line 2640
    return state.destinationEP ?: device.endpointId ?: "01" // library marker kkossev.commonLib, line 2641
} // library marker kkossev.commonLib, line 2642

def checkDriverVersion() { // library marker kkossev.commonLib, line 2644
    if (state.driverVersion == null || driverVersionAndTimeStamp() != state.driverVersion) { // library marker kkossev.commonLib, line 2645
        logDebug "updating the settings from the current driver version ${state.driverVersion} to the new version ${driverVersionAndTimeStamp()}" // library marker kkossev.commonLib, line 2646
        sendInfoEvent("Updated to version ${driverVersionAndTimeStamp()}") // library marker kkossev.commonLib, line 2647
        state.driverVersion = driverVersionAndTimeStamp() // library marker kkossev.commonLib, line 2648
        initializeVars(fullInit = false) // library marker kkossev.commonLib, line 2649
        updateTuyaVersion() // library marker kkossev.commonLib, line 2650
        updateAqaraVersion() // library marker kkossev.commonLib, line 2651
    } // library marker kkossev.commonLib, line 2652
    else { // library marker kkossev.commonLib, line 2653
        // no driver version change // library marker kkossev.commonLib, line 2654
    } // library marker kkossev.commonLib, line 2655
} // library marker kkossev.commonLib, line 2656

// credits @thebearmay // library marker kkossev.commonLib, line 2658
String getModel(){ // library marker kkossev.commonLib, line 2659
    try{ // library marker kkossev.commonLib, line 2660
        String model = getHubVersion() // requires >=2.2.8.141 // library marker kkossev.commonLib, line 2661
    } catch (ignore){ // library marker kkossev.commonLib, line 2662
        try{ // library marker kkossev.commonLib, line 2663
            httpGet("http://${location.hub.localIP}:8080/api/hubitat.xml") { res -> // library marker kkossev.commonLib, line 2664
                model = res.data.device.modelName // library marker kkossev.commonLib, line 2665
            return model // library marker kkossev.commonLib, line 2666
            }         // library marker kkossev.commonLib, line 2667
        } catch(ignore_again) { // library marker kkossev.commonLib, line 2668
            return "" // library marker kkossev.commonLib, line 2669
        } // library marker kkossev.commonLib, line 2670
    } // library marker kkossev.commonLib, line 2671
} // library marker kkossev.commonLib, line 2672

// credits @thebearmay // library marker kkossev.commonLib, line 2674
boolean isCompatible(Integer minLevel) { //check to see if the hub version meets the minimum requirement ( 7 or 8 ) // library marker kkossev.commonLib, line 2675
    String model = getModel()            // <modelName>Rev C-7</modelName> // library marker kkossev.commonLib, line 2676
    String[] tokens = model.split('-') // library marker kkossev.commonLib, line 2677
    String revision = tokens.last() // library marker kkossev.commonLib, line 2678
    return (Integer.parseInt(revision) >= minLevel) // library marker kkossev.commonLib, line 2679
} // library marker kkossev.commonLib, line 2680

/** // library marker kkossev.commonLib, line 2682
 * called from TODO // library marker kkossev.commonLib, line 2683
 *  // library marker kkossev.commonLib, line 2684
 */ // library marker kkossev.commonLib, line 2685

def deleteAllStatesAndJobs() { // library marker kkossev.commonLib, line 2687
    state.clear()    // clear all states // library marker kkossev.commonLib, line 2688
    unschedule() // library marker kkossev.commonLib, line 2689
    device.deleteCurrentState('*') // library marker kkossev.commonLib, line 2690
    device.deleteCurrentState('') // library marker kkossev.commonLib, line 2691

    log.info "${device.displayName} jobs and states cleared. HE hub is ${getHubVersion()}, version is ${location.hub.firmwareVersionString}" // library marker kkossev.commonLib, line 2693
} // library marker kkossev.commonLib, line 2694


def resetStatistics() { // library marker kkossev.commonLib, line 2697
    runIn(1, "resetStats") // library marker kkossev.commonLib, line 2698
    sendInfoEvent("Statistics are reset. Refresh the web page") // library marker kkossev.commonLib, line 2699
} // library marker kkossev.commonLib, line 2700

/** // library marker kkossev.commonLib, line 2702
 * called from TODO // library marker kkossev.commonLib, line 2703
 *  // library marker kkossev.commonLib, line 2704
 */ // library marker kkossev.commonLib, line 2705
def resetStats() { // library marker kkossev.commonLib, line 2706
    logDebug "resetStats..." // library marker kkossev.commonLib, line 2707
    state.stats = [:] // library marker kkossev.commonLib, line 2708
    state.states = [:] // library marker kkossev.commonLib, line 2709
    state.lastRx = [:] // library marker kkossev.commonLib, line 2710
    state.lastTx = [:] // library marker kkossev.commonLib, line 2711
    state.health = [:] // library marker kkossev.commonLib, line 2712
    state.zigbeeGroups = [:]  // library marker kkossev.commonLib, line 2713
    state.stats["rxCtr"] = 0 // library marker kkossev.commonLib, line 2714
    state.stats["txCtr"] = 0 // library marker kkossev.commonLib, line 2715
    state.states["isDigital"] = false // library marker kkossev.commonLib, line 2716
    state.states["isRefresh"] = false // library marker kkossev.commonLib, line 2717
    state.health["offlineCtr"] = 0 // library marker kkossev.commonLib, line 2718
    state.health["checkCtr3"] = 0 // library marker kkossev.commonLib, line 2719
} // library marker kkossev.commonLib, line 2720

/** // library marker kkossev.commonLib, line 2722
 * called from TODO // library marker kkossev.commonLib, line 2723
 *  // library marker kkossev.commonLib, line 2724
 */ // library marker kkossev.commonLib, line 2725
void initializeVars( boolean fullInit = false ) { // library marker kkossev.commonLib, line 2726
    logDebug "InitializeVars()... fullInit = ${fullInit}" // library marker kkossev.commonLib, line 2727
    if (fullInit == true ) { // library marker kkossev.commonLib, line 2728
        state.clear() // library marker kkossev.commonLib, line 2729
        unschedule() // library marker kkossev.commonLib, line 2730
        resetStats() // library marker kkossev.commonLib, line 2731
        //setDeviceNameAndProfile() // library marker kkossev.commonLib, line 2732
        //state.comment = 'Works with Tuya Zigbee Devices' // library marker kkossev.commonLib, line 2733
        logInfo "all states and scheduled jobs cleared!" // library marker kkossev.commonLib, line 2734
        state.driverVersion = driverVersionAndTimeStamp() // library marker kkossev.commonLib, line 2735
        logInfo "DEVICE_TYPE = ${DEVICE_TYPE}" // library marker kkossev.commonLib, line 2736
        state.deviceType = DEVICE_TYPE // library marker kkossev.commonLib, line 2737
        sendInfoEvent("Initialized") // library marker kkossev.commonLib, line 2738
    } // library marker kkossev.commonLib, line 2739

    if (state.stats == null)  { state.stats  = [:] } // library marker kkossev.commonLib, line 2741
    if (state.states == null) { state.states = [:] } // library marker kkossev.commonLib, line 2742
    if (state.lastRx == null) { state.lastRx = [:] } // library marker kkossev.commonLib, line 2743
    if (state.lastTx == null) { state.lastTx = [:] } // library marker kkossev.commonLib, line 2744
    if (state.health == null) { state.health = [:] } // library marker kkossev.commonLib, line 2745
    if (state.zigbeeGroups == null) { state.zigbeeGroups = [:] } // library marker kkossev.commonLib, line 2746

    if (fullInit || settings?.txtEnable == null) device.updateSetting("txtEnable", true) // library marker kkossev.commonLib, line 2748
    if (fullInit || settings?.logEnable == null) device.updateSetting("logEnable", true) // library marker kkossev.commonLib, line 2749
    if (fullInit || settings?.traceEnable == null) device.updateSetting("traceEnable", false) // library marker kkossev.commonLib, line 2750
    if (fullInit || settings?.advancedOptions == null) device.updateSetting("advancedOptions", [value:false, type:"bool"]) // library marker kkossev.commonLib, line 2751
    if (fullInit || settings?.healthCheckMethod == null) device.updateSetting('healthCheckMethod', [value: HealthcheckMethodOpts.defaultValue.toString(), type: 'enum']) // library marker kkossev.commonLib, line 2752
    if (fullInit || settings?.healthCheckInterval == null) device.updateSetting('healthCheckInterval', [value: HealthcheckIntervalOpts.defaultValue.toString(), type: 'enum']) // library marker kkossev.commonLib, line 2753
    if (device.currentValue('healthStatus') == null) sendHealthStatusEvent('unknown') // library marker kkossev.commonLib, line 2754
    if (fullInit || settings?.threeStateEnable == null) device.updateSetting("threeStateEnable", false) // library marker kkossev.commonLib, line 2755
    if (fullInit || settings?.voltageToPercent == null) device.updateSetting("voltageToPercent", false) // library marker kkossev.commonLib, line 2756
    if (device.hasCapability("IlluminanceMeasurement")) { // library marker kkossev.commonLib, line 2757
        if (fullInit || settings?.minReportingTime == null) device.updateSetting("minReportingTime", [value:DEFAULT_MIN_REPORTING_TIME, type:"number"]) // library marker kkossev.commonLib, line 2758
        if (fullInit || settings?.maxReportingTime == null) device.updateSetting("maxReportingTime", [value:DEFAULT_MAX_REPORTING_TIME, type:"number"]) // library marker kkossev.commonLib, line 2759
    } // library marker kkossev.commonLib, line 2760
    if (device.hasCapability("IlluminanceMeasurement")) { // library marker kkossev.commonLib, line 2761
        if (fullInit || settings?.illuminanceThreshold == null) device.updateSetting("illuminanceThreshold", [value:DEFAULT_ILLUMINANCE_THRESHOLD, type:"number"]) // library marker kkossev.commonLib, line 2762
        if (fullInit || settings?.illuminanceCoeff == null) device.updateSetting("illuminanceCoeff", [value:1.00, type:"decimal"]) // library marker kkossev.commonLib, line 2763
    } // library marker kkossev.commonLib, line 2764
    // device specific initialization should be at the end // library marker kkossev.commonLib, line 2765
    if (DEVICE_TYPE in ["AirQuality"]) { initVarsAirQuality(fullInit) } // library marker kkossev.commonLib, line 2766
    if (DEVICE_TYPE in ["Fingerbot"])  { initVarsFingerbot(fullInit); initEventsFingerbot(fullInit) } // library marker kkossev.commonLib, line 2767
    if (DEVICE_TYPE in ["AqaraCube"])  { initVarsAqaraCube(fullInit); initEventsAqaraCube(fullInit) } // library marker kkossev.commonLib, line 2768
    if (DEVICE_TYPE in ["Switch"])     { initVarsSwitch(fullInit);    initEventsSwitch(fullInit) }         // none // library marker kkossev.commonLib, line 2769
    if (DEVICE_TYPE in ["IRBlaster"])  { initVarsIrBlaster(fullInit); initEventsIrBlaster(fullInit) }      // none // library marker kkossev.commonLib, line 2770
    if (DEVICE_TYPE in ["Radar"])      { initVarsRadar(fullInit);     initEventsRadar(fullInit) }          // none // library marker kkossev.commonLib, line 2771
    if (DEVICE_TYPE in ["ButtonDimmer"]) { initVarsButtonDimmer(fullInit);     initEventsButtonDimmer(fullInit) } // library marker kkossev.commonLib, line 2772
    if (DEVICE_TYPE in ["Thermostat"]) { initVarsThermostat(fullInit);     initEventsThermostat(fullInit) } // library marker kkossev.commonLib, line 2773
    if (DEVICE_TYPE in ["Bulb"])       { initVarsBulb(fullInit);     initEventsBulb(fullInit) } // library marker kkossev.commonLib, line 2774

    def mm = device.getDataValue("model") // library marker kkossev.commonLib, line 2776
    if ( mm != null) { // library marker kkossev.commonLib, line 2777
        logDebug " model = ${mm}" // library marker kkossev.commonLib, line 2778
    } // library marker kkossev.commonLib, line 2779
    else { // library marker kkossev.commonLib, line 2780
        logWarn " Model not found, please re-pair the device!" // library marker kkossev.commonLib, line 2781
    } // library marker kkossev.commonLib, line 2782
    def ep = device.getEndpointId() // library marker kkossev.commonLib, line 2783
    if ( ep  != null) { // library marker kkossev.commonLib, line 2784
        //state.destinationEP = ep // library marker kkossev.commonLib, line 2785
        logDebug " destinationEP = ${ep}" // library marker kkossev.commonLib, line 2786
    } // library marker kkossev.commonLib, line 2787
    else { // library marker kkossev.commonLib, line 2788
        logWarn " Destination End Point not found, please re-pair the device!" // library marker kkossev.commonLib, line 2789
        //state.destinationEP = "01"    // fallback // library marker kkossev.commonLib, line 2790
    }     // library marker kkossev.commonLib, line 2791
} // library marker kkossev.commonLib, line 2792


/** // library marker kkossev.commonLib, line 2795
 * called from TODO // library marker kkossev.commonLib, line 2796
 *  // library marker kkossev.commonLib, line 2797
 */ // library marker kkossev.commonLib, line 2798
def setDestinationEP() { // library marker kkossev.commonLib, line 2799
    def ep = device.getEndpointId() // library marker kkossev.commonLib, line 2800
    if (ep != null && ep != 'F2') { // library marker kkossev.commonLib, line 2801
        state.destinationEP = ep // library marker kkossev.commonLib, line 2802
        logDebug "setDestinationEP() destinationEP = ${state.destinationEP}" // library marker kkossev.commonLib, line 2803
    } // library marker kkossev.commonLib, line 2804
    else { // library marker kkossev.commonLib, line 2805
        logWarn "setDestinationEP() Destination End Point not found or invalid(${ep}), activating the F2 bug patch!" // library marker kkossev.commonLib, line 2806
        state.destinationEP = "01"    // fallback EP // library marker kkossev.commonLib, line 2807
    }       // library marker kkossev.commonLib, line 2808
} // library marker kkossev.commonLib, line 2809


def logDebug(msg) { // library marker kkossev.commonLib, line 2812
    if (settings.logEnable) { // library marker kkossev.commonLib, line 2813
        log.debug "${device.displayName} " + msg // library marker kkossev.commonLib, line 2814
    } // library marker kkossev.commonLib, line 2815
} // library marker kkossev.commonLib, line 2816

def logInfo(msg) { // library marker kkossev.commonLib, line 2818
    if (settings.txtEnable) { // library marker kkossev.commonLib, line 2819
        log.info "${device.displayName} " + msg // library marker kkossev.commonLib, line 2820
    } // library marker kkossev.commonLib, line 2821
} // library marker kkossev.commonLib, line 2822

def logWarn(msg) { // library marker kkossev.commonLib, line 2824
    if (settings.logEnable) { // library marker kkossev.commonLib, line 2825
        log.warn "${device.displayName} " + msg // library marker kkossev.commonLib, line 2826
    } // library marker kkossev.commonLib, line 2827
} // library marker kkossev.commonLib, line 2828

def logTrace(msg) { // library marker kkossev.commonLib, line 2830
    if (settings.traceEnable) { // library marker kkossev.commonLib, line 2831
        log.trace "${device.displayName} " + msg // library marker kkossev.commonLib, line 2832
    } // library marker kkossev.commonLib, line 2833
} // library marker kkossev.commonLib, line 2834



// _DEBUG mode only // library marker kkossev.commonLib, line 2838
void getAllProperties() { // library marker kkossev.commonLib, line 2839
    log.trace 'Properties:'     // library marker kkossev.commonLib, line 2840
    device.properties.each { it-> // library marker kkossev.commonLib, line 2841
        log.debug it // library marker kkossev.commonLib, line 2842
    } // library marker kkossev.commonLib, line 2843
    log.trace 'Settings:'     // library marker kkossev.commonLib, line 2844
    settings.each { it-> // library marker kkossev.commonLib, line 2845
        log.debug "${it.key} =  ${it.value}"    // https://community.hubitat.com/t/how-do-i-get-the-datatype-for-an-app-setting/104228/6?u=kkossev // library marker kkossev.commonLib, line 2846
    }     // library marker kkossev.commonLib, line 2847
    log.trace 'Done'     // library marker kkossev.commonLib, line 2848
} // library marker kkossev.commonLib, line 2849

// delete all Preferences // library marker kkossev.commonLib, line 2851
void deleteAllSettings() { // library marker kkossev.commonLib, line 2852
    settings.each { it-> // library marker kkossev.commonLib, line 2853
        logDebug "deleting ${it.key}" // library marker kkossev.commonLib, line 2854
        device.removeSetting("${it.key}") // library marker kkossev.commonLib, line 2855
    } // library marker kkossev.commonLib, line 2856
    logInfo  "All settings (preferences) DELETED" // library marker kkossev.commonLib, line 2857
} // library marker kkossev.commonLib, line 2858

// delete all attributes // library marker kkossev.commonLib, line 2860
void deleteAllCurrentStates() { // library marker kkossev.commonLib, line 2861
    device.properties.supportedAttributes.each { it-> // library marker kkossev.commonLib, line 2862
        logDebug "deleting $it" // library marker kkossev.commonLib, line 2863
        device.deleteCurrentState("$it") // library marker kkossev.commonLib, line 2864
    } // library marker kkossev.commonLib, line 2865
    logInfo "All current states (attributes) DELETED" // library marker kkossev.commonLib, line 2866
} // library marker kkossev.commonLib, line 2867

// delete all State Variables // library marker kkossev.commonLib, line 2869
void deleteAllStates() { // library marker kkossev.commonLib, line 2870
    state.each { it-> // library marker kkossev.commonLib, line 2871
        logDebug "deleting state ${it.key}" // library marker kkossev.commonLib, line 2872
    } // library marker kkossev.commonLib, line 2873
    state.clear() // library marker kkossev.commonLib, line 2874
    logInfo "All States DELETED" // library marker kkossev.commonLib, line 2875
} // library marker kkossev.commonLib, line 2876

void deleteAllScheduledJobs() { // library marker kkossev.commonLib, line 2878
    unschedule() // library marker kkossev.commonLib, line 2879
    logInfo "All scheduled jobs DELETED" // library marker kkossev.commonLib, line 2880
} // library marker kkossev.commonLib, line 2881

void deleteAllChildDevices() { // library marker kkossev.commonLib, line 2883
    logDebug "deleteAllChildDevices : not implemented!" // library marker kkossev.commonLib, line 2884
} // library marker kkossev.commonLib, line 2885

def parseTest(par) { // library marker kkossev.commonLib, line 2887
//read attr - raw: DF8D0104020A000029280A, dni: DF8D, endpoint: 01, cluster: 0402, size: 0A, attrId: 0000, encoding: 29, command: 0A, value: 280A // library marker kkossev.commonLib, line 2888
    log.warn "parseTest(${par})" // library marker kkossev.commonLib, line 2889
    parse(par) // library marker kkossev.commonLib, line 2890
} // library marker kkossev.commonLib, line 2891

def testJob() { // library marker kkossev.commonLib, line 2893
    log.warn "test job executed" // library marker kkossev.commonLib, line 2894
} // library marker kkossev.commonLib, line 2895

/** // library marker kkossev.commonLib, line 2897
 * Calculates and returns the cron expression // library marker kkossev.commonLib, line 2898
 * @param timeInSeconds interval in seconds // library marker kkossev.commonLib, line 2899
 */ // library marker kkossev.commonLib, line 2900
def getCron( timeInSeconds ) { // library marker kkossev.commonLib, line 2901
    //schedule("${rnd.nextInt(59)} ${rnd.nextInt(9)}/${intervalMins} * ? * * *", 'ping') // library marker kkossev.commonLib, line 2902
    // TODO: runEvery1Minute runEvery5Minutes runEvery10Minutes runEvery15Minutes runEvery30Minutes runEvery1Hour runEvery3Hours // library marker kkossev.commonLib, line 2903
    final Random rnd = new Random() // library marker kkossev.commonLib, line 2904
    def minutes = (timeInSeconds / 60 ) as int // library marker kkossev.commonLib, line 2905
    def hours = (minutes / 60 ) as int // library marker kkossev.commonLib, line 2906
    if (hours > 23) { hours = 23 } // library marker kkossev.commonLib, line 2907
    String cron // library marker kkossev.commonLib, line 2908
    if (timeInSeconds < 60) { // library marker kkossev.commonLib, line 2909
        cron = "*/$timeInSeconds * * * * ? *" // library marker kkossev.commonLib, line 2910
    } // library marker kkossev.commonLib, line 2911
    else { // library marker kkossev.commonLib, line 2912
        if (minutes < 60) { // library marker kkossev.commonLib, line 2913
            cron = "${rnd.nextInt(59)} ${rnd.nextInt(9)}/$minutes * ? * *"   // library marker kkossev.commonLib, line 2914
        } // library marker kkossev.commonLib, line 2915
        else { // library marker kkossev.commonLib, line 2916
            cron = "${rnd.nextInt(59)} ${rnd.nextInt(59)} */$hours ? * *"                    // library marker kkossev.commonLib, line 2917
        } // library marker kkossev.commonLib, line 2918
    } // library marker kkossev.commonLib, line 2919
    return cron // library marker kkossev.commonLib, line 2920
} // library marker kkossev.commonLib, line 2921

boolean isTuya() { // library marker kkossev.commonLib, line 2923
    def model = device.getDataValue("model")  // library marker kkossev.commonLib, line 2924
    def manufacturer = device.getDataValue("manufacturer")  // library marker kkossev.commonLib, line 2925
    if (model?.startsWith("TS") && manufacturer?.startsWith("_TZ")) { // library marker kkossev.commonLib, line 2926
        return true // library marker kkossev.commonLib, line 2927
    } // library marker kkossev.commonLib, line 2928
    return false // library marker kkossev.commonLib, line 2929
} // library marker kkossev.commonLib, line 2930

void updateTuyaVersion() { // library marker kkossev.commonLib, line 2932
    if (!isTuya()) { // library marker kkossev.commonLib, line 2933
        logDebug "not Tuya" // library marker kkossev.commonLib, line 2934
        return // library marker kkossev.commonLib, line 2935
    } // library marker kkossev.commonLib, line 2936
    def application = device.getDataValue("application")  // library marker kkossev.commonLib, line 2937
    if (application != null) { // library marker kkossev.commonLib, line 2938
        Integer ver // library marker kkossev.commonLib, line 2939
        try { // library marker kkossev.commonLib, line 2940
            ver = zigbee.convertHexToInt(application) // library marker kkossev.commonLib, line 2941
        } // library marker kkossev.commonLib, line 2942
        catch (e) { // library marker kkossev.commonLib, line 2943
            logWarn "exception caught while converting application version ${application} to tuyaVersion" // library marker kkossev.commonLib, line 2944
            return // library marker kkossev.commonLib, line 2945
        } // library marker kkossev.commonLib, line 2946
        def str = ((ver&0xC0)>>6).toString() + "." + ((ver&0x30)>>4).toString() + "." + (ver&0x0F).toString() // library marker kkossev.commonLib, line 2947
        if (device.getDataValue("tuyaVersion") != str) { // library marker kkossev.commonLib, line 2948
            device.updateDataValue("tuyaVersion", str) // library marker kkossev.commonLib, line 2949
            logInfo "tuyaVersion set to $str" // library marker kkossev.commonLib, line 2950
        } // library marker kkossev.commonLib, line 2951
    } // library marker kkossev.commonLib, line 2952
} // library marker kkossev.commonLib, line 2953

boolean isAqara() { // library marker kkossev.commonLib, line 2955
    def model = device.getDataValue("model")  // library marker kkossev.commonLib, line 2956
    def manufacturer = device.getDataValue("manufacturer")  // library marker kkossev.commonLib, line 2957
    if (model?.startsWith("lumi")) { // library marker kkossev.commonLib, line 2958
        return true // library marker kkossev.commonLib, line 2959
    } // library marker kkossev.commonLib, line 2960
    return false // library marker kkossev.commonLib, line 2961
} // library marker kkossev.commonLib, line 2962

def updateAqaraVersion() { // library marker kkossev.commonLib, line 2964
    if (!isAqara()) { // library marker kkossev.commonLib, line 2965
        logDebug "not Aqara" // library marker kkossev.commonLib, line 2966
        return // library marker kkossev.commonLib, line 2967
    }     // library marker kkossev.commonLib, line 2968
    def application = device.getDataValue("application")  // library marker kkossev.commonLib, line 2969
    if (application != null) { // library marker kkossev.commonLib, line 2970
        def str = "0.0.0_" + String.format("%04d", zigbee.convertHexToInt(application.substring(0, Math.min(application.length(), 2)))); // library marker kkossev.commonLib, line 2971
        if (device.getDataValue("aqaraVersion") != str) { // library marker kkossev.commonLib, line 2972
            device.updateDataValue("aqaraVersion", str) // library marker kkossev.commonLib, line 2973
            logInfo "aqaraVersion set to $str" // library marker kkossev.commonLib, line 2974
        } // library marker kkossev.commonLib, line 2975
    } // library marker kkossev.commonLib, line 2976
    else { // library marker kkossev.commonLib, line 2977
        return null // library marker kkossev.commonLib, line 2978
    } // library marker kkossev.commonLib, line 2979
} // library marker kkossev.commonLib, line 2980

def test(par) { // library marker kkossev.commonLib, line 2982
    ArrayList<String> cmds = [] // library marker kkossev.commonLib, line 2983
    log.warn "test... ${par}" // library marker kkossev.commonLib, line 2984

    parse(par) // library marker kkossev.commonLib, line 2986

   // sendZigbeeCommands(cmds)     // library marker kkossev.commonLib, line 2988
} // library marker kkossev.commonLib, line 2989

// /////////////////////////////////////////////////////////////////// Libraries ////////////////////////////////////////////////////////////////////// // library marker kkossev.commonLib, line 2991



// ~~~~~ end include (144) kkossev.commonLib ~~~~~

// ~~~~~ start include (141) kkossev.xiaomiLib ~~~~~
library ( // library marker kkossev.xiaomiLib, line 1
    base: "driver", // library marker kkossev.xiaomiLib, line 2
    author: "Krassimir Kossev", // library marker kkossev.xiaomiLib, line 3
    category: "zigbee", // library marker kkossev.xiaomiLib, line 4
    description: "Xiaomi Library", // library marker kkossev.xiaomiLib, line 5
    name: "xiaomiLib", // library marker kkossev.xiaomiLib, line 6
    namespace: "kkossev", // library marker kkossev.xiaomiLib, line 7
    importUrl: "https://raw.githubusercontent.com/kkossev/hubitat/development/libraries/xiaomiLib.groovy", // library marker kkossev.xiaomiLib, line 8
    version: "1.0.1", // library marker kkossev.xiaomiLib, line 9
    documentationLink: "" // library marker kkossev.xiaomiLib, line 10
) // library marker kkossev.xiaomiLib, line 11
/* // library marker kkossev.xiaomiLib, line 12
 *  Xiaomi Library // library marker kkossev.xiaomiLib, line 13
 * // library marker kkossev.xiaomiLib, line 14
 *  Licensed Virtual the Apache License, Version 2.0 (the "License"); you may not use this file except // library marker kkossev.xiaomiLib, line 15
 *  in compliance with the License. You may obtain a copy of the License at: // library marker kkossev.xiaomiLib, line 16
 * // library marker kkossev.xiaomiLib, line 17
 *      http://www.apache.org/licenses/LICENSE-2.0 // library marker kkossev.xiaomiLib, line 18
 * // library marker kkossev.xiaomiLib, line 19
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed // library marker kkossev.xiaomiLib, line 20
 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License // library marker kkossev.xiaomiLib, line 21
 *  for the specific language governing permissions and limitations under the License. // library marker kkossev.xiaomiLib, line 22
 * // library marker kkossev.xiaomiLib, line 23
 * ver. 1.0.0  2023-09-09 kkossev  - added xiaomiLib // library marker kkossev.xiaomiLib, line 24
 * ver. 1.0.1  2023-11-07 kkossev  - (dev. branch) // library marker kkossev.xiaomiLib, line 25
 * // library marker kkossev.xiaomiLib, line 26
 *                                   TODO:  // library marker kkossev.xiaomiLib, line 27
*/ // library marker kkossev.xiaomiLib, line 28


def xiaomiLibVersion()   {"1.0.1"} // library marker kkossev.xiaomiLib, line 31
def xiaomiLibStamp() {"2023/11/07 5:23 PM"} // library marker kkossev.xiaomiLib, line 32

// no metadata for this library! // library marker kkossev.xiaomiLib, line 34

@Field static final int XIAOMI_CLUSTER_ID = 0xFCC0 // library marker kkossev.xiaomiLib, line 36

// Zigbee Attributes // library marker kkossev.xiaomiLib, line 38
@Field static final int DIRECTION_MODE_ATTR_ID = 0x0144 // library marker kkossev.xiaomiLib, line 39
@Field static final int MODEL_ATTR_ID = 0x05 // library marker kkossev.xiaomiLib, line 40
@Field static final int PRESENCE_ACTIONS_ATTR_ID = 0x0143 // library marker kkossev.xiaomiLib, line 41
@Field static final int PRESENCE_ATTR_ID = 0x0142 // library marker kkossev.xiaomiLib, line 42
@Field static final int REGION_EVENT_ATTR_ID = 0x0151 // library marker kkossev.xiaomiLib, line 43
@Field static final int RESET_PRESENCE_ATTR_ID = 0x0157 // library marker kkossev.xiaomiLib, line 44
@Field static final int SENSITIVITY_LEVEL_ATTR_ID = 0x010C // library marker kkossev.xiaomiLib, line 45
@Field static final int SET_EDGE_REGION_ATTR_ID = 0x0156 // library marker kkossev.xiaomiLib, line 46
@Field static final int SET_EXIT_REGION_ATTR_ID = 0x0153 // library marker kkossev.xiaomiLib, line 47
@Field static final int SET_INTERFERENCE_ATTR_ID = 0x0154 // library marker kkossev.xiaomiLib, line 48
@Field static final int SET_REGION_ATTR_ID = 0x0150 // library marker kkossev.xiaomiLib, line 49
@Field static final int TRIGGER_DISTANCE_ATTR_ID = 0x0146 // library marker kkossev.xiaomiLib, line 50
@Field static final int XIAOMI_RAW_ATTR_ID = 0xFFF2 // library marker kkossev.xiaomiLib, line 51
@Field static final int XIAOMI_SPECIAL_REPORT_ID = 0x00F7 // library marker kkossev.xiaomiLib, line 52
@Field static final Map MFG_CODE = [ mfgCode: 0x115F ] // library marker kkossev.xiaomiLib, line 53

// Xiaomi Tags // library marker kkossev.xiaomiLib, line 55
@Field static final int DIRECTION_MODE_TAG_ID = 0x67 // library marker kkossev.xiaomiLib, line 56
@Field static final int SENSITIVITY_LEVEL_TAG_ID = 0x66 // library marker kkossev.xiaomiLib, line 57
@Field static final int SWBUILD_TAG_ID = 0x08 // library marker kkossev.xiaomiLib, line 58
@Field static final int TRIGGER_DISTANCE_TAG_ID = 0x69 // library marker kkossev.xiaomiLib, line 59
@Field static final int PRESENCE_ACTIONS_TAG_ID = 0x66 // library marker kkossev.xiaomiLib, line 60
@Field static final int PRESENCE_TAG_ID = 0x65 // library marker kkossev.xiaomiLib, line 61

// called from parseXiaomiCluster() in the main code ... // library marker kkossev.xiaomiLib, line 63
// // library marker kkossev.xiaomiLib, line 64
void parseXiaomiClusterLib(final Map descMap) { // library marker kkossev.xiaomiLib, line 65
    if (settings.logEnable) { // library marker kkossev.xiaomiLib, line 66
        //log.trace "zigbee received xiaomi cluster attribute 0x${descMap.attrId} (value ${descMap.value})" // library marker kkossev.xiaomiLib, line 67
    } // library marker kkossev.xiaomiLib, line 68
    if (DEVICE_TYPE in  ["Thermostat"]) { // library marker kkossev.xiaomiLib, line 69
        parseXiaomiClusterThermostatLib(descMap) // library marker kkossev.xiaomiLib, line 70
        return // library marker kkossev.xiaomiLib, line 71
    } // library marker kkossev.xiaomiLib, line 72
    if (DEVICE_TYPE in  ["Bulb"]) { // library marker kkossev.xiaomiLib, line 73
        parseXiaomiClusterRgbLib(descMap) // library marker kkossev.xiaomiLib, line 74
        return // library marker kkossev.xiaomiLib, line 75
    } // library marker kkossev.xiaomiLib, line 76
    // TODO - refactor AqaraCube specific code // library marker kkossev.xiaomiLib, line 77
    // TODO - refactor FP1 specific code // library marker kkossev.xiaomiLib, line 78
    switch (descMap.attrInt as Integer) { // library marker kkossev.xiaomiLib, line 79
        case 0x0009:                      // Aqara Cube T1 Pro // library marker kkossev.xiaomiLib, line 80
            if (DEVICE_TYPE in  ["AqaraCube"]) { logDebug "AqaraCube 0xFCC0 attribute 0x009 value is ${hexStrToUnsignedInt(descMap.value)}" } // library marker kkossev.xiaomiLib, line 81
            else { logDebug "XiaomiCluster unknown attribute ${descMap.attrInt} value raw = ${hexStrToUnsignedInt(descMap.value)}" } // library marker kkossev.xiaomiLib, line 82
            break // library marker kkossev.xiaomiLib, line 83
        case 0x00FC:                      // FP1 // library marker kkossev.xiaomiLib, line 84
            log.info "unknown attribute - resetting?" // library marker kkossev.xiaomiLib, line 85
            break // library marker kkossev.xiaomiLib, line 86
        case PRESENCE_ATTR_ID:            // 0x0142 FP1 // library marker kkossev.xiaomiLib, line 87
            final Integer value = hexStrToUnsignedInt(descMap.value) // library marker kkossev.xiaomiLib, line 88
            parseXiaomiClusterPresence(value) // library marker kkossev.xiaomiLib, line 89
            break // library marker kkossev.xiaomiLib, line 90
        case PRESENCE_ACTIONS_ATTR_ID:    // 0x0143 FP1 // library marker kkossev.xiaomiLib, line 91
            final Integer value = hexStrToUnsignedInt(descMap.value) // library marker kkossev.xiaomiLib, line 92
            parseXiaomiClusterPresenceAction(value) // library marker kkossev.xiaomiLib, line 93
            break // library marker kkossev.xiaomiLib, line 94
        case REGION_EVENT_ATTR_ID:        // 0x0151 FP1 // library marker kkossev.xiaomiLib, line 95
            // Region events can be sent fast and furious so buffer them // library marker kkossev.xiaomiLib, line 96
            final Integer regionId = HexUtils.hexStringToInt(descMap.value[0..1]) // library marker kkossev.xiaomiLib, line 97
            final Integer value = HexUtils.hexStringToInt(descMap.value[2..3]) // library marker kkossev.xiaomiLib, line 98
            if (settings.logEnable) { // library marker kkossev.xiaomiLib, line 99
                log.debug "xiaomi: region ${regionId} action is ${value}" // library marker kkossev.xiaomiLib, line 100
            } // library marker kkossev.xiaomiLib, line 101
            if (device.currentValue("region${regionId}") != null) { // library marker kkossev.xiaomiLib, line 102
                RegionUpdateBuffer.get(device.id).put(regionId, value) // library marker kkossev.xiaomiLib, line 103
                runInMillis(REGION_UPDATE_DELAY_MS, 'updateRegions') // library marker kkossev.xiaomiLib, line 104
            } // library marker kkossev.xiaomiLib, line 105
            break // library marker kkossev.xiaomiLib, line 106
        case SENSITIVITY_LEVEL_ATTR_ID:   // 0x010C FP1 // library marker kkossev.xiaomiLib, line 107
            final Integer value = hexStrToUnsignedInt(descMap.value) // library marker kkossev.xiaomiLib, line 108
            log.info "sensitivity level is '${SensitivityLevelOpts.options[value]}' (0x${descMap.value})" // library marker kkossev.xiaomiLib, line 109
            device.updateSetting('sensitivityLevel', [value: value.toString(), type: 'enum']) // library marker kkossev.xiaomiLib, line 110
            break // library marker kkossev.xiaomiLib, line 111
        case TRIGGER_DISTANCE_ATTR_ID:    // 0x0146 FP1 // library marker kkossev.xiaomiLib, line 112
            final Integer value = hexStrToUnsignedInt(descMap.value) // library marker kkossev.xiaomiLib, line 113
            log.info "approach distance is '${ApproachDistanceOpts.options[value]}' (0x${descMap.value})" // library marker kkossev.xiaomiLib, line 114
            device.updateSetting('approachDistance', [value: value.toString(), type: 'enum']) // library marker kkossev.xiaomiLib, line 115
            break // library marker kkossev.xiaomiLib, line 116
        case DIRECTION_MODE_ATTR_ID:     // 0x0144 FP1 // library marker kkossev.xiaomiLib, line 117
            final Integer value = hexStrToUnsignedInt(descMap.value) // library marker kkossev.xiaomiLib, line 118
            log.info "monitoring direction mode is '${DirectionModeOpts.options[value]}' (0x${descMap.value})" // library marker kkossev.xiaomiLib, line 119
            device.updateSetting('directionMode', [value: value.toString(), type: 'enum']) // library marker kkossev.xiaomiLib, line 120
            break // library marker kkossev.xiaomiLib, line 121
        case 0x0148 :                    // Aqara Cube T1 Pro - Mode // library marker kkossev.xiaomiLib, line 122
            if (DEVICE_TYPE in  ["AqaraCube"]) { parseXiaomiClusterAqaraCube(descMap) } // library marker kkossev.xiaomiLib, line 123
            else { logDebug "XiaomiCluster unknown attribute ${descMap.attrInt} value raw = ${hexStrToUnsignedInt(descMap.value)}" } // library marker kkossev.xiaomiLib, line 124
            break // library marker kkossev.xiaomiLib, line 125
        case 0x0149:                     // (329) Aqara Cube T1 Pro - i side facing up (0..5) // library marker kkossev.xiaomiLib, line 126
            if (DEVICE_TYPE in  ["AqaraCube"]) { parseXiaomiClusterAqaraCube(descMap) } // library marker kkossev.xiaomiLib, line 127
            else { logDebug "XiaomiCluster unknown attribute ${descMap.attrInt} value raw = ${hexStrToUnsignedInt(descMap.value)}" } // library marker kkossev.xiaomiLib, line 128
            break // library marker kkossev.xiaomiLib, line 129
        case XIAOMI_SPECIAL_REPORT_ID:   // 0x00F7 sent every 55 minutes // library marker kkossev.xiaomiLib, line 130
            final Map<Integer, Integer> tags = decodeXiaomiTags(descMap.value) // library marker kkossev.xiaomiLib, line 131
            parseXiaomiClusterTags(tags) // library marker kkossev.xiaomiLib, line 132
            if (isAqaraCube()) { // library marker kkossev.xiaomiLib, line 133
                sendZigbeeCommands(refreshAqaraCube()) // library marker kkossev.xiaomiLib, line 134
            } // library marker kkossev.xiaomiLib, line 135
            break // library marker kkossev.xiaomiLib, line 136
        case XIAOMI_RAW_ATTR_ID:        // 0xFFF2 FP1  // library marker kkossev.xiaomiLib, line 137
            final byte[] rawData = HexUtils.hexStringToByteArray(descMap.value) // library marker kkossev.xiaomiLib, line 138
            if (rawData.size() == 24 && settings.enableDistanceDirection) { // library marker kkossev.xiaomiLib, line 139
                final int degrees = rawData[19] // library marker kkossev.xiaomiLib, line 140
                final int distanceCm = (rawData[17] << 8) | (rawData[18] & 0x00ff) // library marker kkossev.xiaomiLib, line 141
                if (settings.logEnable) { // library marker kkossev.xiaomiLib, line 142
                    log.debug "location ${degrees}&deg;, ${distanceCm}cm" // library marker kkossev.xiaomiLib, line 143
                } // library marker kkossev.xiaomiLib, line 144
                runIn(1, 'updateLocation', [ data: [ degrees: degrees, distanceCm: distanceCm ] ]) // library marker kkossev.xiaomiLib, line 145
            } // library marker kkossev.xiaomiLib, line 146
            break // library marker kkossev.xiaomiLib, line 147
        default: // library marker kkossev.xiaomiLib, line 148
            log.warn "zigbee received unknown xiaomi cluster 0xFCC0 attribute 0x${descMap.attrId} (value ${descMap.value})" // library marker kkossev.xiaomiLib, line 149
            break // library marker kkossev.xiaomiLib, line 150
    } // library marker kkossev.xiaomiLib, line 151
} // library marker kkossev.xiaomiLib, line 152

void parseXiaomiClusterTags(final Map<Integer, Object> tags) { // library marker kkossev.xiaomiLib, line 154
    tags.each { final Integer tag, final Object value -> // library marker kkossev.xiaomiLib, line 155
        switch (tag) { // library marker kkossev.xiaomiLib, line 156
            case 0x01:    // battery voltage // library marker kkossev.xiaomiLib, line 157
                logDebug "xiaomi decode tag: 0x${intToHexStr(tag, 1)} battery voltage is ${value/1000}V (raw=${value})" // library marker kkossev.xiaomiLib, line 158
                break // library marker kkossev.xiaomiLib, line 159
            case 0x03: // library marker kkossev.xiaomiLib, line 160
                logDebug "xiaomi decode tag: 0x${intToHexStr(tag, 1)} device temperature is ${value}&deg;" // library marker kkossev.xiaomiLib, line 161
                break // library marker kkossev.xiaomiLib, line 162
            case 0x05: // library marker kkossev.xiaomiLib, line 163
                logDebug "xiaomi decode tag: 0x${intToHexStr(tag, 1)} RSSI is ${value}" // library marker kkossev.xiaomiLib, line 164
                break // library marker kkossev.xiaomiLib, line 165
            case 0x06: // library marker kkossev.xiaomiLib, line 166
                logDebug "xiaomi decode tag: 0x${intToHexStr(tag, 1)} LQI is ${value}" // library marker kkossev.xiaomiLib, line 167
                break // library marker kkossev.xiaomiLib, line 168
            case 0x08:            // SWBUILD_TAG_ID: // library marker kkossev.xiaomiLib, line 169
                final String swBuild = '0.0.0_' + (value & 0xFF).toString().padLeft(4, '0') // library marker kkossev.xiaomiLib, line 170
                logDebug "xiaomi decode tag: 0x${intToHexStr(tag, 1)} swBuild is ${swBuild} (raw ${value})" // library marker kkossev.xiaomiLib, line 171
                device.updateDataValue("aqaraVersion", swBuild) // library marker kkossev.xiaomiLib, line 172
                break // library marker kkossev.xiaomiLib, line 173
            case 0x0a: // library marker kkossev.xiaomiLib, line 174
                String nwk = intToHexStr(value as Integer,2) // library marker kkossev.xiaomiLib, line 175
                if (state.health == null) { state.health = [:] } // library marker kkossev.xiaomiLib, line 176
                String oldNWK = state.health['parentNWK'] ?: 'n/a' // library marker kkossev.xiaomiLib, line 177
                logDebug "xiaomi decode tag: 0x${intToHexStr(tag, 1)} <b>Parent NWK is ${nwk}</b>" // library marker kkossev.xiaomiLib, line 178
                if (oldNWK != nwk ) { // library marker kkossev.xiaomiLib, line 179
                    logWarn "parentNWK changed from ${oldNWK} to ${nwk}" // library marker kkossev.xiaomiLib, line 180
                    state.health['parentNWK']  = nwk // library marker kkossev.xiaomiLib, line 181
                    state.health['nwkCtr'] = (state.health['nwkCtr'] ?: 0) + 1 // library marker kkossev.xiaomiLib, line 182
                } // library marker kkossev.xiaomiLib, line 183
                break // library marker kkossev.xiaomiLib, line 184
            case 0x0b: // library marker kkossev.xiaomiLib, line 185
                logDebug "xiaomi decode tag: 0x${intToHexStr(tag, 1)} light level is ${value}" // library marker kkossev.xiaomiLib, line 186
                break // library marker kkossev.xiaomiLib, line 187
            case 0x64: // library marker kkossev.xiaomiLib, line 188
                logDebug "xiaomi decode tag: 0x${intToHexStr(tag, 1)} temperature is ${value/100} (raw ${value})"    // Aqara TVOC // library marker kkossev.xiaomiLib, line 189
                // TODO - also smoke gas/density if UINT ! // library marker kkossev.xiaomiLib, line 190
                break // library marker kkossev.xiaomiLib, line 191
            case 0x65: // library marker kkossev.xiaomiLib, line 192
                if (isAqaraFP1()) { logDebug "xiaomi decode PRESENCE_TAG_ID tag: 0x${intToHexStr(tag, 1)}=${value}" } // library marker kkossev.xiaomiLib, line 193
                else              { logDebug "xiaomi decode tag: 0x${intToHexStr(tag, 1)} humidity is ${value/100} (raw ${value})" }    // Aqara TVOC // library marker kkossev.xiaomiLib, line 194
                break // library marker kkossev.xiaomiLib, line 195
            case 0x66: // library marker kkossev.xiaomiLib, line 196
                if (isAqaraFP1()) { logDebug "xiaomi decode SENSITIVITY_LEVEL_TAG_ID tag: 0x${intToHexStr(tag, 1)}=${value}" } // library marker kkossev.xiaomiLib, line 197
                else if (isAqaraTVOC()) { logDebug "xiaomi decode tag: 0x${intToHexStr(tag, 1)} airQualityIndex is ${value}" }        // Aqara TVOC level (in ppb) // library marker kkossev.xiaomiLib, line 198
                else                    { logDebug "xiaomi decode tag: 0x${intToHexStr(tag, 1)} presure is ${value}" }  // library marker kkossev.xiaomiLib, line 199
                break // library marker kkossev.xiaomiLib, line 200
            case 0x67: // library marker kkossev.xiaomiLib, line 201
                if (isAqaraFP1()) { logDebug "xiaomi decode DIRECTION_MODE_TAG_ID tag: 0x${intToHexStr(tag, 1)}=${value}" }     // library marker kkossev.xiaomiLib, line 202
                else              { logDebug "xiaomi decode unknown tag: 0x${intToHexStr(tag, 1)}=${value}" }                        // Aqara TVOC:  // library marker kkossev.xiaomiLib, line 203
                // air quality (as 6 - #stars) ['excellent', 'good', 'moderate', 'poor', 'unhealthy'][val - 1] // library marker kkossev.xiaomiLib, line 204
                break // library marker kkossev.xiaomiLib, line 205
            case 0x69: // library marker kkossev.xiaomiLib, line 206
                if (isAqaraFP1()) { logDebug "xiaomi decode TRIGGER_DISTANCE_TAG_ID tag: 0x${intToHexStr(tag, 1)}=${value}" } // library marker kkossev.xiaomiLib, line 207
                else              { logDebug "xiaomi decode unknown tag: 0x${intToHexStr(tag, 1)}=${value}" } // library marker kkossev.xiaomiLib, line 208
                break // library marker kkossev.xiaomiLib, line 209
            case 0x6a: // library marker kkossev.xiaomiLib, line 210
                if (isAqaraFP1()) { logDebug "xiaomi decode FP1 unknown tag: 0x${intToHexStr(tag, 1)}=${value}" } // library marker kkossev.xiaomiLib, line 211
                else              { logDebug "xiaomi decode MOTION SENSITIVITY tag: 0x${intToHexStr(tag, 1)}=${value}" } // library marker kkossev.xiaomiLib, line 212
                break // library marker kkossev.xiaomiLib, line 213
            case 0x6b: // library marker kkossev.xiaomiLib, line 214
                if (isAqaraFP1()) { logDebug "xiaomi decode FP1 unknown tag: 0x${intToHexStr(tag, 1)}=${value}" } // library marker kkossev.xiaomiLib, line 215
                else              { logDebug "xiaomi decode MOTION LED tag: 0x${intToHexStr(tag, 1)}=${value}" } // library marker kkossev.xiaomiLib, line 216
                break // library marker kkossev.xiaomiLib, line 217
            case 0x95: // library marker kkossev.xiaomiLib, line 218
                logDebug "xiaomi decode tag: 0x${intToHexStr(tag, 1)} energy is ${value}" // library marker kkossev.xiaomiLib, line 219
                break // library marker kkossev.xiaomiLib, line 220
            case 0x96: // library marker kkossev.xiaomiLib, line 221
                logDebug "xiaomi decode tag: 0x${intToHexStr(tag, 1)} voltage is ${value}" // library marker kkossev.xiaomiLib, line 222
                break // library marker kkossev.xiaomiLib, line 223
            case 0x97: // library marker kkossev.xiaomiLib, line 224
                logDebug "xiaomi decode tag: 0x${intToHexStr(tag, 1)} current is ${value}" // library marker kkossev.xiaomiLib, line 225
                break // library marker kkossev.xiaomiLib, line 226
            case 0x98: // library marker kkossev.xiaomiLib, line 227
                logDebug "xiaomi decode tag: 0x${intToHexStr(tag, 1)} power is ${value}" // library marker kkossev.xiaomiLib, line 228
                break // library marker kkossev.xiaomiLib, line 229
            case 0x9b: // library marker kkossev.xiaomiLib, line 230
                if (isAqaraCube()) {  // library marker kkossev.xiaomiLib, line 231
                    logDebug "Aqara cubeMode tag: 0x${intToHexStr(tag, 1)} is '${AqaraCubeModeOpts.options[value as int]}' (${value})"  // library marker kkossev.xiaomiLib, line 232
                    sendAqaraCubeOperationModeEvent(value as int) // library marker kkossev.xiaomiLib, line 233
                } // library marker kkossev.xiaomiLib, line 234
                else { logDebug "xiaomi decode CONSUMER CONNECTED tag: 0x${intToHexStr(tag, 1)}=${value}" } // library marker kkossev.xiaomiLib, line 235
                break // library marker kkossev.xiaomiLib, line 236
            default: // library marker kkossev.xiaomiLib, line 237
                logDebug "xiaomi decode unknown tag: 0x${intToHexStr(tag, 1)}=${value}" // library marker kkossev.xiaomiLib, line 238
        } // library marker kkossev.xiaomiLib, line 239
    } // library marker kkossev.xiaomiLib, line 240
} // library marker kkossev.xiaomiLib, line 241


/** // library marker kkossev.xiaomiLib, line 244
 *  Reads a specified number of little-endian bytes from a given // library marker kkossev.xiaomiLib, line 245
 *  ByteArrayInputStream and returns a BigInteger. // library marker kkossev.xiaomiLib, line 246
 */ // library marker kkossev.xiaomiLib, line 247
private static BigInteger readBigIntegerBytes(final ByteArrayInputStream stream, final int length) { // library marker kkossev.xiaomiLib, line 248
    final byte[] byteArr = new byte[length] // library marker kkossev.xiaomiLib, line 249
    stream.read(byteArr, 0, length) // library marker kkossev.xiaomiLib, line 250
    BigInteger bigInt = BigInteger.ZERO // library marker kkossev.xiaomiLib, line 251
    for (int i = byteArr.length - 1; i >= 0; i--) { // library marker kkossev.xiaomiLib, line 252
        bigInt |= (BigInteger.valueOf((byteArr[i] & 0xFF) << (8 * i))) // library marker kkossev.xiaomiLib, line 253
    } // library marker kkossev.xiaomiLib, line 254
    return bigInt // library marker kkossev.xiaomiLib, line 255
} // library marker kkossev.xiaomiLib, line 256

/** // library marker kkossev.xiaomiLib, line 258
 *  Decodes a Xiaomi Zigbee cluster attribute payload in hexadecimal format and // library marker kkossev.xiaomiLib, line 259
 *  returns a map of decoded tag number and value pairs where the value is either a // library marker kkossev.xiaomiLib, line 260
 *  BigInteger for fixed values or a String for variable length. // library marker kkossev.xiaomiLib, line 261
 */ // library marker kkossev.xiaomiLib, line 262
private static Map<Integer, Object> decodeXiaomiTags(final String hexString) { // library marker kkossev.xiaomiLib, line 263
    final Map<Integer, Object> results = [:] // library marker kkossev.xiaomiLib, line 264
    final byte[] bytes = HexUtils.hexStringToByteArray(hexString) // library marker kkossev.xiaomiLib, line 265
    new ByteArrayInputStream(bytes).withCloseable { final stream -> // library marker kkossev.xiaomiLib, line 266
        while (stream.available() > 2) { // library marker kkossev.xiaomiLib, line 267
            int tag = stream.read() // library marker kkossev.xiaomiLib, line 268
            int dataType = stream.read() // library marker kkossev.xiaomiLib, line 269
            Object value // library marker kkossev.xiaomiLib, line 270
            if (DataType.isDiscrete(dataType)) { // library marker kkossev.xiaomiLib, line 271
                int length = stream.read() // library marker kkossev.xiaomiLib, line 272
                byte[] byteArr = new byte[length] // library marker kkossev.xiaomiLib, line 273
                stream.read(byteArr, 0, length) // library marker kkossev.xiaomiLib, line 274
                value = new String(byteArr) // library marker kkossev.xiaomiLib, line 275
            } else { // library marker kkossev.xiaomiLib, line 276
                int length = DataType.getLength(dataType) // library marker kkossev.xiaomiLib, line 277
                value = readBigIntegerBytes(stream, length) // library marker kkossev.xiaomiLib, line 278
            } // library marker kkossev.xiaomiLib, line 279
            results[tag] = value // library marker kkossev.xiaomiLib, line 280
        } // library marker kkossev.xiaomiLib, line 281
    } // library marker kkossev.xiaomiLib, line 282
    return results // library marker kkossev.xiaomiLib, line 283
} // library marker kkossev.xiaomiLib, line 284


def refreshXiaomi() { // library marker kkossev.xiaomiLib, line 287
    List<String> cmds = [] // library marker kkossev.xiaomiLib, line 288
    if (cmds == []) { cmds = ["delay 299"] } // library marker kkossev.xiaomiLib, line 289
    return cmds // library marker kkossev.xiaomiLib, line 290
} // library marker kkossev.xiaomiLib, line 291

def configureXiaomi() { // library marker kkossev.xiaomiLib, line 293
    List<String> cmds = [] // library marker kkossev.xiaomiLib, line 294
    logDebug "configureThermostat() : ${cmds}" // library marker kkossev.xiaomiLib, line 295
    if (cmds == []) { cmds = ["delay 299"] }    // no ,  // library marker kkossev.xiaomiLib, line 296
    return cmds     // library marker kkossev.xiaomiLib, line 297
} // library marker kkossev.xiaomiLib, line 298

def initializeXiaomi() // library marker kkossev.xiaomiLib, line 300
{ // library marker kkossev.xiaomiLib, line 301
    List<String> cmds = [] // library marker kkossev.xiaomiLib, line 302
    logDebug "initializeXiaomi() : ${cmds}" // library marker kkossev.xiaomiLib, line 303
    if (cmds == []) { cmds = ["delay 299",] } // library marker kkossev.xiaomiLib, line 304
    return cmds         // library marker kkossev.xiaomiLib, line 305
} // library marker kkossev.xiaomiLib, line 306

void initVarsXiaomi(boolean fullInit=false) { // library marker kkossev.xiaomiLib, line 308
    logDebug "initVarsXiaomi(${fullInit})" // library marker kkossev.xiaomiLib, line 309
} // library marker kkossev.xiaomiLib, line 310

void initEventsXiaomi(boolean fullInit=false) { // library marker kkossev.xiaomiLib, line 312
    logDebug "initEventsXiaomi(${fullInit})" // library marker kkossev.xiaomiLib, line 313
} // library marker kkossev.xiaomiLib, line 314


// ~~~~~ end include (141) kkossev.xiaomiLib ~~~~~

// ~~~~~ start include (142) kkossev.deviceProfileLib ~~~~~
library ( // library marker kkossev.deviceProfileLib, line 1
    base: "driver", // library marker kkossev.deviceProfileLib, line 2
    author: "Krassimir Kossev", // library marker kkossev.deviceProfileLib, line 3
    category: "zigbee", // library marker kkossev.deviceProfileLib, line 4
    description: "Device Profile Library", // library marker kkossev.deviceProfileLib, line 5
    name: "deviceProfileLib", // library marker kkossev.deviceProfileLib, line 6
    namespace: "kkossev", // library marker kkossev.deviceProfileLib, line 7
    importUrl: "https://raw.githubusercontent.com/kkossev/hubitat/development/libraries/deviceProfileLib.groovy", // library marker kkossev.deviceProfileLib, line 8
    version: "1.0.0", // library marker kkossev.deviceProfileLib, line 9
    documentationLink: "" // library marker kkossev.deviceProfileLib, line 10
) // library marker kkossev.deviceProfileLib, line 11
/* // library marker kkossev.deviceProfileLib, line 12
 *  Device Profile Library // library marker kkossev.deviceProfileLib, line 13
 * // library marker kkossev.deviceProfileLib, line 14
 *  Licensed Virtual the Apache License, Version 2.0 (the "License"); you may not use this file except // library marker kkossev.deviceProfileLib, line 15
 *  in compliance with the License. You may obtain a copy of the License at: // library marker kkossev.deviceProfileLib, line 16
 * // library marker kkossev.deviceProfileLib, line 17
 *      http://www.apache.org/licenses/LICENSE-2.0 // library marker kkossev.deviceProfileLib, line 18
 * // library marker kkossev.deviceProfileLib, line 19
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed // library marker kkossev.deviceProfileLib, line 20
 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License // library marker kkossev.deviceProfileLib, line 21
 *  for the specific language governing permissions and limitations under the License. // library marker kkossev.deviceProfileLib, line 22
 * // library marker kkossev.deviceProfileLib, line 23
 * ver. 1.0.0  2023-11-04 kkossev  - added deviceProfileLib (based on Tuya 4 In 1 driver) // library marker kkossev.deviceProfileLib, line 24
 * ver. 3.0.0  2023-11-18 kkossev  - (dev. branch) // library marker kkossev.deviceProfileLib, line 25
 * // library marker kkossev.deviceProfileLib, line 26
 *                                   TODO: setPar refactoring // library marker kkossev.deviceProfileLib, line 27
*/ // library marker kkossev.deviceProfileLib, line 28

def deviceProfileLibVersion()   {"3.0.0"} // library marker kkossev.deviceProfileLib, line 30
def deviceProfileLibtamp() {"2023/11/18 11:55 PM"} // library marker kkossev.deviceProfileLib, line 31

metadata { // library marker kkossev.deviceProfileLib, line 33
    // no capabilities // library marker kkossev.deviceProfileLib, line 34
    // no attributes // library marker kkossev.deviceProfileLib, line 35
    command "sendCommand", [ // library marker kkossev.deviceProfileLib, line 36
        [name:"command", type: "STRING", description: "command name", constraints: ["STRING"]], // library marker kkossev.deviceProfileLib, line 37
        [name:"val",     type: "STRING", description: "command parameter value", constraints: ["STRING"]] // library marker kkossev.deviceProfileLib, line 38
    ] // library marker kkossev.deviceProfileLib, line 39
    command "setPar", [ // library marker kkossev.deviceProfileLib, line 40
            [name:"par", type: "STRING", description: "preference parameter name", constraints: ["STRING"]], // library marker kkossev.deviceProfileLib, line 41
            [name:"val", type: "STRING", description: "preference parameter value", constraints: ["STRING"]] // library marker kkossev.deviceProfileLib, line 42
    ]     // library marker kkossev.deviceProfileLib, line 43
    // // library marker kkossev.deviceProfileLib, line 44
    // itterate over DEVICE.preferences map and inputIt all! // library marker kkossev.deviceProfileLib, line 45
    (DEVICE.preferences).each { key, value -> // library marker kkossev.deviceProfileLib, line 46
        if (inputIt(key) != null) { // library marker kkossev.deviceProfileLib, line 47
            input inputIt(key) // library marker kkossev.deviceProfileLib, line 48
        } // library marker kkossev.deviceProfileLib, line 49
    }     // library marker kkossev.deviceProfileLib, line 50
    preferences { // library marker kkossev.deviceProfileLib, line 51
        if (advancedOptions == true) { // library marker kkossev.deviceProfileLib, line 52
            input (name: "forcedProfile", type: "enum", title: "<b>Device Profile</b>", description: "<i>Forcely change the Device Profile, if the model/manufacturer was not recognized automatically.<br>Warning! Manually setting a device profile may not always work!</i>",  options: getDeviceProfilesMap()) // library marker kkossev.deviceProfileLib, line 53
        } // library marker kkossev.deviceProfileLib, line 54
    } // library marker kkossev.deviceProfileLib, line 55
} // library marker kkossev.deviceProfileLib, line 56

def getDeviceGroup()     { state.deviceProfile ?: "UNKNOWN" } // library marker kkossev.deviceProfileLib, line 58
def getDEVICE()          { deviceProfilesV2[getDeviceGroup()] } // library marker kkossev.deviceProfileLib, line 59
def getDeviceProfiles()      { deviceProfilesV2.keySet() } // library marker kkossev.deviceProfileLib, line 60
def getDeviceProfilesMap()   {deviceProfilesV2.values().description as List<String>} // library marker kkossev.deviceProfileLib, line 61


/** // library marker kkossev.deviceProfileLib, line 64
 * Returns the profile key for a given profile description. // library marker kkossev.deviceProfileLib, line 65
 * @param valueStr The profile description to search for. // library marker kkossev.deviceProfileLib, line 66
 * @return The profile key if found, otherwise null. // library marker kkossev.deviceProfileLib, line 67
 */ // library marker kkossev.deviceProfileLib, line 68
def getProfileKey(String valueStr) { // library marker kkossev.deviceProfileLib, line 69
    def key = null // library marker kkossev.deviceProfileLib, line 70
    deviceProfilesV2.each {  profileName, profileMap -> // library marker kkossev.deviceProfileLib, line 71
        if (profileMap.description.equals(valueStr)) { // library marker kkossev.deviceProfileLib, line 72
            key = profileName // library marker kkossev.deviceProfileLib, line 73
        } // library marker kkossev.deviceProfileLib, line 74
    } // library marker kkossev.deviceProfileLib, line 75
    return key // library marker kkossev.deviceProfileLib, line 76
} // library marker kkossev.deviceProfileLib, line 77

/** // library marker kkossev.deviceProfileLib, line 79
 * Finds the preferences map for the given parameter. // library marker kkossev.deviceProfileLib, line 80
 * @param param The parameter to find the preferences map for. // library marker kkossev.deviceProfileLib, line 81
 * @param debug Whether or not to output debug logs. // library marker kkossev.deviceProfileLib, line 82
 * @return returns either tuyaDPs or attributes map, depending on where the preference (param) is found // library marker kkossev.deviceProfileLib, line 83
 * @return null if param is not defined for this device. // library marker kkossev.deviceProfileLib, line 84
 */ // library marker kkossev.deviceProfileLib, line 85
def getPreferencesMap( String param, boolean debug=false ) { // library marker kkossev.deviceProfileLib, line 86
    Map foundMap = [:] // library marker kkossev.deviceProfileLib, line 87
    if (!(param in DEVICE.preferences)) { // library marker kkossev.deviceProfileLib, line 88
        if (debug) { logWarn "getPreferencesMap: preference ${param} not defined for this device!" } // library marker kkossev.deviceProfileLib, line 89
        return null // library marker kkossev.deviceProfileLib, line 90
    } // library marker kkossev.deviceProfileLib, line 91
    def preference  // library marker kkossev.deviceProfileLib, line 92
    try { // library marker kkossev.deviceProfileLib, line 93
        preference = DEVICE.preferences["$param"] // library marker kkossev.deviceProfileLib, line 94
        if (debug) log.debug "getPreferencesMap: preference ${param} found. value is ${preference}" // library marker kkossev.deviceProfileLib, line 95
        if (preference in [true, false]) { // library marker kkossev.deviceProfileLib, line 96
            // find the preference in the tuyaDPs map // library marker kkossev.deviceProfileLib, line 97
            if (debug) { logDebug "getPreferencesMap: preference ${param} is boolean" } // library marker kkossev.deviceProfileLib, line 98
            return null     // no maps for predefined preferences ! // library marker kkossev.deviceProfileLib, line 99
        } // library marker kkossev.deviceProfileLib, line 100
        if (preference.isNumber()) { // library marker kkossev.deviceProfileLib, line 101
            // find the preference in the tuyaDPs map // library marker kkossev.deviceProfileLib, line 102
            int dp = safeToInt(preference) // library marker kkossev.deviceProfileLib, line 103
            def dpMaps   =  DEVICE.tuyaDPs  // library marker kkossev.deviceProfileLib, line 104
            foundMap = dpMaps.find { it.dp == dp } // library marker kkossev.deviceProfileLib, line 105
        } // library marker kkossev.deviceProfileLib, line 106
        else { // cluster:attribute // library marker kkossev.deviceProfileLib, line 107
            if (debug) log.trace "${DEVICE.attributes}" // library marker kkossev.deviceProfileLib, line 108
            def dpMaps   =  DEVICE.tuyaDPs  // library marker kkossev.deviceProfileLib, line 109
            foundMap = DEVICE.attributes.find { it.at == preference } // library marker kkossev.deviceProfileLib, line 110
        } // library marker kkossev.deviceProfileLib, line 111
        // TODO - could be also 'true' or 'false' ... // library marker kkossev.deviceProfileLib, line 112
    } catch (Exception e) { // library marker kkossev.deviceProfileLib, line 113
        if (debug) log.warn "getPreferencesMap: exception ${e} caught when getting preference ${param} !" // library marker kkossev.deviceProfileLib, line 114
        return null // library marker kkossev.deviceProfileLib, line 115
    } // library marker kkossev.deviceProfileLib, line 116
    if (debug) { logDebug "getPreferencesMap: foundMap = ${foundMap}" } // library marker kkossev.deviceProfileLib, line 117
    return foundMap      // library marker kkossev.deviceProfileLib, line 118
} // library marker kkossev.deviceProfileLib, line 119

def getAttributesMap( String attribName, boolean debug=false ) { // library marker kkossev.deviceProfileLib, line 121
    Map foundMap = null // library marker kkossev.deviceProfileLib, line 122
    def searchMap // library marker kkossev.deviceProfileLib, line 123
    if (debug) { logDebug "getAttributesMap: searching for attribute ${attribName} in tuyaDPs" } // library marker kkossev.deviceProfileLib, line 124
    if (DEVICE.tuyaDPs != null) { // library marker kkossev.deviceProfileLib, line 125
        searchMap =  DEVICE.tuyaDPs  // library marker kkossev.deviceProfileLib, line 126
        foundMap = searchMap.find { it.name == attribName } // library marker kkossev.deviceProfileLib, line 127
        if (foundMap != null) { // library marker kkossev.deviceProfileLib, line 128
            if (debug) { logDebug "getAttributesMap: foundMap = ${foundMap}" } // library marker kkossev.deviceProfileLib, line 129
            return foundMap // library marker kkossev.deviceProfileLib, line 130
        } // library marker kkossev.deviceProfileLib, line 131
    } // library marker kkossev.deviceProfileLib, line 132
    logDebug "getAttributesMap: searching for attribute ${attribName} in attributes" // library marker kkossev.deviceProfileLib, line 133
    if (DEVICE.attributes != null) { // library marker kkossev.deviceProfileLib, line 134
        searchMap  =  DEVICE.attributes  // library marker kkossev.deviceProfileLib, line 135
        foundMap = searchMap.find { it.name == attribName } // library marker kkossev.deviceProfileLib, line 136
        if (foundMap != null) { // library marker kkossev.deviceProfileLib, line 137
            if (debug) { logDebug "getAttributesMap: foundMap = ${foundMap}" } // library marker kkossev.deviceProfileLib, line 138
            return foundMap // library marker kkossev.deviceProfileLib, line 139
        } // library marker kkossev.deviceProfileLib, line 140
    } // library marker kkossev.deviceProfileLib, line 141
    if (debug) { logDebug "getAttributesMap: attribute ${attribName} not found in tuyaDPs or attributes map! foundMap=${foundMap}" } // library marker kkossev.deviceProfileLib, line 142
    return null // library marker kkossev.deviceProfileLib, line 143
} // library marker kkossev.deviceProfileLib, line 144


/** // library marker kkossev.deviceProfileLib, line 147
 * Resets the device preferences to their default values. // library marker kkossev.deviceProfileLib, line 148
 * @param debug A boolean indicating whether to output debug information. // library marker kkossev.deviceProfileLib, line 149
 */ // library marker kkossev.deviceProfileLib, line 150
def resetPreferencesToDefaults(boolean debug=false ) { // library marker kkossev.deviceProfileLib, line 151
    Map preferences = DEVICE?.preferences // library marker kkossev.deviceProfileLib, line 152
    if (preferences == null) { // library marker kkossev.deviceProfileLib, line 153
        if (debug) { logWarn "Preferences not found!" } // library marker kkossev.deviceProfileLib, line 154
        return // library marker kkossev.deviceProfileLib, line 155
    } // library marker kkossev.deviceProfileLib, line 156
    Map parMap = [:] // library marker kkossev.deviceProfileLib, line 157
    preferences.each{ parName, mapValue ->  // library marker kkossev.deviceProfileLib, line 158
        if (debug) log.trace "$parName $mapValue" // library marker kkossev.deviceProfileLib, line 159
        // TODO - could be also 'true' or 'false' ... // library marker kkossev.deviceProfileLib, line 160
        if (mapValue in [true, false]) { // library marker kkossev.deviceProfileLib, line 161
            if (debug) { logDebug "Preference ${parName} is predefined -> (${mapValue})" } // library marker kkossev.deviceProfileLib, line 162
            // TODO - set the predefined value // library marker kkossev.deviceProfileLib, line 163
            /* // library marker kkossev.deviceProfileLib, line 164
            if (debug) log.info "par ${parName} defaultValue = ${parMap.defaultValue}" // library marker kkossev.deviceProfileLib, line 165
            device.updateSetting("${parMap.name}",[value:parMap.defaultValue, type:parMap.type])      // library marker kkossev.deviceProfileLib, line 166
            */        // library marker kkossev.deviceProfileLib, line 167
            return // continue // library marker kkossev.deviceProfileLib, line 168
        } // library marker kkossev.deviceProfileLib, line 169
        // find the individual preference map // library marker kkossev.deviceProfileLib, line 170
        parMap = getPreferencesMap(parName, false) // library marker kkossev.deviceProfileLib, line 171
        if (parMap == null) { // library marker kkossev.deviceProfileLib, line 172
            if (debug) { logWarn "Preference ${parName} not found in tuyaDPs or attributes map!" } // library marker kkossev.deviceProfileLib, line 173
            return // continue // library marker kkossev.deviceProfileLib, line 174
        }    // library marker kkossev.deviceProfileLib, line 175
        // parMap = [at:0xE002:0xE005, name:staticDetectionSensitivity, type:number, dt:UINT8, rw:rw, min:0, max:5, step:1, scale:1, unit:x, title:Static Detection Sensitivity, description:Static detection sensitivity] // library marker kkossev.deviceProfileLib, line 176
        if (parMap.defaultValue == null) { // library marker kkossev.deviceProfileLib, line 177
            if (debug) { logWarn "no default value for preference ${parName} !" } // library marker kkossev.deviceProfileLib, line 178
            return // continue // library marker kkossev.deviceProfileLib, line 179
        } // library marker kkossev.deviceProfileLib, line 180
        if (debug) log.info "par ${parName} defaultValue = ${parMap.defaultValue}" // library marker kkossev.deviceProfileLib, line 181
        device.updateSetting("${parMap.name}",[value:parMap.defaultValue, type:parMap.type]) // library marker kkossev.deviceProfileLib, line 182
    } // library marker kkossev.deviceProfileLib, line 183
    logInfo "Preferences reset to default values" // library marker kkossev.deviceProfileLib, line 184
} // library marker kkossev.deviceProfileLib, line 185




/** // library marker kkossev.deviceProfileLib, line 190
 * Returns a list of valid parameters per model based on the device preferences. // library marker kkossev.deviceProfileLib, line 191
 * // library marker kkossev.deviceProfileLib, line 192
 * @return List of valid parameters. // library marker kkossev.deviceProfileLib, line 193
 */ // library marker kkossev.deviceProfileLib, line 194
def getValidParsPerModel() { // library marker kkossev.deviceProfileLib, line 195
    List<String> validPars = [] // library marker kkossev.deviceProfileLib, line 196
    if (DEVICE?.preferences != null && DEVICE?.preferences != [:]) { // library marker kkossev.deviceProfileLib, line 197
        // use the preferences to validate the parameters // library marker kkossev.deviceProfileLib, line 198
        validPars = DEVICE.preferences.keySet().toList() // library marker kkossev.deviceProfileLib, line 199
    } // library marker kkossev.deviceProfileLib, line 200
    return validPars // library marker kkossev.deviceProfileLib, line 201
} // library marker kkossev.deviceProfileLib, line 202


/** // library marker kkossev.deviceProfileLib, line 205
 * Returns the scaled value of a preference based on its type and scale. // library marker kkossev.deviceProfileLib, line 206
 * @param preference The name of the preference to retrieve. // library marker kkossev.deviceProfileLib, line 207
 * @param dpMap A map containing the type and scale of the preference. // library marker kkossev.deviceProfileLib, line 208
 * @return The scaled value of the preference, or null if the preference is not found or has an unsupported type. // library marker kkossev.deviceProfileLib, line 209
 */ // library marker kkossev.deviceProfileLib, line 210
def getScaledPreferenceValue(String preference, Map dpMap) { // library marker kkossev.deviceProfileLib, line 211
    def value = settings."${preference}" // library marker kkossev.deviceProfileLib, line 212
    def scaledValue // library marker kkossev.deviceProfileLib, line 213
    if (value == null) { // library marker kkossev.deviceProfileLib, line 214
        logDebug "getScaledPreferenceValue: preference ${preference} not found!" // library marker kkossev.deviceProfileLib, line 215
        return null // library marker kkossev.deviceProfileLib, line 216
    } // library marker kkossev.deviceProfileLib, line 217
    switch(dpMap.type) { // library marker kkossev.deviceProfileLib, line 218
        case "number" : // library marker kkossev.deviceProfileLib, line 219
            scaledValue = safeToInt(value) // library marker kkossev.deviceProfileLib, line 220
            break // library marker kkossev.deviceProfileLib, line 221
        case "decimal" : // library marker kkossev.deviceProfileLib, line 222
            scaledValue = safeToDouble(value) // library marker kkossev.deviceProfileLib, line 223
            if (dpMap.scale != null && dpMap.scale != 1) { // library marker kkossev.deviceProfileLib, line 224
                scaledValue = Math.round(scaledValue * dpMap.scale) // library marker kkossev.deviceProfileLib, line 225
            } // library marker kkossev.deviceProfileLib, line 226
            break // library marker kkossev.deviceProfileLib, line 227
        case "bool" : // library marker kkossev.deviceProfileLib, line 228
            scaledValue = value == "true" ? 1 : 0 // library marker kkossev.deviceProfileLib, line 229
            break // library marker kkossev.deviceProfileLib, line 230
        case "enum" : // library marker kkossev.deviceProfileLib, line 231
            //log.warn "getScaledPreferenceValue: <b>ENUM</b> preference ${preference} type:${dpMap.type} value = ${value} dpMap.scale=${dpMap.scale}" // library marker kkossev.deviceProfileLib, line 232
            if (dpMap.map == null) { // library marker kkossev.deviceProfileLib, line 233
                logDebug "getScaledPreferenceValue: preference ${preference} has no map defined!" // library marker kkossev.deviceProfileLib, line 234
                return null // library marker kkossev.deviceProfileLib, line 235
            } // library marker kkossev.deviceProfileLib, line 236
            scaledValue = value  // library marker kkossev.deviceProfileLib, line 237
            if (dpMap.scale != null && safeToInt(dpMap.scale) != 1) { // library marker kkossev.deviceProfileLib, line 238
                scaledValue = Math.round(safeToDouble(scaledValue ) * safeToInt(dpMap.scale)) // library marker kkossev.deviceProfileLib, line 239
            }             // library marker kkossev.deviceProfileLib, line 240
            break // library marker kkossev.deviceProfileLib, line 241
        default : // library marker kkossev.deviceProfileLib, line 242
            logDebug "getScaledPreferenceValue: preference ${preference} has unsupported type ${dpMap.type}!" // library marker kkossev.deviceProfileLib, line 243
            return null // library marker kkossev.deviceProfileLib, line 244
    } // library marker kkossev.deviceProfileLib, line 245
    //logDebug "getScaledPreferenceValue: preference ${preference} value = ${value} scaledValue = ${scaledValue} (scale=${dpMap.scale})"  // library marker kkossev.deviceProfileLib, line 246
    return scaledValue // library marker kkossev.deviceProfileLib, line 247
} // library marker kkossev.deviceProfileLib, line 248

// called from updated() method // library marker kkossev.deviceProfileLib, line 250
// TODO !!!!!!!!!! - refactor it !!!  IAS settings do not use Tuya DPs !!! // library marker kkossev.deviceProfileLib, line 251
void updateAllPreferences() { // library marker kkossev.deviceProfileLib, line 252
    logDebug "updateAllPreferences: preferences=${DEVICE.preferences}" // library marker kkossev.deviceProfileLib, line 253
    if (DEVICE.preferences == null || DEVICE.preferences == [:]) { // library marker kkossev.deviceProfileLib, line 254
        logDebug "updateAllPreferences: no preferences defined for device profile ${getDeviceGroup()}" // library marker kkossev.deviceProfileLib, line 255
        return // library marker kkossev.deviceProfileLib, line 256
    } // library marker kkossev.deviceProfileLib, line 257
    Integer dpInt = 0 // library marker kkossev.deviceProfileLib, line 258
    def scaledValue    // int or String for enums // library marker kkossev.deviceProfileLib, line 259
    (DEVICE.preferences).each { name, dp ->  // library marker kkossev.deviceProfileLib, line 260
        dpInt = safeToInt(dp, -1) // library marker kkossev.deviceProfileLib, line 261
        if (dpInt <= 0) { // library marker kkossev.deviceProfileLib, line 262
            // this is the IAS and other non-Tuya DPs preferences ....  // library marker kkossev.deviceProfileLib, line 263
            logDebug "updateAllPreferences: preference ${name} has invalid Tuya dp value ${dp}" // library marker kkossev.deviceProfileLib, line 264
            return  // library marker kkossev.deviceProfileLib, line 265
        } // library marker kkossev.deviceProfileLib, line 266
        def dpMaps   =  DEVICE.tuyaDPs  // library marker kkossev.deviceProfileLib, line 267
        Map foundMap // library marker kkossev.deviceProfileLib, line 268
        foundMap = getPreferencesMap(name) // library marker kkossev.deviceProfileLib, line 269
        //logDebug "updateAllPreferences: foundMap = ${foundMap}" // library marker kkossev.deviceProfileLib, line 270
        if (foundMap != null) { // library marker kkossev.deviceProfileLib, line 271
            scaledValue = getScaledPreferenceValue(name, foundMap) // library marker kkossev.deviceProfileLib, line 272
            setPar(name, scaledValue) // library marker kkossev.deviceProfileLib, line 273
        } // library marker kkossev.deviceProfileLib, line 274
        else { // library marker kkossev.deviceProfileLib, line 275
            logDebug "warning: couldn't find tuyaDPs map for preference ${name} (dp = ${dp})" // library marker kkossev.deviceProfileLib, line 276
            return  // library marker kkossev.deviceProfileLib, line 277
        } // library marker kkossev.deviceProfileLib, line 278
    }     // library marker kkossev.deviceProfileLib, line 279
    return // library marker kkossev.deviceProfileLib, line 280
} // library marker kkossev.deviceProfileLib, line 281

def divideBy100( val ) { return (val as int) / 100 } // library marker kkossev.deviceProfileLib, line 283
def multiplyBy100( val ) { return (val as int) * 100 } // library marker kkossev.deviceProfileLib, line 284
def divideBy10( val ) {  // library marker kkossev.deviceProfileLib, line 285
    if (val > 10) { return (val as int) / 10 } // library marker kkossev.deviceProfileLib, line 286
    else { return (val as int) } // library marker kkossev.deviceProfileLib, line 287
} // library marker kkossev.deviceProfileLib, line 288
def multiplyBy10( val ) { return (val as int) * 10 } // library marker kkossev.deviceProfileLib, line 289
def divideBy1( val ) { return (val as int) / 1 }    //tests // library marker kkossev.deviceProfileLib, line 290

/** // library marker kkossev.deviceProfileLib, line 292
 * Called from setPar() method only! // library marker kkossev.deviceProfileLib, line 293
 * Validates the parameter value based on the given dpMap type and scales it if needed. // library marker kkossev.deviceProfileLib, line 294
 *  // library marker kkossev.deviceProfileLib, line 295
 * @param dpMap The map containing the parameter type, minimum and maximum values. // library marker kkossev.deviceProfileLib, line 296
 * @param val The value to be validated and scaled. // library marker kkossev.deviceProfileLib, line 297
 * @return The validated and scaled value if it is within the specified range, null otherwise. // library marker kkossev.deviceProfileLib, line 298
 */ // library marker kkossev.deviceProfileLib, line 299
def validateAndScaleParameterValue(Map dpMap, String val) { // library marker kkossev.deviceProfileLib, line 300
    def value = null    // validated value - integer, floar // library marker kkossev.deviceProfileLib, line 301
    def scaledValue = null // library marker kkossev.deviceProfileLib, line 302
    //logDebug "validateAndScaleParameterValue: dpMap=${dpMap} val=${val}" // library marker kkossev.deviceProfileLib, line 303
    switch (dpMap.type) { // library marker kkossev.deviceProfileLib, line 304
        case "number" : // library marker kkossev.deviceProfileLib, line 305
            value = safeToInt(val, -1) // library marker kkossev.deviceProfileLib, line 306
            scaledValue = value // library marker kkossev.deviceProfileLib, line 307
            // scale the value - added 10/26/2023 also for integer values ! // library marker kkossev.deviceProfileLib, line 308
            if (dpMap.scale != null) { // library marker kkossev.deviceProfileLib, line 309
                scaledValue = (value * dpMap.scale) as Integer // library marker kkossev.deviceProfileLib, line 310
            }             // library marker kkossev.deviceProfileLib, line 311
            break // library marker kkossev.deviceProfileLib, line 312
        case "decimal" : // library marker kkossev.deviceProfileLib, line 313
             value = safeToDouble(val, -1.0) // library marker kkossev.deviceProfileLib, line 314
            // scale the value // library marker kkossev.deviceProfileLib, line 315
            if (dpMap.scale != null) { // library marker kkossev.deviceProfileLib, line 316
                scaledValue = (value * dpMap.scale) as Integer // library marker kkossev.deviceProfileLib, line 317
            } // library marker kkossev.deviceProfileLib, line 318
            break // library marker kkossev.deviceProfileLib, line 319
        case "bool" : // library marker kkossev.deviceProfileLib, line 320
            if (val == '0' || val == 'false')     { value = scaledValue = 0 } // library marker kkossev.deviceProfileLib, line 321
            else if (val == '1' || val == 'true') { value = scaledValue = 1 } // library marker kkossev.deviceProfileLib, line 322
            else { // library marker kkossev.deviceProfileLib, line 323
                log.warn "${device.displayName} sevalidateAndScaleParameterValue: bool parameter <b>${val}</b>. value must be one of <b>0 1 false true</b>" // library marker kkossev.deviceProfileLib, line 324
                return null // library marker kkossev.deviceProfileLib, line 325
            } // library marker kkossev.deviceProfileLib, line 326
            break // library marker kkossev.deviceProfileLib, line 327
        case "enum" : // library marker kkossev.deviceProfileLib, line 328
            // val could be both integer or float value ... check if the scaling is different than 1 in dpMap  // library marker kkossev.deviceProfileLib, line 329

            if (dpMap.scale != null && safeToInt(dpMap.scale) != 1) { // library marker kkossev.deviceProfileLib, line 331
                // we have a float parameter input - convert it to int // library marker kkossev.deviceProfileLib, line 332
                value = safeToDouble(val, -1.0) // library marker kkossev.deviceProfileLib, line 333
                scaledValue = (value * safeToInt(dpMap.scale)) as Integer // library marker kkossev.deviceProfileLib, line 334
            } // library marker kkossev.deviceProfileLib, line 335
            else { // library marker kkossev.deviceProfileLib, line 336
                value = scaledValue = safeToInt(val, -1) // library marker kkossev.deviceProfileLib, line 337
            } // library marker kkossev.deviceProfileLib, line 338
            if (scaledValue == null || scaledValue < 0) { // library marker kkossev.deviceProfileLib, line 339
                // get the keys of dpMap.map as a List // library marker kkossev.deviceProfileLib, line 340
                List<String> keys = dpMap.map.keySet().toList() // library marker kkossev.deviceProfileLib, line 341
                log.warn "${device.displayName} validateAndScaleParameterValue: enum parameter <b>${val}</b>. value must be one of <b>${keys}</b>" // library marker kkossev.deviceProfileLib, line 342
                return null // library marker kkossev.deviceProfileLib, line 343
            } // library marker kkossev.deviceProfileLib, line 344
            break // library marker kkossev.deviceProfileLib, line 345
        default : // library marker kkossev.deviceProfileLib, line 346
            logWarn "validateAndScaleParameterValue: unsupported dpMap type <b>${parType}</b>" // library marker kkossev.deviceProfileLib, line 347
            return null // library marker kkossev.deviceProfileLib, line 348
    } // library marker kkossev.deviceProfileLib, line 349
    //log.warn "validateAndScaleParameterValue before checking  scaledValue=${scaledValue}" // library marker kkossev.deviceProfileLib, line 350
    // check if the value is within the specified range // library marker kkossev.deviceProfileLib, line 351
    if ((dpMap.min != null && value < dpMap.min) || (dpMap.max != null && value > dpMap.max)) { // library marker kkossev.deviceProfileLib, line 352
        log.warn "${device.displayName} validateAndScaleParameterValue: invalid ${dpMap.name} parameter value <b>${value}</b> (scaled ${scaledValue}). Value must be within ${dpMap.min} and ${dpMap.max}" // library marker kkossev.deviceProfileLib, line 353
        return null // library marker kkossev.deviceProfileLib, line 354
    } // library marker kkossev.deviceProfileLib, line 355
    //log.warn "validateAndScaleParameterValue returning scaledValue=${scaledValue}" // library marker kkossev.deviceProfileLib, line 356
    return scaledValue // library marker kkossev.deviceProfileLib, line 357
} // library marker kkossev.deviceProfileLib, line 358

/** // library marker kkossev.deviceProfileLib, line 360
 * Sets the parameter value for the device. // library marker kkossev.deviceProfileLib, line 361
 * @param par The name of the parameter to set. // library marker kkossev.deviceProfileLib, line 362
 * @param val The value to set the parameter to. // library marker kkossev.deviceProfileLib, line 363
 * @return Nothing. // library marker kkossev.deviceProfileLib, line 364
 * // library marker kkossev.deviceProfileLib, line 365
 * TODO: refactor it !!! // library marker kkossev.deviceProfileLib, line 366
 */ // library marker kkossev.deviceProfileLib, line 367
def setPar( par=null, val=null ) // library marker kkossev.deviceProfileLib, line 368
{ // library marker kkossev.deviceProfileLib, line 369
    ArrayList<String> cmds = [] // library marker kkossev.deviceProfileLib, line 370
    Boolean validated = false // library marker kkossev.deviceProfileLib, line 371
    logDebug "setPar(${par}, ${val})" // library marker kkossev.deviceProfileLib, line 372
    if (DEVICE?.preferences == null || DEVICE?.preferences == [:]) { return } // library marker kkossev.deviceProfileLib, line 373
    if (par == null /*|| !(par in getValidParsPerModel())*/) { log.warn "${device.displayName} setPar: 'parameter' must be one of these : ${getValidParsPerModel()}"; return }         // library marker kkossev.deviceProfileLib, line 374
    Map dpMap = getPreferencesMap(par, false)                                   // get the map for the parameter // library marker kkossev.deviceProfileLib, line 375
    if ( dpMap == null ) { log.warn "${device.displayName} setPar: tuyaDPs map not found for parameter <b>${par}</b>"; return } // library marker kkossev.deviceProfileLib, line 376
    if (val == null) { log.warn "${device.displayName} setPar: 'value' must be specified for parameter <b>${par}</b> in the range ${dpMap.min} to ${dpMap.max}"; return } // library marker kkossev.deviceProfileLib, line 377
    def scaledValue = validateAndScaleParameterValue(dpMap, val as String)      // convert the val to the correct type and scale it if needed // library marker kkossev.deviceProfileLib, line 378
    if (scaledValue == null) { log.warn "${device.displayName} setPar: invalid parameter value <b>${val}</b>. Must be in the range ${dpMap.min} to ${dpMap.max}"; return } // library marker kkossev.deviceProfileLib, line 379
    /* // library marker kkossev.deviceProfileLib, line 380
    // update the device setting // TODO: decide whether the setting must be updated here, or after it is echeod back from the device // library marker kkossev.deviceProfileLib, line 381
    try { // library marker kkossev.deviceProfileLib, line 382
        device.updateSetting("$par", [value:val, type:dpMap.type]) // library marker kkossev.deviceProfileLib, line 383
    } // library marker kkossev.deviceProfileLib, line 384
    catch (e) { // library marker kkossev.deviceProfileLib, line 385
        logWarn "setPar: Exception '${e}'caught while updateSetting <b>$par</b>(<b>$val</b>) type=${dpMap.type}" // library marker kkossev.deviceProfileLib, line 386
        return // library marker kkossev.deviceProfileLib, line 387
    } // library marker kkossev.deviceProfileLib, line 388
    */ // library marker kkossev.deviceProfileLib, line 389
    //logDebug "setPar: parameter ${par} value ${val}, type ${dpMap.type} validated and scaled to ${scaledValue} type=${dpMap.type}" // library marker kkossev.deviceProfileLib, line 390
    // if there is a dedicated set function, use it // library marker kkossev.deviceProfileLib, line 391
    String capitalizedFirstChar = par[0].toUpperCase() + par[1..-1] // library marker kkossev.deviceProfileLib, line 392
    String setFunction = "set${capitalizedFirstChar}" // library marker kkossev.deviceProfileLib, line 393
    if (this.respondsTo(setFunction)) { // library marker kkossev.deviceProfileLib, line 394
        logDebug "setPar: found setFunction=${setFunction}, scaledValue=${scaledValue}  (val=${val})" // library marker kkossev.deviceProfileLib, line 395
        // execute the setFunction // library marker kkossev.deviceProfileLib, line 396
        try { // library marker kkossev.deviceProfileLib, line 397
            cmds = "$setFunction"(scaledValue) // library marker kkossev.deviceProfileLib, line 398
        } // library marker kkossev.deviceProfileLib, line 399
        catch (e) { // library marker kkossev.deviceProfileLib, line 400
            logWarn "setPar: Exception '${e}'caught while processing <b>$setFunction</b>(<b>$scaledValue</b>) (val=${val}))" // library marker kkossev.deviceProfileLib, line 401
            return // library marker kkossev.deviceProfileLib, line 402
        } // library marker kkossev.deviceProfileLib, line 403
        logDebug "setFunction result is ${cmds}"        // library marker kkossev.deviceProfileLib, line 404
        if (cmds != null && cmds != []) { // library marker kkossev.deviceProfileLib, line 405
            logInfo "setPar: successfluly executed setPar <b>$setFunction</b>(<b>$scaledValue</b>)" // library marker kkossev.deviceProfileLib, line 406
            sendZigbeeCommands( cmds ) // library marker kkossev.deviceProfileLib, line 407
            return // library marker kkossev.deviceProfileLib, line 408
        }             // library marker kkossev.deviceProfileLib, line 409
        else { // library marker kkossev.deviceProfileLib, line 410
            logWarn "setPar: setFunction <b>$setFunction</b>(<b>$scaledValue</b>) returned null or empty list" // library marker kkossev.deviceProfileLib, line 411
            // continue with the default processing // library marker kkossev.deviceProfileLib, line 412
        } // library marker kkossev.deviceProfileLib, line 413
    } // library marker kkossev.deviceProfileLib, line 414
    // check whether this is a tuya DP or a cluster:attribute parameter // library marker kkossev.deviceProfileLib, line 415
    boolean isTuyaDP // library marker kkossev.deviceProfileLib, line 416
    def preference = dpMap.dp // library marker kkossev.deviceProfileLib, line 417
    try { // library marker kkossev.deviceProfileLib, line 418
        isTuyaDP = true //preference.isNumber() // library marker kkossev.deviceProfileLib, line 419
    } // library marker kkossev.deviceProfileLib, line 420
    catch (e) { // library marker kkossev.deviceProfileLib, line 421
        if (debug) log.warn "setPar: exception ${e} caught while checking isNumber() preference ${preference}" // library marker kkossev.deviceProfileLib, line 422
        return null // library marker kkossev.deviceProfileLib, line 423
    }      // library marker kkossev.deviceProfileLib, line 424
    if (dpMap.dp != null && isTuyaDP) { // library marker kkossev.deviceProfileLib, line 425
        // Tuya DP // library marker kkossev.deviceProfileLib, line 426
        cmds = sendTuyaParameter(dpMap,  par, scaledValue)  // library marker kkossev.deviceProfileLib, line 427
        if (cmds == null || cmds == []) { // library marker kkossev.deviceProfileLib, line 428
            logWarn "setPar: sendTuyaParameter par ${par} scaledValue ${scaledValue} returned null or empty list" // library marker kkossev.deviceProfileLib, line 429
            return // library marker kkossev.deviceProfileLib, line 430
        } // library marker kkossev.deviceProfileLib, line 431
        else { // library marker kkossev.deviceProfileLib, line 432
            logInfo "setPar: successfluly executed setPar <b>$setFunction</b>(<b>$val</b> (scaledValue=${scaledValue}))" // library marker kkossev.deviceProfileLib, line 433
            sendZigbeeCommands( cmds ) // library marker kkossev.deviceProfileLib, line 434
            return // library marker kkossev.deviceProfileLib, line 435
        } // library marker kkossev.deviceProfileLib, line 436
    } // library marker kkossev.deviceProfileLib, line 437
    else if (dpMap.at != null) { // library marker kkossev.deviceProfileLib, line 438
        // cluster:attribute // library marker kkossev.deviceProfileLib, line 439
        int cluster // library marker kkossev.deviceProfileLib, line 440
        int attribute // library marker kkossev.deviceProfileLib, line 441
        int dt // library marker kkossev.deviceProfileLib, line 442
        int mfgCode // library marker kkossev.deviceProfileLib, line 443
        try { // library marker kkossev.deviceProfileLib, line 444
            cluster = hubitat.helper.HexUtils.hexStringToInt(dpMap.at.split(":")[0]) // library marker kkossev.deviceProfileLib, line 445
            attribute = hubitat.helper.HexUtils.hexStringToInt(dpMap.at.split(":")[1]) // library marker kkossev.deviceProfileLib, line 446
            dt = hubitat.helper.HexUtils.hexStringToInt(dpMap.dt) // library marker kkossev.deviceProfileLib, line 447
            mfgCode = dpMap.mfgCode != null ? hubitat.helper.HexUtils.hexStringToInt(dpMap.mfgCode) : null // library marker kkossev.deviceProfileLib, line 448
        } // library marker kkossev.deviceProfileLib, line 449
        catch (e) { // library marker kkossev.deviceProfileLib, line 450
            logWarn "setPar: Exception '${e}'caught while splitting cluser and attribute <b>$setFunction</b>(<b>$scaledValue</b>) (val=${val}))" // library marker kkossev.deviceProfileLib, line 451
            return // library marker kkossev.deviceProfileLib, line 452
        } // library marker kkossev.deviceProfileLib, line 453
        Map mapMfCode = ["mfgCode":mfgCode] // library marker kkossev.deviceProfileLib, line 454
        logDebug "setPar: found cluster=${cluster} attribute=${attribute} dt=${dpMap.dt} mapMfCode=${mapMfCode} scaledValue=${scaledValue}  (val=${val})" // library marker kkossev.deviceProfileLib, line 455
        if (mfgCode != null) { // library marker kkossev.deviceProfileLib, line 456
            cmds = zigbee.writeAttribute(cluster, attribute, dt, scaledValue, mapMfCode, delay=200) // library marker kkossev.deviceProfileLib, line 457
        } // library marker kkossev.deviceProfileLib, line 458
        else { // library marker kkossev.deviceProfileLib, line 459
            cmds = zigbee.writeAttribute(cluster, attribute, dt, scaledValue, [:], delay=200) // library marker kkossev.deviceProfileLib, line 460
        } // library marker kkossev.deviceProfileLib, line 461
    } // library marker kkossev.deviceProfileLib, line 462
    else { // library marker kkossev.deviceProfileLib, line 463
        logWarn "setPar: invalid dp or at value <b>${dpMap.dp}</b> for parameter <b>${par}</b>" // library marker kkossev.deviceProfileLib, line 464
        return // library marker kkossev.deviceProfileLib, line 465
    } // library marker kkossev.deviceProfileLib, line 466
    logInfo "setPar: successfluly executed setPar <b>$setFunction</b>(<b>$scaledValue</b>)" // library marker kkossev.deviceProfileLib, line 467
    sendZigbeeCommands( cmds ) // library marker kkossev.deviceProfileLib, line 468
    return // library marker kkossev.deviceProfileLib, line 469
} // library marker kkossev.deviceProfileLib, line 470

// function to send a Tuya command to data point taken from dpMap with value tuyaValue and type taken from dpMap // library marker kkossev.deviceProfileLib, line 472
// TODO - reuse it !!! // library marker kkossev.deviceProfileLib, line 473
def sendTuyaParameter( Map dpMap, String par, tuyaValue) { // library marker kkossev.deviceProfileLib, line 474
    //logDebug "sendTuyaParameter: trying to send parameter ${par} value ${tuyaValue}" // library marker kkossev.deviceProfileLib, line 475
    ArrayList<String> cmds = [] // library marker kkossev.deviceProfileLib, line 476
    if (dpMap == null) { // library marker kkossev.deviceProfileLib, line 477
        log.warn "${device.displayName} sendTuyaParameter: tuyaDPs map not found for parameter <b>${par}</b>" // library marker kkossev.deviceProfileLib, line 478
        return null // library marker kkossev.deviceProfileLib, line 479
    } // library marker kkossev.deviceProfileLib, line 480
    String dp = zigbee.convertToHexString(dpMap.dp, 2) // library marker kkossev.deviceProfileLib, line 481
    if (dpMap.dp <= 0 || dpMap.dp >= 256) { // library marker kkossev.deviceProfileLib, line 482
        log.warn "${device.displayName} sendTuyaParameter: invalid dp <b>${dpMap.dp}</b> for parameter <b>${par}</b>" // library marker kkossev.deviceProfileLib, line 483
        return null  // library marker kkossev.deviceProfileLib, line 484
    } // library marker kkossev.deviceProfileLib, line 485
    String dpType // library marker kkossev.deviceProfileLib, line 486
    if (dpMap.dt == null) { // library marker kkossev.deviceProfileLib, line 487
        dpType = dpMap.type == "bool" ? DP_TYPE_BOOL : dpMap.type == "enum" ? DP_TYPE_ENUM : (dpMap.type in ["value", "number", "decimal"]) ? DP_TYPE_VALUE: null // library marker kkossev.deviceProfileLib, line 488
    } // library marker kkossev.deviceProfileLib, line 489
    else { // library marker kkossev.deviceProfileLib, line 490
        dpType = dpMap.dt // "01" - bool, "02" - enum, "03" - value // library marker kkossev.deviceProfileLib, line 491
    } // library marker kkossev.deviceProfileLib, line 492
    //log.debug "dpType = ${dpType}" // library marker kkossev.deviceProfileLib, line 493
    if (dpType == null) { // library marker kkossev.deviceProfileLib, line 494
        log.warn "${device.displayName} sendTuyaParameter: invalid dpType <b>${dpMap.type}</b> for parameter <b>${par}</b>" // library marker kkossev.deviceProfileLib, line 495
        return null  // library marker kkossev.deviceProfileLib, line 496
    } // library marker kkossev.deviceProfileLib, line 497
    // sendTuyaCommand // library marker kkossev.deviceProfileLib, line 498
    def dpValHex = dpType == DP_TYPE_VALUE ? zigbee.convertToHexString(tuyaValue as int, 8) : zigbee.convertToHexString(tuyaValue as int, 2)  // library marker kkossev.deviceProfileLib, line 499
    logDebug "sendTuyaParameter: sending parameter ${par} dpValHex ${dpValHex} (raw=${tuyaValue}) Tuya dp=${dp} dpType=${dpType} " // library marker kkossev.deviceProfileLib, line 500
    cmds = sendTuyaCommand( dp, dpType, dpValHex) // library marker kkossev.deviceProfileLib, line 501
    return cmds // library marker kkossev.deviceProfileLib, line 502
} // library marker kkossev.deviceProfileLib, line 503

def sendAttribute( par=null, val=null ) // library marker kkossev.deviceProfileLib, line 505
{ // library marker kkossev.deviceProfileLib, line 506
    ArrayList<String> cmds = [] // library marker kkossev.deviceProfileLib, line 507
    Boolean validated = false // library marker kkossev.deviceProfileLib, line 508
    logDebug "sendAttribute(${par}, ${val})" // library marker kkossev.deviceProfileLib, line 509
    if (par == null || DEVICE?.preferences == null || DEVICE?.preferences == [:]) { return } // library marker kkossev.deviceProfileLib, line 510

    Map dpMap = getAttributesMap(par, false)                                   // get the map for the attribute // library marker kkossev.deviceProfileLib, line 512
    if ( dpMap == null ) { log.warn "${device.displayName} sendAttribute: map not found for parameter <b>${par}</b>"; return } // library marker kkossev.deviceProfileLib, line 513
    if (val == null) { log.warn "${device.displayName} sendAttribute: 'value' must be specified for parameter <b>${par}</b> in the range ${dpMap.min} to ${dpMap.max}"; return } // library marker kkossev.deviceProfileLib, line 514
    def scaledValue = validateAndScaleParameterValue(dpMap, val as String)      // convert the val to the correct type and scale it if needed // library marker kkossev.deviceProfileLib, line 515
    if (scaledValue == null) { log.warn "${device.displayName} sendAttribute: invalid parameter value <b>${val}</b>. Must be in the range ${dpMap.min} to ${dpMap.max}"; return } // library marker kkossev.deviceProfileLib, line 516
    logDebug "sendAttribute: parameter ${par} value ${val}, type ${dpMap.type} validated and scaled to ${scaledValue} type=${dpMap.type}" // library marker kkossev.deviceProfileLib, line 517
    // if there is a dedicated set function, use it // library marker kkossev.deviceProfileLib, line 518
    String capitalizedFirstChar = par[0].toUpperCase() + par[1..-1] // library marker kkossev.deviceProfileLib, line 519
    String setFunction = "set${capitalizedFirstChar}" // library marker kkossev.deviceProfileLib, line 520
    if (this.respondsTo(setFunction) && (setFunction != "setHeatingSetpoint" && setFunction != "setCoolingSetpoint")) { // library marker kkossev.deviceProfileLib, line 521
        logDebug "sendAttribute: found setFunction=${setFunction}, scaledValue=${scaledValue}  (val=${val})" // library marker kkossev.deviceProfileLib, line 522
        // execute the setFunction // library marker kkossev.deviceProfileLib, line 523
        try { // library marker kkossev.deviceProfileLib, line 524
            cmds = "$setFunction"(scaledValue) // library marker kkossev.deviceProfileLib, line 525
        } // library marker kkossev.deviceProfileLib, line 526
        catch (e) { // library marker kkossev.deviceProfileLib, line 527
            logWarn "sendAttribute: Exception '${e}'caught while processing <b>$setFunction</b>(<b>$scaledValue</b>) (val=${val}))" // library marker kkossev.deviceProfileLib, line 528
            return // library marker kkossev.deviceProfileLib, line 529
        } // library marker kkossev.deviceProfileLib, line 530
        logDebug "setFunction result is ${cmds}"        // library marker kkossev.deviceProfileLib, line 531
        if (cmds != null && cmds != []) { // library marker kkossev.deviceProfileLib, line 532
            logDebug "sendAttribute: successfluly executed sendAttribute <b>$setFunction</b>(<b>$scaledValue</b>)" // library marker kkossev.deviceProfileLib, line 533
            sendZigbeeCommands( cmds ) // library marker kkossev.deviceProfileLib, line 534
            return // library marker kkossev.deviceProfileLib, line 535
        }             // library marker kkossev.deviceProfileLib, line 536
        else { // library marker kkossev.deviceProfileLib, line 537
            logWarn "sendAttribute: setFunction <b>$setFunction</b>(<b>$scaledValue</b>) returned null or empty list" // library marker kkossev.deviceProfileLib, line 538
            // continue with the default processing // library marker kkossev.deviceProfileLib, line 539
        } // library marker kkossev.deviceProfileLib, line 540
    } // library marker kkossev.deviceProfileLib, line 541
    // check whether this is a tuya DP or a cluster:attribute parameter // library marker kkossev.deviceProfileLib, line 542
    boolean isTuyaDP // library marker kkossev.deviceProfileLib, line 543
    def preference = dpMap.dp // library marker kkossev.deviceProfileLib, line 544
    try { // library marker kkossev.deviceProfileLib, line 545
        isTuyaDP = true //preference.isNumber() // library marker kkossev.deviceProfileLib, line 546
    } // library marker kkossev.deviceProfileLib, line 547
    catch (e) { // library marker kkossev.deviceProfileLib, line 548
        if (debug) log.warn "sendAttribute: exception ${e} caught while checking isNumber() preference ${preference}" // library marker kkossev.deviceProfileLib, line 549
        return null // library marker kkossev.deviceProfileLib, line 550
    }      // library marker kkossev.deviceProfileLib, line 551
    if (dpMap.dp != null && isTuyaDP) { // library marker kkossev.deviceProfileLib, line 552
        // Tuya DP // library marker kkossev.deviceProfileLib, line 553
        cmds = sendTuyaParameter(dpMap,  par, scaledValue)  // library marker kkossev.deviceProfileLib, line 554
        if (cmds == null || cmds == []) { // library marker kkossev.deviceProfileLib, line 555
            logWarn "sendAttribute: sendTuyaParameter par ${par} scaledValue ${scaledValue} returned null or empty list" // library marker kkossev.deviceProfileLib, line 556
            return // library marker kkossev.deviceProfileLib, line 557
        } // library marker kkossev.deviceProfileLib, line 558
        else { // library marker kkossev.deviceProfileLib, line 559
            logDebug "sendAttribute: successfluly executed sendAttribute <b>$setFunction</b>(<b>$val</b> (scaledValue=${scaledValue}))" // library marker kkossev.deviceProfileLib, line 560
            sendZigbeeCommands( cmds ) // library marker kkossev.deviceProfileLib, line 561
            return // library marker kkossev.deviceProfileLib, line 562
        } // library marker kkossev.deviceProfileLib, line 563
    } // library marker kkossev.deviceProfileLib, line 564
    else if (dpMap.at != null) { // library marker kkossev.deviceProfileLib, line 565
        // cluster:attribute // library marker kkossev.deviceProfileLib, line 566
        int cluster // library marker kkossev.deviceProfileLib, line 567
        int attribute // library marker kkossev.deviceProfileLib, line 568
        int dt // library marker kkossev.deviceProfileLib, line 569
        int mfgCode // library marker kkossev.deviceProfileLib, line 570
        try { // library marker kkossev.deviceProfileLib, line 571
            cluster = hubitat.helper.HexUtils.hexStringToInt(dpMap.at.split(":")[0]) // library marker kkossev.deviceProfileLib, line 572
            attribute = hubitat.helper.HexUtils.hexStringToInt(dpMap.at.split(":")[1]) // library marker kkossev.deviceProfileLib, line 573
            dt = hubitat.helper.HexUtils.hexStringToInt(dpMap.dt) // library marker kkossev.deviceProfileLib, line 574
            mfgCode = dpMap.mfgCode != null ? hubitat.helper.HexUtils.hexStringToInt(dpMap.mfgCode) : null // library marker kkossev.deviceProfileLib, line 575
        } // library marker kkossev.deviceProfileLib, line 576
        catch (e) { // library marker kkossev.deviceProfileLib, line 577
            logWarn "sendAttribute: Exception '${e}'caught while splitting cluser and attribute <b>$setFunction</b>(<b>$scaledValue</b>) (val=${val}))" // library marker kkossev.deviceProfileLib, line 578
            return // library marker kkossev.deviceProfileLib, line 579
        } // library marker kkossev.deviceProfileLib, line 580
        Map mapMfCode = ["mfgCode":mfgCode] // library marker kkossev.deviceProfileLib, line 581
        logDebug "sendAttribute: found cluster=${cluster} attribute=${attribute} dt=${dpMap.dt} mapMfCode=${mapMfCode} scaledValue=${scaledValue}  (val=${val})" // library marker kkossev.deviceProfileLib, line 582
        if (mfgCode != null) { // library marker kkossev.deviceProfileLib, line 583
            cmds = zigbee.writeAttribute(cluster, attribute, dt, scaledValue, mapMfCode, delay=200) // library marker kkossev.deviceProfileLib, line 584
        } // library marker kkossev.deviceProfileLib, line 585
        else { // library marker kkossev.deviceProfileLib, line 586
            cmds = zigbee.writeAttribute(cluster, attribute, dt, scaledValue, [:], delay=200) // library marker kkossev.deviceProfileLib, line 587
        } // library marker kkossev.deviceProfileLib, line 588
    } // library marker kkossev.deviceProfileLib, line 589
    else { // library marker kkossev.deviceProfileLib, line 590
        logWarn "sendAttribute: invalid dp or at value <b>${dpMap.dp}</b> for parameter <b>${par}</b>" // library marker kkossev.deviceProfileLib, line 591
        return // library marker kkossev.deviceProfileLib, line 592
    } // library marker kkossev.deviceProfileLib, line 593
    logDebug "sendAttribute: successfluly executed sendAttribute <b>$setFunction</b>(<b>$scaledValue</b>)" // library marker kkossev.deviceProfileLib, line 594
    sendZigbeeCommands( cmds ) // library marker kkossev.deviceProfileLib, line 595
    return // library marker kkossev.deviceProfileLib, line 596
} // library marker kkossev.deviceProfileLib, line 597


/** // library marker kkossev.deviceProfileLib, line 600
 * Sends a command to the device. // library marker kkossev.deviceProfileLib, line 601
 * @param command The command to send. Must be one of the commands defined in the DEVICE.commands map. // library marker kkossev.deviceProfileLib, line 602
 * @param val The value to send with the command. // library marker kkossev.deviceProfileLib, line 603
 * @return void // library marker kkossev.deviceProfileLib, line 604
 */ // library marker kkossev.deviceProfileLib, line 605
def sendCommand( command=null, val=null ) // library marker kkossev.deviceProfileLib, line 606
{ // library marker kkossev.deviceProfileLib, line 607
    //logDebug "sending command ${command}(${val}))" // library marker kkossev.deviceProfileLib, line 608
    ArrayList<String> cmds = [] // library marker kkossev.deviceProfileLib, line 609
    def supportedCommandsMap = DEVICE.commands  // library marker kkossev.deviceProfileLib, line 610
    if (supportedCommandsMap == null || supportedCommandsMap == []) { // library marker kkossev.deviceProfileLib, line 611
        logWarn "sendCommand: no commands defined for device profile ${getDeviceGroup()} !" // library marker kkossev.deviceProfileLib, line 612
        return // library marker kkossev.deviceProfileLib, line 613
    } // library marker kkossev.deviceProfileLib, line 614
    // TODO: compare ignoring the upper/lower case of the command. // library marker kkossev.deviceProfileLib, line 615
    def supportedCommandsList =  DEVICE.commands.keySet() as List  // library marker kkossev.deviceProfileLib, line 616
    // check if the command is defined in the DEVICE commands map // library marker kkossev.deviceProfileLib, line 617
    if (command == null || !(command in supportedCommandsList)) { // library marker kkossev.deviceProfileLib, line 618
        logWarn "sendCommand: the command <b>${(command ?: '')}</b> for device profile '${DEVICE.description}' must be one of these : ${supportedCommandsList}" // library marker kkossev.deviceProfileLib, line 619
        return // library marker kkossev.deviceProfileLib, line 620
    } // library marker kkossev.deviceProfileLib, line 621
    def func // library marker kkossev.deviceProfileLib, line 622
    try { // library marker kkossev.deviceProfileLib, line 623
        func = DEVICE.commands.find { it.key == command }.value // library marker kkossev.deviceProfileLib, line 624
        if (val != null) { // library marker kkossev.deviceProfileLib, line 625
            cmds = "${func}"(val) // library marker kkossev.deviceProfileLib, line 626
            logInfo "executed <b>$func</b>($val)" // library marker kkossev.deviceProfileLib, line 627
        } // library marker kkossev.deviceProfileLib, line 628
        else { // library marker kkossev.deviceProfileLib, line 629
            cmds = "${func}"() // library marker kkossev.deviceProfileLib, line 630
            logInfo "executed <b>$func</b>()" // library marker kkossev.deviceProfileLib, line 631
        } // library marker kkossev.deviceProfileLib, line 632
    } // library marker kkossev.deviceProfileLib, line 633
    catch (e) { // library marker kkossev.deviceProfileLib, line 634
        logWarn "sendCommand: Exception '${e}' caught while processing <b>$func</b>(${val})" // library marker kkossev.deviceProfileLib, line 635
        return // library marker kkossev.deviceProfileLib, line 636
    } // library marker kkossev.deviceProfileLib, line 637
    if (cmds != null && cmds != []) { // library marker kkossev.deviceProfileLib, line 638
        sendZigbeeCommands( cmds ) // library marker kkossev.deviceProfileLib, line 639
    } // library marker kkossev.deviceProfileLib, line 640
} // library marker kkossev.deviceProfileLib, line 641

/** // library marker kkossev.deviceProfileLib, line 643
 * This method takes a string parameter and a boolean debug flag as input and returns a map containing the input details. // library marker kkossev.deviceProfileLib, line 644
 * The method checks if the input parameter is defined in the device preferences and returns null if it is not. // library marker kkossev.deviceProfileLib, line 645
 * It then checks if the input parameter is a boolean value and skips it if it is. // library marker kkossev.deviceProfileLib, line 646
 * The method also checks if the input parameter is a number and sets the isTuyaDP flag accordingly. // library marker kkossev.deviceProfileLib, line 647
 * If the input parameter is read-only, the method returns null. // library marker kkossev.deviceProfileLib, line 648
 * The method then populates the input map with the name, type, title, description, range, options, and default value of the input parameter. // library marker kkossev.deviceProfileLib, line 649
 * If the input parameter type is not supported, the method returns null. // library marker kkossev.deviceProfileLib, line 650
 * @param param The input parameter to be checked. // library marker kkossev.deviceProfileLib, line 651
 * @param debug A boolean flag indicating whether to log debug messages or not. // library marker kkossev.deviceProfileLib, line 652
 * @return A map containing the input details. // library marker kkossev.deviceProfileLib, line 653
 */ // library marker kkossev.deviceProfileLib, line 654
def inputIt( String param, boolean debug=false ) { // library marker kkossev.deviceProfileLib, line 655
    Map input = [:] // library marker kkossev.deviceProfileLib, line 656
    Map foundMap = [:] // library marker kkossev.deviceProfileLib, line 657
    if (!(param in DEVICE.preferences)) { // library marker kkossev.deviceProfileLib, line 658
        if (debug) log.warn "inputIt: preference ${param} not defined for this device!" // library marker kkossev.deviceProfileLib, line 659
        return null // library marker kkossev.deviceProfileLib, line 660
    } // library marker kkossev.deviceProfileLib, line 661
    def preference // library marker kkossev.deviceProfileLib, line 662
    boolean isTuyaDP  // library marker kkossev.deviceProfileLib, line 663
    try { // library marker kkossev.deviceProfileLib, line 664
        preference = DEVICE.preferences["$param"] // library marker kkossev.deviceProfileLib, line 665
    } // library marker kkossev.deviceProfileLib, line 666
    catch (e) { // library marker kkossev.deviceProfileLib, line 667
        if (debug) log.warn "inputIt: exception ${e} caught while parsing preference ${param} value ${preference}" // library marker kkossev.deviceProfileLib, line 668
        return null // library marker kkossev.deviceProfileLib, line 669
    }    // library marker kkossev.deviceProfileLib, line 670
    //  check for boolean values // library marker kkossev.deviceProfileLib, line 671
    try { // library marker kkossev.deviceProfileLib, line 672
        if (preference in [true, false]) { // library marker kkossev.deviceProfileLib, line 673
            if (debug) log.warn "inputIt: preference ${param} is boolean value ${preference} - skipping it for now!" // library marker kkossev.deviceProfileLib, line 674
            return null // library marker kkossev.deviceProfileLib, line 675
        } // library marker kkossev.deviceProfileLib, line 676
    } // library marker kkossev.deviceProfileLib, line 677
    catch (e) { // library marker kkossev.deviceProfileLib, line 678
        if (debug) log.warn "inputIt: exception ${e} caught while checking for boolean values preference ${param} value ${preference}" // library marker kkossev.deviceProfileLib, line 679
        return null // library marker kkossev.deviceProfileLib, line 680
    }  // library marker kkossev.deviceProfileLib, line 681

    try { // library marker kkossev.deviceProfileLib, line 683
        isTuyaDP = preference.isNumber() // library marker kkossev.deviceProfileLib, line 684
    } // library marker kkossev.deviceProfileLib, line 685
    catch (e) { // library marker kkossev.deviceProfileLib, line 686
        if (debug) log.warn "inputIt: exception ${e} caught while checking isNumber() preference ${param} value ${preference}" // library marker kkossev.deviceProfileLib, line 687
        return null // library marker kkossev.deviceProfileLib, line 688
    }  // library marker kkossev.deviceProfileLib, line 689

    //if (debug) log.debug "inputIt: preference ${param} found. value is ${preference} isTuyaDP=${isTuyaDP}" // library marker kkossev.deviceProfileLib, line 691
    foundMap = getPreferencesMap(param) // library marker kkossev.deviceProfileLib, line 692
    //if (debug) log.debug "foundMap = ${foundMap}" // library marker kkossev.deviceProfileLib, line 693
    if (foundMap == null) { // library marker kkossev.deviceProfileLib, line 694
        if (debug) log.warn "inputIt: map not found for param '${param}'!" // library marker kkossev.deviceProfileLib, line 695
        return null // library marker kkossev.deviceProfileLib, line 696
    } // library marker kkossev.deviceProfileLib, line 697
    if (foundMap.rw != "rw") { // library marker kkossev.deviceProfileLib, line 698
        if (debug) log.warn "inputIt: param '${param}' is read only!" // library marker kkossev.deviceProfileLib, line 699
        return null // library marker kkossev.deviceProfileLib, line 700
    }         // library marker kkossev.deviceProfileLib, line 701
    input.name = foundMap.name // library marker kkossev.deviceProfileLib, line 702
    input.type = foundMap.type    // bool, enum, number, decimal // library marker kkossev.deviceProfileLib, line 703
    input.title = foundMap.title // library marker kkossev.deviceProfileLib, line 704
    input.description = foundMap.description // library marker kkossev.deviceProfileLib, line 705
    if (input.type in ["number", "decimal"]) { // library marker kkossev.deviceProfileLib, line 706
        if (foundMap.min != null && foundMap.max != null) { // library marker kkossev.deviceProfileLib, line 707
            input.range = "${foundMap.min}..${foundMap.max}" // library marker kkossev.deviceProfileLib, line 708
        } // library marker kkossev.deviceProfileLib, line 709
        if (input.range != null && input.description !=null) { // library marker kkossev.deviceProfileLib, line 710
            input.description += "<br><i>Range: ${input.range}</i>" // library marker kkossev.deviceProfileLib, line 711
            if (foundMap.unit != null && foundMap.unit != "") { // library marker kkossev.deviceProfileLib, line 712
                input.description += " <i>(${foundMap.unit})</i>" // library marker kkossev.deviceProfileLib, line 713
            } // library marker kkossev.deviceProfileLib, line 714
        } // library marker kkossev.deviceProfileLib, line 715
    } // library marker kkossev.deviceProfileLib, line 716
    else if (input.type == "enum") { // library marker kkossev.deviceProfileLib, line 717
        input.options = foundMap.map // library marker kkossev.deviceProfileLib, line 718
    }/* // library marker kkossev.deviceProfileLib, line 719
    else if (input.type == "bool") { // library marker kkossev.deviceProfileLib, line 720
        input.options = ["true", "false"] // library marker kkossev.deviceProfileLib, line 721
    }*/ // library marker kkossev.deviceProfileLib, line 722
    else { // library marker kkossev.deviceProfileLib, line 723
        if (debug) log.warn "inputIt: unsupported type ${input.type} for param '${param}'!" // library marker kkossev.deviceProfileLib, line 724
        return null // library marker kkossev.deviceProfileLib, line 725
    }    // library marker kkossev.deviceProfileLib, line 726
    if (input.defaultValue != null) { // library marker kkossev.deviceProfileLib, line 727
        input.defaultValue = foundMap.defaultValue // library marker kkossev.deviceProfileLib, line 728
    } // library marker kkossev.deviceProfileLib, line 729
    return input // library marker kkossev.deviceProfileLib, line 730
} // library marker kkossev.deviceProfileLib, line 731


/** // library marker kkossev.deviceProfileLib, line 734
 * Returns the device name and profile based on the device model and manufacturer. // library marker kkossev.deviceProfileLib, line 735
 * @param model The device model (optional). If not provided, it will be retrieved from the device data value. // library marker kkossev.deviceProfileLib, line 736
 * @param manufacturer The device manufacturer (optional). If not provided, it will be retrieved from the device data value. // library marker kkossev.deviceProfileLib, line 737
 * @return A list containing the device name and profile. // library marker kkossev.deviceProfileLib, line 738
 */ // library marker kkossev.deviceProfileLib, line 739
def getDeviceNameAndProfile( model=null, manufacturer=null) { // library marker kkossev.deviceProfileLib, line 740
    def deviceName         = UNKNOWN // library marker kkossev.deviceProfileLib, line 741
    def deviceProfile      = UNKNOWN // library marker kkossev.deviceProfileLib, line 742
    String deviceModel        = model != null ? model : device.getDataValue('model') ?: UNKNOWN // library marker kkossev.deviceProfileLib, line 743
    String deviceManufacturer = manufacturer != null ? manufacturer : device.getDataValue('manufacturer') ?: UNKNOWN // library marker kkossev.deviceProfileLib, line 744
    deviceProfilesV2.each { profileName, profileMap -> // library marker kkossev.deviceProfileLib, line 745
        profileMap.fingerprints.each { fingerprint -> // library marker kkossev.deviceProfileLib, line 746
            if (fingerprint.model == deviceModel && fingerprint.manufacturer == deviceManufacturer) { // library marker kkossev.deviceProfileLib, line 747
                deviceProfile = profileName // library marker kkossev.deviceProfileLib, line 748
                deviceName = fingerprint.deviceJoinName ?: deviceProfilesV2[deviceProfile].deviceJoinName ?: UNKNOWN // library marker kkossev.deviceProfileLib, line 749
                logDebug "<b>found exact match</b> for model ${deviceModel} manufacturer ${deviceManufacturer} : <b>profileName=${deviceProfile}</b> deviceName =${deviceName}" // library marker kkossev.deviceProfileLib, line 750
                return [deviceName, deviceProfile] // library marker kkossev.deviceProfileLib, line 751
            } // library marker kkossev.deviceProfileLib, line 752
        } // library marker kkossev.deviceProfileLib, line 753
    } // library marker kkossev.deviceProfileLib, line 754
    if (deviceProfile == UNKNOWN) { // library marker kkossev.deviceProfileLib, line 755
        logWarn "<b>NOT FOUND!</b> deviceName =${deviceName} profileName=${deviceProfile} for model ${deviceModel} manufacturer ${deviceManufacturer}" // library marker kkossev.deviceProfileLib, line 756
    } // library marker kkossev.deviceProfileLib, line 757
    return [deviceName, deviceProfile] // library marker kkossev.deviceProfileLib, line 758
} // library marker kkossev.deviceProfileLib, line 759

// called from  initializeVars( fullInit = true) // library marker kkossev.deviceProfileLib, line 761
def setDeviceNameAndProfile( model=null, manufacturer=null) { // library marker kkossev.deviceProfileLib, line 762
    def (String deviceName, String deviceProfile) = getDeviceNameAndProfile(model, manufacturer) // library marker kkossev.deviceProfileLib, line 763
    if (deviceProfile == null || deviceProfile == UNKNOWN) { // library marker kkossev.deviceProfileLib, line 764
        logWarn "unknown model ${deviceModel} manufacturer ${deviceManufacturer}" // library marker kkossev.deviceProfileLib, line 765
        // don't change the device name when unknown // library marker kkossev.deviceProfileLib, line 766
        state.deviceProfile = UNKNOWN // library marker kkossev.deviceProfileLib, line 767
    } // library marker kkossev.deviceProfileLib, line 768
    def dataValueModel = model != null ? model : device.getDataValue('model') ?: UNKNOWN // library marker kkossev.deviceProfileLib, line 769
    def dataValueManufacturer  = manufacturer != null ? manufacturer : device.getDataValue('manufacturer') ?: UNKNOWN // library marker kkossev.deviceProfileLib, line 770
    if (deviceName != NULL && deviceName != UNKNOWN  ) { // library marker kkossev.deviceProfileLib, line 771
        device.setName(deviceName) // library marker kkossev.deviceProfileLib, line 772
        state.deviceProfile = deviceProfile // library marker kkossev.deviceProfileLib, line 773
        device.updateSetting("forcedProfile", [value:deviceProfilesV2[deviceProfile].description, type:"enum"]) // library marker kkossev.deviceProfileLib, line 774
        //logDebug "after : forcedProfile = ${settings.forcedProfile}" // library marker kkossev.deviceProfileLib, line 775
        logInfo "device model ${dataValueModel} manufacturer ${dataValueManufacturer} was set to : <b>deviceProfile=${deviceProfile} : deviceName=${deviceName}</b>" // library marker kkossev.deviceProfileLib, line 776
    } else { // library marker kkossev.deviceProfileLib, line 777
        logWarn "device model ${dataValueModel} manufacturer ${dataValueManufacturer} was not found!" // library marker kkossev.deviceProfileLib, line 778
    }     // library marker kkossev.deviceProfileLib, line 779
} // library marker kkossev.deviceProfileLib, line 780

def refreshDeviceProfile() { // library marker kkossev.deviceProfileLib, line 782
    List<String> cmds = [] // library marker kkossev.deviceProfileLib, line 783
    if (cmds == []) { cmds = ["delay 299"] } // library marker kkossev.deviceProfileLib, line 784
    logDebug "refreshDeviceProfile() : ${cmds}" // library marker kkossev.deviceProfileLib, line 785
    return cmds // library marker kkossev.deviceProfileLib, line 786
} // library marker kkossev.deviceProfileLib, line 787

def configureDeviceProfile() { // library marker kkossev.deviceProfileLib, line 789
    List<String> cmds = [] // library marker kkossev.deviceProfileLib, line 790
    logDebug "configureDeviceProfile() : ${cmds}" // library marker kkossev.deviceProfileLib, line 791
    if (cmds == []) { cmds = ["delay 299"] }    // no ,  // library marker kkossev.deviceProfileLib, line 792
    return cmds     // library marker kkossev.deviceProfileLib, line 793
} // library marker kkossev.deviceProfileLib, line 794

def initializeDeviceProfile() // library marker kkossev.deviceProfileLib, line 796
{ // library marker kkossev.deviceProfileLib, line 797
    List<String> cmds = [] // library marker kkossev.deviceProfileLib, line 798
    logDebug "initializeDeviceProfile() : ${cmds}" // library marker kkossev.deviceProfileLib, line 799
    if (cmds == []) { cmds = ["delay 299",] } // library marker kkossev.deviceProfileLib, line 800
    return cmds         // library marker kkossev.deviceProfileLib, line 801
} // library marker kkossev.deviceProfileLib, line 802

void initVarsDeviceProfile(boolean fullInit=false) { // library marker kkossev.deviceProfileLib, line 804
    logDebug "initVarsDeviceProfile(${fullInit})" // library marker kkossev.deviceProfileLib, line 805
    if (state.deviceProfile == null) { // library marker kkossev.deviceProfileLib, line 806
        setDeviceNameAndProfile() // library marker kkossev.deviceProfileLib, line 807
    }     // library marker kkossev.deviceProfileLib, line 808
} // library marker kkossev.deviceProfileLib, line 809

void initEventsDeviceProfile(boolean fullInit=false) { // library marker kkossev.deviceProfileLib, line 811
    logDebug "initEventsDeviceProfile(${fullInit})" // library marker kkossev.deviceProfileLib, line 812
} // library marker kkossev.deviceProfileLib, line 813

///////////////////////////// Tuya DPs ///////////////////////////////// // library marker kkossev.deviceProfileLib, line 815


// // library marker kkossev.deviceProfileLib, line 818
// called from parse() // library marker kkossev.deviceProfileLib, line 819
// returns: true  - do not process this message if the spammy DP is defined in the spammyDPsToIgnore element of the active Device Profule // library marker kkossev.deviceProfileLib, line 820
//          false - the processing can continue // library marker kkossev.deviceProfileLib, line 821
// // library marker kkossev.deviceProfileLib, line 822
boolean isSpammyDPsToIgnore(descMap) { // library marker kkossev.deviceProfileLib, line 823
    if (!(descMap?.clusterId == "EF00" && (descMap?.command in ["01", "02"]))) { return false } // library marker kkossev.deviceProfileLib, line 824
    if (descMap?.data?.size <= 2) { return false } // library marker kkossev.deviceProfileLib, line 825
    Integer dp =  zigbee.convertHexToInt(descMap.data[2]) // library marker kkossev.deviceProfileLib, line 826
    def spammyList = deviceProfilesV2[getDeviceGroup()].spammyDPsToIgnore // library marker kkossev.deviceProfileLib, line 827
    return (spammyList != null && (dp in spammyList) && ((settings?.ignoreDistance ?: false) == true)) // library marker kkossev.deviceProfileLib, line 828
} // library marker kkossev.deviceProfileLib, line 829

// // library marker kkossev.deviceProfileLib, line 831
// called from processTuyaDP(), processTuyaDPfromDeviceProfile() // library marker kkossev.deviceProfileLib, line 832
// returns: true  - do not generate Debug log messages if the chatty DP is defined in the spammyDPsToNotTrace element of the active Device Profule // library marker kkossev.deviceProfileLib, line 833
//          false - debug logs can be generated // library marker kkossev.deviceProfileLib, line 834
// // library marker kkossev.deviceProfileLib, line 835
boolean isSpammyDPsToNotTrace(descMap) { // library marker kkossev.deviceProfileLib, line 836
    if (!(descMap?.clusterId == "EF00" && (descMap?.command in ["01", "02"]))) { return false } // library marker kkossev.deviceProfileLib, line 837
    if (descMap?.data?.size <= 2) { return false } // library marker kkossev.deviceProfileLib, line 838
    Integer dp = zigbee.convertHexToInt(descMap.data[2])  // library marker kkossev.deviceProfileLib, line 839
    def spammyList = deviceProfilesV2[getDeviceGroup()].spammyDPsToNotTrace // library marker kkossev.deviceProfileLib, line 840
    return (spammyList != null && (dp in spammyList)) // library marker kkossev.deviceProfileLib, line 841
} // library marker kkossev.deviceProfileLib, line 842

def compareAndConvertStrings(foundItem, tuyaValue, hubitatValue) { // library marker kkossev.deviceProfileLib, line 844
    String convertedValue = tuyaValue // library marker kkossev.deviceProfileLib, line 845
    boolean isEqual    = ((tuyaValue  as String) == (hubitatValue as String))      // because the events(attributes) are always strings // library marker kkossev.deviceProfileLib, line 846
    return [isEqual, convertedValue] // library marker kkossev.deviceProfileLib, line 847
} // library marker kkossev.deviceProfileLib, line 848

def compareAndConvertNumbers(foundItem, tuyaValue, hubitatValue) { // library marker kkossev.deviceProfileLib, line 850
    Integer convertedValue // library marker kkossev.deviceProfileLib, line 851
    if (foundItem.scale == null || foundItem.scale == 0 || foundItem.scale == 1) {    // compare as integer // library marker kkossev.deviceProfileLib, line 852
        convertedValue = tuyaValue as int                 // library marker kkossev.deviceProfileLib, line 853
    } // library marker kkossev.deviceProfileLib, line 854
    else { // library marker kkossev.deviceProfileLib, line 855
        convertedValue  = ((tuyaValue as double) / (foundItem.scale as double)) as int // library marker kkossev.deviceProfileLib, line 856
    } // library marker kkossev.deviceProfileLib, line 857
    boolean isEqual = ((convertedValue as int) == (hubitatValue as int)) // library marker kkossev.deviceProfileLib, line 858
    return [isEqual, convertedValue] // library marker kkossev.deviceProfileLib, line 859
} // library marker kkossev.deviceProfileLib, line 860

def compareAndConvertDecimals(foundItem, tuyaValue, hubitatValue) { // library marker kkossev.deviceProfileLib, line 862
    Double convertedValue // library marker kkossev.deviceProfileLib, line 863
    if (foundItem.scale == null || foundItem.scale == 0 || foundItem.scale == 1) { // library marker kkossev.deviceProfileLib, line 864
        convertedValue = tuyaValue as double // library marker kkossev.deviceProfileLib, line 865
    } // library marker kkossev.deviceProfileLib, line 866
    else { // library marker kkossev.deviceProfileLib, line 867
        convertedValue = (tuyaValue as double) / (foundItem.scale as double)  // library marker kkossev.deviceProfileLib, line 868
    } // library marker kkossev.deviceProfileLib, line 869
    isEqual = Math.abs((convertedValue as double) - (hubitatValue as double)) < 0.001  // library marker kkossev.deviceProfileLib, line 870
    return [isEqual, convertedValue] // library marker kkossev.deviceProfileLib, line 871
} // library marker kkossev.deviceProfileLib, line 872


def compareAndConvertTuyaToHubitatPreferenceValue(foundItem, fncmd, preference) { // library marker kkossev.deviceProfileLib, line 875
    if (foundItem == null || fncmd == null || preference == null) { return [true, "none"] } // library marker kkossev.deviceProfileLib, line 876
    if (foundItem.type == null) { return [true, "none"] } // library marker kkossev.deviceProfileLib, line 877
    boolean isEqual // library marker kkossev.deviceProfileLib, line 878
    def tuyaValueScaled     // could be integer or float // library marker kkossev.deviceProfileLib, line 879
    switch (foundItem.type) { // library marker kkossev.deviceProfileLib, line 880
        case "bool" :       // [0:"OFF", 1:"ON"]  // library marker kkossev.deviceProfileLib, line 881
        case "enum" :       // [0:"inactive", 1:"active"] // library marker kkossev.deviceProfileLib, line 882
            (isEqual, tuyaValueScaled) = compareAndConvertNumbers(foundItem, safeToInt(fncmd), safeToInt(preference)) // library marker kkossev.deviceProfileLib, line 883
            //logDebug "compareAndConvertTuyaToHubitatPreferenceValue: preference = ${preference} <b>type=${foundItem.type}</b>  foundItem=${foundItem.name} <b>isEqual=${isEqual}</b> preferenceValue=${preferenceValue} tuyaValueScaled=${tuyaValueScaled} fncmd=${fncmd}" // library marker kkossev.deviceProfileLib, line 884
            break // library marker kkossev.deviceProfileLib, line 885
        case "value" :      // depends on foundItem.scale // library marker kkossev.deviceProfileLib, line 886
        case "number" : // library marker kkossev.deviceProfileLib, line 887
            (isEqual, tuyaValueScaled) = compareAndConvertNumbers(foundItem, safeToInt(fncmd), safeToInt(preference)) // library marker kkossev.deviceProfileLib, line 888
            //log.warn "tuyaValue=${tuyaValue} tuyaValueScaled=${tuyaValueScaled} preferenceValue = ${preference} isEqual=${isEqual}" // library marker kkossev.deviceProfileLib, line 889
            break  // library marker kkossev.deviceProfileLib, line 890
       case "decimal" : // library marker kkossev.deviceProfileLib, line 891
            (isEqual, tuyaValueScaled) = compareAndConvertDecimals(foundItem, safeToDouble(fncmd), safeToDouble(preference))  // library marker kkossev.deviceProfileLib, line 892
            //logDebug "comparing as float tuyaValue=${tuyaValue} foundItem.scale=${foundItem.scale} tuyaValueScaled=${tuyaValueScaled} to preferenceValue = ${preference}" // library marker kkossev.deviceProfileLib, line 893
            break // library marker kkossev.deviceProfileLib, line 894
        default : // library marker kkossev.deviceProfileLib, line 895
            logDebug "compareAndConvertTuyaToHubitatPreferenceValue: unsupported type %{foundItem.type}" // library marker kkossev.deviceProfileLib, line 896
            return [true, "none"]   // fallback - assume equal // library marker kkossev.deviceProfileLib, line 897
    } // library marker kkossev.deviceProfileLib, line 898
    if (isEqual == false) { // library marker kkossev.deviceProfileLib, line 899
        logDebug "compareAndConvertTuyaToHubitatPreferenceValue: preference = ${preference} <b>type=${foundItem.type}</b> foundItem=${foundItem.name} <b>isEqual=${isEqual}</b> tuyaValueScaled=${tuyaValueScaled} (scale=${foundItem.scale}) fncmd=${fncmd}" // library marker kkossev.deviceProfileLib, line 900
    } // library marker kkossev.deviceProfileLib, line 901
    // // library marker kkossev.deviceProfileLib, line 902
    return [isEqual, tuyaValueScaled] // library marker kkossev.deviceProfileLib, line 903
} // library marker kkossev.deviceProfileLib, line 904

// // library marker kkossev.deviceProfileLib, line 906
// called from processTuyaDPfromDeviceProfile() // library marker kkossev.deviceProfileLib, line 907
// compares the value of the DP foundItem against a Preference with the same name // library marker kkossev.deviceProfileLib, line 908
// returns: (two results!) // library marker kkossev.deviceProfileLib, line 909
//    isEqual : true  - if the Tuya DP value equals to the DP calculated value (no need to update the preference) // library marker kkossev.deviceProfileLib, line 910
//            : true  - if a preference with the same name does not exist (no preference value to update) // library marker kkossev.deviceProfileLib, line 911
//    isEqual : false - the reported DP value is different than the corresponding preference (the preference needs to be updated!) // library marker kkossev.deviceProfileLib, line 912
//  // library marker kkossev.deviceProfileLib, line 913
//    hubitatEventValue - the converted DP value, scaled (divided by the scale factor) to match the corresponding preference type value // library marker kkossev.deviceProfileLib, line 914
// // library marker kkossev.deviceProfileLib, line 915
//  TODO: refactor! // library marker kkossev.deviceProfileLib, line 916
// // library marker kkossev.deviceProfileLib, line 917
def compareAndConvertTuyaToHubitatEventValue(foundItem, fncmd, doNotTrace=false) { // library marker kkossev.deviceProfileLib, line 918
    if (foundItem == null) { return [true, "none"] } // library marker kkossev.deviceProfileLib, line 919
    if (foundItem.type == null) { return [true, "none"] } // library marker kkossev.deviceProfileLib, line 920
    def hubitatEventValue   // could be integer or float or string // library marker kkossev.deviceProfileLib, line 921
    boolean isEqual // library marker kkossev.deviceProfileLib, line 922
    switch (foundItem.type) { // library marker kkossev.deviceProfileLib, line 923
        case "bool" :       // [0:"OFF", 1:"ON"]  // library marker kkossev.deviceProfileLib, line 924
        case "enum" :       // [0:"inactive", 1:"active"] // library marker kkossev.deviceProfileLib, line 925
            (isEqual, hubitatEventValue) = compareAndConvertStrings(foundItem, foundItem.map[fncmd as int] ?: "unknown", device.currentValue(foundItem.name) ?: "unknown") // library marker kkossev.deviceProfileLib, line 926
            break // library marker kkossev.deviceProfileLib, line 927
        case "value" :      // depends on foundItem.scale // library marker kkossev.deviceProfileLib, line 928
        case "number" : // library marker kkossev.deviceProfileLib, line 929
            (isEqual, hubitatEventValue) = compareAndConvertNumbers(foundItem, safeToInt(fncmd), safeToInt(device.currentValue(foundItem.name))) // library marker kkossev.deviceProfileLib, line 930
            break         // library marker kkossev.deviceProfileLib, line 931
        case "decimal" : // library marker kkossev.deviceProfileLib, line 932
            (isEqual, hubitatEventValue) = compareAndConvertDecimals(foundItem, safeToDouble(fncmd), safeToDouble(device.currentValue(foundItem.name)))             // library marker kkossev.deviceProfileLib, line 933
            break // library marker kkossev.deviceProfileLib, line 934
        default : // library marker kkossev.deviceProfileLib, line 935
            logDebug "compareAndConvertTuyaToHubitatEventValue: unsupported dpType %{foundItem.type}" // library marker kkossev.deviceProfileLib, line 936
            return [true, "none"]   // fallback - assume equal // library marker kkossev.deviceProfileLib, line 937
    } // library marker kkossev.deviceProfileLib, line 938
    //if (!doNotTrace)  log.trace "foundItem=${foundItem.name} <b>isEqual=${isEqual}</b> attrValue=${attrValue} fncmd=${fncmd}  foundItem.scale=${foundItem.scale } valueScaled=${valueScaled} " // library marker kkossev.deviceProfileLib, line 939
    return [isEqual, hubitatEventValue] // library marker kkossev.deviceProfileLib, line 940
} // library marker kkossev.deviceProfileLib, line 941


def preProc(foundItem, fncmd_orig) { // library marker kkossev.deviceProfileLib, line 944
    def fncmd = fncmd_orig // library marker kkossev.deviceProfileLib, line 945
    if (foundItem == null) { return fncmd } // library marker kkossev.deviceProfileLib, line 946
    if (foundItem.preProc == null) { return fncmd } // library marker kkossev.deviceProfileLib, line 947
    String preProcFunction = foundItem.preProc // library marker kkossev.deviceProfileLib, line 948
    //logDebug "preProc: foundItem.preProc = ${preProcFunction}" // library marker kkossev.deviceProfileLib, line 949
    // check if preProc method exists // library marker kkossev.deviceProfileLib, line 950
    if (!this.respondsTo(preProcFunction)) { // library marker kkossev.deviceProfileLib, line 951
        logDebug "preProc: function <b>${preProcFunction}</b> not found" // library marker kkossev.deviceProfileLib, line 952
        return fncmd_orig // library marker kkossev.deviceProfileLib, line 953
    } // library marker kkossev.deviceProfileLib, line 954
    // execute the preProc function // library marker kkossev.deviceProfileLib, line 955
    try { // library marker kkossev.deviceProfileLib, line 956
        fncmd = "$preProcFunction"(fncmd_orig) // library marker kkossev.deviceProfileLib, line 957
    } // library marker kkossev.deviceProfileLib, line 958
    catch (e) { // library marker kkossev.deviceProfileLib, line 959
        logWarn "preProc: Exception '${e}'caught while processing <b>$preProcFunction</b>(<b>$fncmd_orig</b>) (val=${fncmd}))" // library marker kkossev.deviceProfileLib, line 960
        return fncmd_orig // library marker kkossev.deviceProfileLib, line 961
    } // library marker kkossev.deviceProfileLib, line 962
    //logDebug "setFunction result is ${fncmd}" // library marker kkossev.deviceProfileLib, line 963
    return fncmd // library marker kkossev.deviceProfileLib, line 964
} // library marker kkossev.deviceProfileLib, line 965


/** // library marker kkossev.deviceProfileLib, line 968
 * Processes a Tuya DP (Data Point) received from the device, based on the device profile and its defined Tuya DPs. // library marker kkossev.deviceProfileLib, line 969
 * If a preference exists for the DP, it updates the preference value and sends an event if the DP is declared as an attribute. // library marker kkossev.deviceProfileLib, line 970
 * If no preference exists for the DP, it logs the DP value as an info message. // library marker kkossev.deviceProfileLib, line 971
 * If the DP is spammy (not needed for anything), it does not perform any further processing. // library marker kkossev.deviceProfileLib, line 972
 *  // library marker kkossev.deviceProfileLib, line 973
 * @param descMap The description map of the received DP. // library marker kkossev.deviceProfileLib, line 974
 * @param dp The value of the received DP. // library marker kkossev.deviceProfileLib, line 975
 * @param dp_id The ID of the received DP. // library marker kkossev.deviceProfileLib, line 976
 * @param fncmd The command of the received DP. // library marker kkossev.deviceProfileLib, line 977
 * @param dp_len The length of the received DP. // library marker kkossev.deviceProfileLib, line 978
 * @return true if the DP was processed successfully, false otherwise. // library marker kkossev.deviceProfileLib, line 979
 */ // library marker kkossev.deviceProfileLib, line 980
boolean processTuyaDPfromDeviceProfile(descMap, dp, dp_id, fncmd_orig, dp_len=0) { // library marker kkossev.deviceProfileLib, line 981
    def fncmd = fncmd_orig // library marker kkossev.deviceProfileLib, line 982
    if (state.deviceProfile == null)  { return false } // library marker kkossev.deviceProfileLib, line 983
    //if (isSpammyDPsToIgnore(descMap)) { return true  }       // do not perform any further processing, if this is a spammy report that is not needed for anyhting (such as the LED status)  // library marker kkossev.deviceProfileLib, line 984

    def tuyaDPsMap = deviceProfilesV2[state.deviceProfile].tuyaDPs // library marker kkossev.deviceProfileLib, line 986
    if (tuyaDPsMap == null || tuyaDPsMap == []) { return false }    // no any Tuya DPs defined in the Device Profile // library marker kkossev.deviceProfileLib, line 987

    def foundItem = null // library marker kkossev.deviceProfileLib, line 989
    tuyaDPsMap.each { item -> // library marker kkossev.deviceProfileLib, line 990
         if (item['dp'] == (dp as int)) { // library marker kkossev.deviceProfileLib, line 991
            foundItem = item // library marker kkossev.deviceProfileLib, line 992
            return // library marker kkossev.deviceProfileLib, line 993
        } // library marker kkossev.deviceProfileLib, line 994
    } // library marker kkossev.deviceProfileLib, line 995
    if (foundItem == null) {  // library marker kkossev.deviceProfileLib, line 996
        // DP was not found into the tuyaDPs list for this particular deviceProfile // library marker kkossev.deviceProfileLib, line 997
        //updateStateUnknownDPs(descMap, dp, dp_id, fncmd, dp_len) // library marker kkossev.deviceProfileLib, line 998
        // continue processing the DP report in the old code ... // library marker kkossev.deviceProfileLib, line 999
        return false  // library marker kkossev.deviceProfileLib, line 1000
    } // library marker kkossev.deviceProfileLib, line 1001
    // added 10/31/2023 - preProc the DP value if needed // library marker kkossev.deviceProfileLib, line 1002
    if (foundItem.preProc != null) { // library marker kkossev.deviceProfileLib, line 1003
        fncmd = preProc(foundItem, fncmd_orig) // library marker kkossev.deviceProfileLib, line 1004
        logDebug "<b>preProc</b> changed ${foundItem.name} from ${fncmd_orig} to ${fncmd}" // library marker kkossev.deviceProfileLib, line 1005
    } // library marker kkossev.deviceProfileLib, line 1006
    else { // library marker kkossev.deviceProfileLib, line 1007
        // logDebug "no preProc for ${foundItem.name} : ${foundItem}" // library marker kkossev.deviceProfileLib, line 1008
    } // library marker kkossev.deviceProfileLib, line 1009

    def name = foundItem.name                                    // preference name as in the tuyaDPs map // library marker kkossev.deviceProfileLib, line 1011
    def existingPrefValue = settings[name]                        // preference name as in Hubitat settings (preferences), if already created. // library marker kkossev.deviceProfileLib, line 1012
    def perfValue = null   // preference value // library marker kkossev.deviceProfileLib, line 1013
    boolean preferenceExists = existingPrefValue != null          // check if there is an existing preference for this dp   // library marker kkossev.deviceProfileLib, line 1014
    boolean isAttribute = device.hasAttribute(foundItem.name)    // check if there is such a attribute for this dp // library marker kkossev.deviceProfileLib, line 1015
    boolean isEqual = false // library marker kkossev.deviceProfileLib, line 1016
    boolean wasChanged = false // library marker kkossev.deviceProfileLib, line 1017
    boolean doNotTrace = false  // isSpammyDPsToNotTrace(descMap)          // do not log/trace the spammy DP's TODO! // library marker kkossev.deviceProfileLib, line 1018
    if (!doNotTrace) { // library marker kkossev.deviceProfileLib, line 1019
        //logDebug "processTuyaDPfromDeviceProfile dp=${dp} ${foundItem.name} (type ${foundItem.type}, rw=${foundItem.rw} isAttribute=${isAttribute}, preferenceExists=${preferenceExists}) value is ${fncmd} - ${foundItem.description}" // library marker kkossev.deviceProfileLib, line 1020
    } // library marker kkossev.deviceProfileLib, line 1021
    // check if the dp has the same value as the last one, or the value has changed // library marker kkossev.deviceProfileLib, line 1022
    // the previous value may be stored in an attribute, as a preference, as both attribute and preference or not stored anywhere ... // library marker kkossev.deviceProfileLib, line 1023
    String unitText     = foundItem.unit != null ? "$foundItem.unit" : "" // library marker kkossev.deviceProfileLib, line 1024
    def valueScaled    // can be number or decimal or string // library marker kkossev.deviceProfileLib, line 1025
    String descText = descText  = "${name} is ${fncmd} ${unitText}"    // the default description text for log events // library marker kkossev.deviceProfileLib, line 1026

    // TODO - check if DP is in the list of the received state.tuyaDPs - then we have something to compare ! // library marker kkossev.deviceProfileLib, line 1028
    if (!isAttribute && !preferenceExists) {                    // if the previous value of this dp is not stored anywhere - just seend an Info log if Debug is enabled // library marker kkossev.deviceProfileLib, line 1029
        if (!doNotTrace) {                                      // only if the DP is not in the spammy list // library marker kkossev.deviceProfileLib, line 1030
            (isEqual, valueScaled) = compareAndConvertTuyaToHubitatEventValue(foundItem, fncmd, doNotTrace) // library marker kkossev.deviceProfileLib, line 1031
            descText  = "${name} is ${valueScaled} ${unitText}"         // library marker kkossev.deviceProfileLib, line 1032
            if (settings.logEnable) { logInfo "${descText}"} // library marker kkossev.deviceProfileLib, line 1033
        } // library marker kkossev.deviceProfileLib, line 1034
        // no more processing is needed, as this DP is not a preference and not an attribute // library marker kkossev.deviceProfileLib, line 1035
        return true // library marker kkossev.deviceProfileLib, line 1036
    } // library marker kkossev.deviceProfileLib, line 1037

    // first, check if there is a preference defined to be updated // library marker kkossev.deviceProfileLib, line 1039
    if (preferenceExists) { // library marker kkossev.deviceProfileLib, line 1040
        // preference exists and its's value is extracted // library marker kkossev.deviceProfileLib, line 1041
        def oldPerfValue = device.getSetting(name) // library marker kkossev.deviceProfileLib, line 1042
        (isEqual, perfValue)  = compareAndConvertTuyaToHubitatPreferenceValue(foundItem, fncmd, existingPrefValue)     // library marker kkossev.deviceProfileLib, line 1043
        if (isEqual == true) {                                 // the DP value is the same as the preference value - no need to update the preference // library marker kkossev.deviceProfileLib, line 1044
            logDebug "no change: preference '${name}' existingPrefValue ${existingPrefValue} equals scaled value ${perfValue} (dp raw value ${fncmd})" // library marker kkossev.deviceProfileLib, line 1045
        } // library marker kkossev.deviceProfileLib, line 1046
        else { // library marker kkossev.deviceProfileLib, line 1047
            logDebug "preference '${name}' value ${existingPrefValue} <b>differs</b> from the new scaled value ${perfValue} (dp raw value ${fncmd})" // library marker kkossev.deviceProfileLib, line 1048
            if (debug) log.info "updating par ${name} from ${existingPrefValue} to ${perfValue} type ${foundItem.type}"  // library marker kkossev.deviceProfileLib, line 1049
            try { // library marker kkossev.deviceProfileLib, line 1050
                device.updateSetting("${name}",[value:perfValue, type:foundItem.type]) // library marker kkossev.deviceProfileLib, line 1051
                wasChanged = true // library marker kkossev.deviceProfileLib, line 1052
            } // library marker kkossev.deviceProfileLib, line 1053
            catch (e) { // library marker kkossev.deviceProfileLib, line 1054
                logWarn "exception ${e} caught while updating preference ${name} to ${fncmd}, type ${foundItem.type}"  // library marker kkossev.deviceProfileLib, line 1055
            } // library marker kkossev.deviceProfileLib, line 1056
        } // library marker kkossev.deviceProfileLib, line 1057
    } // library marker kkossev.deviceProfileLib, line 1058
    else {    // no preference exists for this dp // library marker kkossev.deviceProfileLib, line 1059
        // if not in the spammy list - log it! // library marker kkossev.deviceProfileLib, line 1060
        unitText = foundItem.unit != null ? "$foundItem.unit" : "" // library marker kkossev.deviceProfileLib, line 1061
        //logInfo "${name} is ${fncmd} ${unitText}" // library marker kkossev.deviceProfileLib, line 1062
    }     // library marker kkossev.deviceProfileLib, line 1063

    // second, send an event if this is declared as an attribute! // library marker kkossev.deviceProfileLib, line 1065
    if (isAttribute) {                                         // this DP has an attribute that must be sent in an Event // library marker kkossev.deviceProfileLib, line 1066
        (isEqual, valueScaled) = compareAndConvertTuyaToHubitatEventValue(foundItem, fncmd, doNotTrace) // library marker kkossev.deviceProfileLib, line 1067
        descText  = "${name} is ${valueScaled} ${unitText}" // library marker kkossev.deviceProfileLib, line 1068
        if (settings?.logEnable == true) { descText += " (raw:${fncmd})" } // library marker kkossev.deviceProfileLib, line 1069

        if (isEqual && !wasChanged) {                        // this DP report has the same value as the last one - just send a debug log and move along! // library marker kkossev.deviceProfileLib, line 1071
            if (!doNotTrace) { // library marker kkossev.deviceProfileLib, line 1072
                if (settings.logEnable) { logInfo "${descText} (no change)"} // library marker kkossev.deviceProfileLib, line 1073
            } // library marker kkossev.deviceProfileLib, line 1074
            // patch for inverted motion sensor 2-in-1 // library marker kkossev.deviceProfileLib, line 1075
            if (name == "motion" && is2in1()) { // library marker kkossev.deviceProfileLib, line 1076
                logDebug "patch for inverted motion sensor 2-in-1" // library marker kkossev.deviceProfileLib, line 1077
                // continue ...  // library marker kkossev.deviceProfileLib, line 1078
            } // library marker kkossev.deviceProfileLib, line 1079
            else { // library marker kkossev.deviceProfileLib, line 1080
                return true      // we are done (if there was potentially a preference, it should be already set to the same value) // library marker kkossev.deviceProfileLib, line 1081
            } // library marker kkossev.deviceProfileLib, line 1082
        } // library marker kkossev.deviceProfileLib, line 1083

        // DP value (fncmd) is not equal to the attribute last value or was changed- we must send an event! // library marker kkossev.deviceProfileLib, line 1085
        def value = safeToInt(fncmd) // library marker kkossev.deviceProfileLib, line 1086
        def divider = safeToInt(foundItem.scale ?: 1) ?: 1 // library marker kkossev.deviceProfileLib, line 1087
        def valueCorrected = value / divider // library marker kkossev.deviceProfileLib, line 1088
        if (!doNotTrace) { logTrace "value=${value} foundItem.scale=${foundItem.scale}  divider=${divider} valueCorrected=${valueCorrected}" } // library marker kkossev.deviceProfileLib, line 1089
        // process the events in the device specific driver.. // library marker kkossev.deviceProfileLib, line 1090
        if (DEVICE_TYPE in ["Thermostat"])  { processDeviceEventThermostat(name, valueScaled, unitText, descText) } // library marker kkossev.deviceProfileLib, line 1091
        else { // library marker kkossev.deviceProfileLib, line 1092
            switch (name) { // library marker kkossev.deviceProfileLib, line 1093
                case "motion" : // library marker kkossev.deviceProfileLib, line 1094
                    handleMotion(motionActive = fncmd)  // TODO !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! // library marker kkossev.deviceProfileLib, line 1095
                    break // library marker kkossev.deviceProfileLib, line 1096
                case "temperature" : // library marker kkossev.deviceProfileLib, line 1097
                    //temperatureEvent(fncmd / getTemperatureDiv()) // library marker kkossev.deviceProfileLib, line 1098
                    handleTemperatureEvent(valueScaled as Float) // library marker kkossev.deviceProfileLib, line 1099
                    break // library marker kkossev.deviceProfileLib, line 1100
                case "humidity" : // library marker kkossev.deviceProfileLib, line 1101
                    handleHumidityEvent(valueScaled) // library marker kkossev.deviceProfileLib, line 1102
                    break // library marker kkossev.deviceProfileLib, line 1103
                case "illuminance" : // library marker kkossev.deviceProfileLib, line 1104
                case "illuminance_lux" : // library marker kkossev.deviceProfileLib, line 1105
                    handleIlluminanceEvent(valueCorrected)        // library marker kkossev.deviceProfileLib, line 1106
                    break // library marker kkossev.deviceProfileLib, line 1107
                case "pushed" : // library marker kkossev.deviceProfileLib, line 1108
                    logDebug "button event received fncmd=${fncmd} valueScaled=${valueScaled} valueCorrected=${valueCorrected}" // library marker kkossev.deviceProfileLib, line 1109
                    buttonEvent(valueScaled) // library marker kkossev.deviceProfileLib, line 1110
                    break // library marker kkossev.deviceProfileLib, line 1111
                default : // library marker kkossev.deviceProfileLib, line 1112
                    sendEvent(name : name, value : valueScaled, unit:unitText, descriptionText: descText, type: "physical", isStateChange: true)    // attribute value is changed - send an event ! // library marker kkossev.deviceProfileLib, line 1113
                    if (!doNotTrace) { // library marker kkossev.deviceProfileLib, line 1114
                        logDebug "event ${name} sent w/ value ${valueScaled}" // library marker kkossev.deviceProfileLib, line 1115
                        logInfo "${descText}"                                 // send an Info log also (because value changed )  // TODO - check whether Info log will be sent also for spammy DPs ?                                // library marker kkossev.deviceProfileLib, line 1116
                    } // library marker kkossev.deviceProfileLib, line 1117
                    break // library marker kkossev.deviceProfileLib, line 1118
            } // library marker kkossev.deviceProfileLib, line 1119
            //log.trace "attrValue=${attrValue} valueScaled=${valueScaled} equal=${isEqual}" // library marker kkossev.deviceProfileLib, line 1120

        } // library marker kkossev.deviceProfileLib, line 1122
    } // library marker kkossev.deviceProfileLib, line 1123
    // all processing was done here! // library marker kkossev.deviceProfileLib, line 1124
    return true // library marker kkossev.deviceProfileLib, line 1125
} // library marker kkossev.deviceProfileLib, line 1126


// ~~~~~ end include (142) kkossev.deviceProfileLib ~~~~~
